/**
 * Binance Gift Card REST API
 *
 * OpenAPI Specification for the Binance Gift Card REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { MarketDataApi } from '../../../src/rest-api';
import {
    CreateADualTokenGiftCardRequest,
    CreateASingleTokenGiftCardRequest,
    FetchRsaPublicKeyRequest,
    FetchTokenLimitRequest,
    RedeemABinanceGiftCardRequest,
    VerifyBinanceGiftCardByGiftCardNumberRequest,
} from '../../../src/rest-api';
import type {
    CreateADualTokenGiftCardResponse,
    CreateASingleTokenGiftCardResponse,
    FetchRsaPublicKeyResponse,
    FetchTokenLimitResponse,
    RedeemABinanceGiftCardResponse,
    VerifyBinanceGiftCardByGiftCardNumberResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('createADualTokenGiftCard()', () => {
        it('should execute createADualTokenGiftCard() successfully with required parameters only', async () => {
            const params: CreateADualTokenGiftCardRequest = {
                baseToken: 'baseToken_example',
                faceToken: 'faceToken_example',
                baseTokenAmount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        referenceNo: '0033002144060553',
                        code: '6H9EKF5ECCWFBHGE',
                        expiredTime: 1727417154000,
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'createADualTokenGiftCard').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateADualTokenGiftCardResponse>)
            );
            const response = await client.createADualTokenGiftCard(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute createADualTokenGiftCard() successfully with optional parameters', async () => {
            const params: CreateADualTokenGiftCardRequest = {
                baseToken: 'baseToken_example',
                faceToken: 'faceToken_example',
                baseTokenAmount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        referenceNo: '0033002144060553',
                        code: '6H9EKF5ECCWFBHGE',
                        expiredTime: 1727417154000,
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'createADualTokenGiftCard').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateADualTokenGiftCardResponse>)
            );
            const response = await client.createADualTokenGiftCard(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when baseToken is missing', async () => {
            const _params: CreateADualTokenGiftCardRequest = {
                baseToken: 'baseToken_example',
                faceToken: 'faceToken_example',
                baseTokenAmount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.baseToken;

            await expect(client.createADualTokenGiftCard(params)).rejects.toThrow(
                'Required parameter baseToken was null or undefined when calling createADualTokenGiftCard.'
            );
        });

        it('should throw RequiredError when faceToken is missing', async () => {
            const _params: CreateADualTokenGiftCardRequest = {
                baseToken: 'baseToken_example',
                faceToken: 'faceToken_example',
                baseTokenAmount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.faceToken;

            await expect(client.createADualTokenGiftCard(params)).rejects.toThrow(
                'Required parameter faceToken was null or undefined when calling createADualTokenGiftCard.'
            );
        });

        it('should throw RequiredError when baseTokenAmount is missing', async () => {
            const _params: CreateADualTokenGiftCardRequest = {
                baseToken: 'baseToken_example',
                faceToken: 'faceToken_example',
                baseTokenAmount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.baseTokenAmount;

            await expect(client.createADualTokenGiftCard(params)).rejects.toThrow(
                'Required parameter baseTokenAmount was null or undefined when calling createADualTokenGiftCard.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CreateADualTokenGiftCardRequest = {
                baseToken: 'baseToken_example',
                faceToken: 'faceToken_example',
                baseTokenAmount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'createADualTokenGiftCard')
                .mockRejectedValueOnce(mockError);
            await expect(client.createADualTokenGiftCard(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('createASingleTokenGiftCard()', () => {
        it('should execute createASingleTokenGiftCard() successfully with required parameters only', async () => {
            const params: CreateASingleTokenGiftCardRequest = {
                token: 'token_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        referenceNo: '0033002144060553',
                        code: '6H9EKF5ECCWFBHGE',
                        expiredTime: 1727417154000,
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'createASingleTokenGiftCard').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateASingleTokenGiftCardResponse>)
            );
            const response = await client.createASingleTokenGiftCard(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute createASingleTokenGiftCard() successfully with optional parameters', async () => {
            const params: CreateASingleTokenGiftCardRequest = {
                token: 'token_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        referenceNo: '0033002144060553',
                        code: '6H9EKF5ECCWFBHGE',
                        expiredTime: 1727417154000,
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'createASingleTokenGiftCard').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateASingleTokenGiftCardResponse>)
            );
            const response = await client.createASingleTokenGiftCard(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when token is missing', async () => {
            const _params: CreateASingleTokenGiftCardRequest = {
                token: 'token_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.token;

            await expect(client.createASingleTokenGiftCard(params)).rejects.toThrow(
                'Required parameter token was null or undefined when calling createASingleTokenGiftCard.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: CreateASingleTokenGiftCardRequest = {
                token: 'token_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.createASingleTokenGiftCard(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling createASingleTokenGiftCard.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CreateASingleTokenGiftCardRequest = {
                token: 'token_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'createASingleTokenGiftCard')
                .mockRejectedValueOnce(mockError);
            await expect(client.createASingleTokenGiftCard(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('fetchRsaPublicKey()', () => {
        it('should execute fetchRsaPublicKey() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCXBBVKLAc1GQ5FsIFFqOHrPTox5noBONIKr+IAedTR9FkVxq6e65updEbfdhRNkMOeYIO2i0UylrjGC0X8YSoIszmrVHeV0l06Zh1oJuZos1+7N+WLuz9JvlPaawof3GUakTxYWWCa9+8KIbLKsoKMdfS96VT+8iOXO3quMGKUmQIDAQAB',
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'fetchRsaPublicKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchRsaPublicKeyResponse>)
            );
            const response = await client.fetchRsaPublicKey();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fetchRsaPublicKey() successfully with optional parameters', async () => {
            const params: FetchRsaPublicKeyRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCXBBVKLAc1GQ5FsIFFqOHrPTox5noBONIKr+IAedTR9FkVxq6e65updEbfdhRNkMOeYIO2i0UylrjGC0X8YSoIszmrVHeV0l06Zh1oJuZos1+7N+WLuz9JvlPaawof3GUakTxYWWCa9+8KIbLKsoKMdfS96VT+8iOXO3quMGKUmQIDAQAB',
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'fetchRsaPublicKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchRsaPublicKeyResponse>)
            );
            const response = await client.fetchRsaPublicKey(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fetchRsaPublicKey').mockRejectedValueOnce(mockError);
            await expect(client.fetchRsaPublicKey()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fetchTokenLimit()', () => {
        it('should execute fetchTokenLimit() successfully with required parameters only', async () => {
            const params: FetchTokenLimitRequest = {
                baseToken: 'baseToken_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: [{ coin: 'BNB', fromMin: '0.01', fromMax: '1' }],
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'fetchTokenLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchTokenLimitResponse>)
            );
            const response = await client.fetchTokenLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fetchTokenLimit() successfully with optional parameters', async () => {
            const params: FetchTokenLimitRequest = {
                baseToken: 'baseToken_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: [{ coin: 'BNB', fromMin: '0.01', fromMax: '1' }],
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'fetchTokenLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchTokenLimitResponse>)
            );
            const response = await client.fetchTokenLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when baseToken is missing', async () => {
            const _params: FetchTokenLimitRequest = {
                baseToken: 'baseToken_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.baseToken;

            await expect(client.fetchTokenLimit(params)).rejects.toThrow(
                'Required parameter baseToken was null or undefined when calling fetchTokenLimit.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FetchTokenLimitRequest = {
                baseToken: 'baseToken_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fetchTokenLimit').mockRejectedValueOnce(mockError);
            await expect(client.fetchTokenLimit(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemABinanceGiftCard()', () => {
        it('should execute redeemABinanceGiftCard() successfully with required parameters only', async () => {
            const params: RedeemABinanceGiftCardRequest = {
                code: 'code_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        referenceNo: '0033002328060227',
                        identityNo: '10317392647411060736',
                        token: 'BNB',
                        amount: '0.00000001',
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'redeemABinanceGiftCard').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemABinanceGiftCardResponse>)
            );
            const response = await client.redeemABinanceGiftCard(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemABinanceGiftCard() successfully with optional parameters', async () => {
            const params: RedeemABinanceGiftCardRequest = {
                code: 'code_example',
                externalUid: 'externalUid_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        referenceNo: '0033002328060227',
                        identityNo: '10317392647411060736',
                        token: 'BNB',
                        amount: '0.00000001',
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'redeemABinanceGiftCard').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemABinanceGiftCardResponse>)
            );
            const response = await client.redeemABinanceGiftCard(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when code is missing', async () => {
            const _params: RedeemABinanceGiftCardRequest = {
                code: 'code_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.code;

            await expect(client.redeemABinanceGiftCard(params)).rejects.toThrow(
                'Required parameter code was null or undefined when calling redeemABinanceGiftCard.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemABinanceGiftCardRequest = {
                code: 'code_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'redeemABinanceGiftCard')
                .mockRejectedValueOnce(mockError);
            await expect(client.redeemABinanceGiftCard(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('verifyBinanceGiftCardByGiftCardNumber()', () => {
        it('should execute verifyBinanceGiftCardByGiftCardNumber() successfully with required parameters only', async () => {
            const params: VerifyBinanceGiftCardByGiftCardNumberRequest = {
                referenceNo: 'referenceNo_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: { valid: true, token: 'BNB', amount: '0.00000001' },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'verifyBinanceGiftCardByGiftCardNumber').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<VerifyBinanceGiftCardByGiftCardNumberResponse>)
            );
            const response = await client.verifyBinanceGiftCardByGiftCardNumber(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute verifyBinanceGiftCardByGiftCardNumber() successfully with optional parameters', async () => {
            const params: VerifyBinanceGiftCardByGiftCardNumberRequest = {
                referenceNo: 'referenceNo_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: { valid: true, token: 'BNB', amount: '0.00000001' },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'verifyBinanceGiftCardByGiftCardNumber').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<VerifyBinanceGiftCardByGiftCardNumberResponse>)
            );
            const response = await client.verifyBinanceGiftCardByGiftCardNumber(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when referenceNo is missing', async () => {
            const _params: VerifyBinanceGiftCardByGiftCardNumberRequest = {
                referenceNo: 'referenceNo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.referenceNo;

            await expect(client.verifyBinanceGiftCardByGiftCardNumber(params)).rejects.toThrow(
                'Required parameter referenceNo was null or undefined when calling verifyBinanceGiftCardByGiftCardNumber.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: VerifyBinanceGiftCardByGiftCardNumberRequest = {
                referenceNo: 'referenceNo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'verifyBinanceGiftCardByGiftCardNumber')
                .mockRejectedValueOnce(mockError);
            await expect(client.verifyBinanceGiftCardByGiftCardNumber(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
