/**
 * Binance NFT REST API
 *
 * OpenAPI Specification for the Binance NFT REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { NFTApi } from '../../../src/rest-api';
import {
    GetNFTAssetRequest,
    GetNFTDepositHistoryRequest,
    GetNFTTransactionHistoryRequest,
    GetNFTWithdrawHistoryRequest,
} from '../../../src/rest-api';
import type {
    GetNFTAssetResponse,
    GetNFTDepositHistoryResponse,
    GetNFTTransactionHistoryResponse,
    GetNFTWithdrawHistoryResponse,
} from '../../../src/rest-api/types';

describe('NFTApi', () => {
    let client: NFTApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new NFTApi(config);
    });

    describe('getNFTAsset()', () => {
        it('should execute getNFTAsset() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    total: 347,
                    list: [
                        {
                            network: 'BSC',
                            contractAddress: 'REGULAR11234567891779',
                            tokenId: '100900000017',
                        },
                        { network: 'BSC', contractAddress: 'SSMDQ8W59', tokenId: '200500000011' },
                        { network: 'BSC', contractAddress: 'SSMDQ8W59', tokenId: '200500000019' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTAssetResponse>)
            );
            const response = await client.getNFTAsset();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getNFTAsset() successfully with optional parameters', async () => {
            const params: GetNFTAssetRequest = {
                limit: 50,
                page: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 347,
                    list: [
                        {
                            network: 'BSC',
                            contractAddress: 'REGULAR11234567891779',
                            tokenId: '100900000017',
                        },
                        { network: 'BSC', contractAddress: 'SSMDQ8W59', tokenId: '200500000011' },
                        { network: 'BSC', contractAddress: 'SSMDQ8W59', tokenId: '200500000019' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTAssetResponse>)
            );
            const response = await client.getNFTAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getNFTAsset').mockRejectedValueOnce(mockError);
            await expect(client.getNFTAsset()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getNFTDepositHistory()', () => {
        it('should execute getNFTDepositHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    list: [
                        {
                            network: 'ETH',
                            txID: null,
                            contractAdrress: '0xe507c961ee127d4439977a61af39c34eafee0dc6',
                            tokenId: '10014',
                            timestamp: 1629986047000,
                        },
                        {
                            network: 'BSC',
                            txID: null,
                            contractAdrress: '0x058451b463bab04f52c0799d55c4094f507acfa9',
                            tokenId: '10016',
                            timestamp: 1630083581000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTDepositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTDepositHistoryResponse>)
            );
            const response = await client.getNFTDepositHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getNFTDepositHistory() successfully with optional parameters', async () => {
            const params: GetNFTDepositHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 50,
                page: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    list: [
                        {
                            network: 'ETH',
                            txID: null,
                            contractAdrress: '0xe507c961ee127d4439977a61af39c34eafee0dc6',
                            tokenId: '10014',
                            timestamp: 1629986047000,
                        },
                        {
                            network: 'BSC',
                            txID: null,
                            contractAdrress: '0x058451b463bab04f52c0799d55c4094f507acfa9',
                            tokenId: '10016',
                            timestamp: 1630083581000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTDepositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTDepositHistoryResponse>)
            );
            const response = await client.getNFTDepositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getNFTDepositHistory').mockRejectedValueOnce(mockError);
            await expect(client.getNFTDepositHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getNFTTransactionHistory()', () => {
        it('should execute getNFTTransactionHistory() successfully with required parameters only', async () => {
            const params: GetNFTTransactionHistoryRequest = {
                orderType: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    list: [
                        {
                            orderNo: '1_470502070600699904',
                            tokens: [
                                {
                                    network: 'BSC',
                                    tokenId: '216000000496',
                                    contractAddress: 'MYSTERY_BOX0000087',
                                },
                            ],
                            tradeTime: 1626941236000,
                            tradeAmount: '19.60000000',
                            tradeCurrency: 'BNB',
                        },
                        {
                            orderNo: '1_488306442479116288',
                            tokens: [
                                {
                                    network: 'BSC',
                                    tokenId: '132900000007',
                                    contractAddress: '0xAf12111a592e408DAbC740849fcd5e68629D9fb6',
                                },
                            ],
                            tradeTime: 1631186130000,
                            tradeAmount: '192.00000000',
                            tradeCurrency: 'BNB',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTTransactionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTTransactionHistoryResponse>)
            );
            const response = await client.getNFTTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getNFTTransactionHistory() successfully with optional parameters', async () => {
            const params: GetNFTTransactionHistoryRequest = {
                orderType: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 50,
                page: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    list: [
                        {
                            orderNo: '1_470502070600699904',
                            tokens: [
                                {
                                    network: 'BSC',
                                    tokenId: '216000000496',
                                    contractAddress: 'MYSTERY_BOX0000087',
                                },
                            ],
                            tradeTime: 1626941236000,
                            tradeAmount: '19.60000000',
                            tradeCurrency: 'BNB',
                        },
                        {
                            orderNo: '1_488306442479116288',
                            tokens: [
                                {
                                    network: 'BSC',
                                    tokenId: '132900000007',
                                    contractAddress: '0xAf12111a592e408DAbC740849fcd5e68629D9fb6',
                                },
                            ],
                            tradeTime: 1631186130000,
                            tradeAmount: '192.00000000',
                            tradeCurrency: 'BNB',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTTransactionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTTransactionHistoryResponse>)
            );
            const response = await client.getNFTTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when orderType is missing', async () => {
            const _params: GetNFTTransactionHistoryRequest = {
                orderType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.orderType;

            await expect(client.getNFTTransactionHistory(params)).rejects.toThrow(
                'Required parameter orderType was null or undefined when calling getNFTTransactionHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetNFTTransactionHistoryRequest = {
                orderType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getNFTTransactionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getNFTTransactionHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getNFTWithdrawHistory()', () => {
        it('should execute getNFTWithdrawHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    total: 178,
                    list: [
                        {
                            network: 'ETH',
                            txID: '0x2be5eed31d787fdb4880bc631c8e76bdfb6150e137f5cf1732e0416ea206f57f',
                            contractAdrress: '0xe507c961ee127d4439977a61af39c34eafee0dc6',
                            tokenId: '1000001247',
                            timestamp: 1633674433000,
                            fee: 0.1,
                            feeAsset: 'ETH',
                        },
                        {
                            network: 'ETH',
                            txID: '0x3b3aea5c0a4faccd6f306641e6deb9713ab229ac233be3be227f580311e4362a',
                            contractAdrress: '0xe507c961ee127d4439977a61af39c34eafee0dc6',
                            tokenId: '40000030',
                            timestamp: 1633677022000,
                            fee: 0.1,
                            feeAsset: 'ETH',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTWithdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTWithdrawHistoryResponse>)
            );
            const response = await client.getNFTWithdrawHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getNFTWithdrawHistory() successfully with optional parameters', async () => {
            const params: GetNFTWithdrawHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 50,
                page: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 178,
                    list: [
                        {
                            network: 'ETH',
                            txID: '0x2be5eed31d787fdb4880bc631c8e76bdfb6150e137f5cf1732e0416ea206f57f',
                            contractAdrress: '0xe507c961ee127d4439977a61af39c34eafee0dc6',
                            tokenId: '1000001247',
                            timestamp: 1633674433000,
                            fee: 0.1,
                            feeAsset: 'ETH',
                        },
                        {
                            network: 'ETH',
                            txID: '0x3b3aea5c0a4faccd6f306641e6deb9713ab229ac233be3be227f580311e4362a',
                            contractAdrress: '0xe507c961ee127d4439977a61af39c34eafee0dc6',
                            tokenId: '40000030',
                            timestamp: 1633677022000,
                            fee: 0.1,
                            feeAsset: 'ETH',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getNFTWithdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetNFTWithdrawHistoryResponse>)
            );
            const response = await client.getNFTWithdrawHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getNFTWithdrawHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getNFTWithdrawHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
