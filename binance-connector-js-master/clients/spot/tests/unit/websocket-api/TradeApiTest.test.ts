/* eslint-disable @typescript-eslint/no-unused-vars */

/**
 * Binance Spot WebSocket API
 *
 * OpenAPI Specifications for the Binance Spot WebSocket API
 *
 * API documents:
 * - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
 * - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import WebSocketClient from 'ws';
import { EventEmitter } from 'events';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { jest, expect, beforeEach, afterEach, describe, it } from '@jest/globals';
import { ConfigurationWebsocketAPI, WebsocketAPIBase, randomString } from '@binance/common';

import {
    TradeApi,
    OrderCancelReplaceCancelReplaceModeEnum,
    OrderCancelReplaceSideEnum,
    OrderCancelReplaceTypeEnum,
    OrderListPlaceSideEnum,
    OrderListPlaceOcoSideEnum,
    OrderListPlaceOcoAboveTypeEnum,
    OrderListPlaceOcoBelowTypeEnum,
    OrderListPlaceOpoWorkingTypeEnum,
    OrderListPlaceOpoWorkingSideEnum,
    OrderListPlaceOpoPendingTypeEnum,
    OrderListPlaceOpoPendingSideEnum,
    OrderListPlaceOpocoWorkingTypeEnum,
    OrderListPlaceOpocoWorkingSideEnum,
    OrderListPlaceOpocoPendingSideEnum,
    OrderListPlaceOpocoPendingAboveTypeEnum,
    OrderListPlaceOtoWorkingTypeEnum,
    OrderListPlaceOtoWorkingSideEnum,
    OrderListPlaceOtoPendingTypeEnum,
    OrderListPlaceOtoPendingSideEnum,
    OrderListPlaceOtocoWorkingTypeEnum,
    OrderListPlaceOtocoWorkingSideEnum,
    OrderListPlaceOtocoPendingSideEnum,
    OrderListPlaceOtocoPendingAboveTypeEnum,
    OrderPlaceSideEnum,
    OrderPlaceTypeEnum,
    OrderTestSideEnum,
    OrderTestTypeEnum,
    SorOrderPlaceSideEnum,
    SorOrderPlaceTypeEnum,
    SorOrderTestSideEnum,
    SorOrderTestTypeEnum,
} from '../../../src/websocket-api';
import {
    OpenOrdersCancelAllRequest,
    OrderAmendKeepPriorityRequest,
    OrderCancelRequest,
    OrderCancelReplaceRequest,
    OrderListCancelRequest,
    OrderListPlaceRequest,
    OrderListPlaceOcoRequest,
    OrderListPlaceOpoRequest,
    OrderListPlaceOpocoRequest,
    OrderListPlaceOtoRequest,
    OrderListPlaceOtocoRequest,
    OrderPlaceRequest,
    OrderTestRequest,
    SorOrderPlaceRequest,
    SorOrderTestRequest,
} from '../../../src/websocket-api';

jest.mock('ws');

describe('TradeApi', () => {
    let websocketBase: WebsocketAPIBase;
    let websocketAPIClient: TradeApi;
    let mockWs: jest.Mocked<WebSocketClient> & EventEmitter;
    let mockResponse: {
        id?: string;
        status?: number;
        result?: object | null;
        response?: object | null;
        error?: {
            code?: number;
            msg?: string;
        };
        rateLimits?: object[];
    } = {
        result: {},
        response: {},
        rateLimits: [],
    };

    describe('openOrdersCancelAll()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute openOrdersCancelAll() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '778f938f-9041-4b88-9914-efbf64eeacc8',
                    status: 200,
                    result: [
                        {
                            orderListId: 19431,
                            contingencyType: 'OCO',
                            listStatusType: 'ALL_DONE',
                            listOrderStatus: 'ALL_DONE',
                            listClientOrderId: 'iuVNVJYYrByz6C4yGOPPK0',
                            transactionTime: 1660803702431,
                            symbol: 'BTCUSDT',
                            orders: [
                                {
                                    symbol: 'BTCUSDT',
                                    orderId: 12569099454,
                                    clientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                                },
                                {
                                    symbol: 'BTCUSDT',
                                    orderId: 12569099453,
                                    clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                                },
                            ],
                            orderReports: [
                                {
                                    symbol: 'BTCUSDT',
                                    origClientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                                    orderId: 12569099454,
                                    orderListId: 19431,
                                    clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                    transactTime: 1684804350068,
                                    price: '23400.00000000',
                                    origQty: '0.00850000',
                                    executedQty: '0.00000000',
                                    origQuoteOrderQty: '0.000000',
                                    cummulativeQuoteQty: '0.00000000',
                                    status: 'CANCELED',
                                    timeInForce: 'GTC',
                                    type: 'LIMIT_MAKER',
                                    side: 'BUY',
                                    selfTradePreventionMode: 'NONE',
                                },
                                {
                                    symbol: 'BTCUSDT',
                                    origClientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                                    orderId: 12569099453,
                                    orderListId: 19431,
                                    clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                    transactTime: 1684804350068,
                                    price: '23450.50000000',
                                    origQty: '0.00850000',
                                    executedQty: '0.00000000',
                                    origQuoteOrderQty: '0.000000',
                                    cummulativeQuoteQty: '0.00000000',
                                    status: 'CANCELED',
                                    timeInForce: 'GTC',
                                    type: 'STOP_LOSS_LIMIT',
                                    side: 'BUY',
                                    stopPrice: '23430.00000000',
                                    selfTradePreventionMode: 'NONE',
                                },
                            ],
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '4d96324ff9d44481926157',
                            orderId: 12569099453,
                            orderListId: -1,
                            clientOrderId: '91fe37ce9e69c90d6358c0',
                            transactTime: 1684804350068,
                            price: '23416.10000000',
                            origQty: '0.00847000',
                            executedQty: '0.00001000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.23416100',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            stopPrice: '0.00000000',
                            trailingDelta: 0,
                            trailingTime: -1,
                            icebergQty: '0.00000000',
                            strategyId: 37463720,
                            strategyType: 1000000,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OpenOrdersCancelAllRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.openOrdersCancelAll({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/openOrders.cancelAll'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OpenOrdersCancelAllRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.openOrdersCancelAll({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OpenOrdersCancelAllRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.openOrdersCancelAll(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderAmendKeepPriority()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderAmendKeepPriority() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '56374b46-3061-486b-a311-89ee972eb648',
                    status: 200,
                    result: {
                        transactTime: 1741924229819,
                        executionId: 60,
                        amendedOrder: {
                            symbol: 'BTUCSDT',
                            orderId: 23,
                            orderListId: 4,
                            origClientOrderId: 'my_pending_order',
                            clientOrderId: 'xbxXh5SSwaHS7oUEOCI88B',
                            price: '1.00000000',
                            qty: '5.00000000',
                            executedQty: '0.00000000',
                            preventedQty: '0.00000000',
                            quoteOrderQty: '0.00000000',
                            cumulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1741924204920,
                            selfTradePreventionMode: 'NONE',
                        },
                        listStatus: {
                            orderListId: 4,
                            contingencyType: 'OTO',
                            listOrderStatus: 'EXECUTING',
                            listClientOrderId: '8nOGLLawudj1QoOiwbroRH',
                            symbol: 'BTCUSDT',
                            orders: [
                                {
                                    symbol: 'BTCUSDT',
                                    orderId: 23,
                                    clientOrderId: 'xbxXh5SSwaHS7oUEOCI88B',
                                },
                                {
                                    symbol: 'BTCUSDT',
                                    orderId: 22,
                                    clientOrderId: 'g04EWsjaackzedjC9wRkWD',
                                },
                                {
                                    symbol: 'BTCUSDT',
                                    orderId: 23,
                                    clientOrderId: 'xbxXh5SSwaHS7oUEOCI88B',
                                },
                                {
                                    symbol: 'BTCUSDT',
                                    orderId: 22,
                                    clientOrderId: 'g04EWsjaackzedjC9wRkWD',
                                },
                            ],
                        },
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderAmendKeepPriority({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/order.amend.keepPriority'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderAmendKeepPriority({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderAmendKeepPriority(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderCancel()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderCancel() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '16eaf097-bbec-44b9-96ff-e97e6e875870',
                    status: 200,
                    result: {
                        symbol: 'BTCUSDT',
                        origClientOrderId: '4d96324ff9d44481926157',
                        orderId: 12569099453,
                        orderListId: 19431,
                        clientOrderId: '91fe37ce9e69c90d6358c0',
                        transactTime: 1684804350068,
                        price: '23416.10000000',
                        origQty: '0.00847000',
                        executedQty: '0.00001000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.23416100',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        stopPrice: '0.00000000',
                        trailingDelta: 0,
                        icebergQty: '0.00000000',
                        strategyId: 37463720,
                        strategyType: 1000000,
                        selfTradePreventionMode: 'NONE',
                        contingencyType: 'OCO',
                        listStatusType: 'ALL_DONE',
                        listOrderStatus: 'ALL_DONE',
                        listClientOrderId: 'iuVNVJYYrByz6C4yGOPPK0',
                        transactionTime: 1660803702431,
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569099454,
                                clientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569099453,
                                clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569099454,
                                clientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569099453,
                                clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                                orderId: 12569099454,
                                orderListId: 19431,
                                clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                transactTime: 1684804350068,
                                price: '23400.00000000',
                                origQty: '0.00850000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'BUY',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                                orderId: 12569099453,
                                orderListId: 19431,
                                clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                transactTime: 1684804350068,
                                price: '23450.50000000',
                                origQty: '0.00850000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'BUY',
                                stopPrice: '23430.00000000',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                                orderId: 12569099454,
                                orderListId: 19431,
                                clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                transactTime: 1684804350068,
                                price: '23400.00000000',
                                origQty: '0.00850000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'BUY',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                                orderId: 12569099453,
                                orderListId: 19431,
                                clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                transactTime: 1684804350068,
                                price: '23450.50000000',
                                origQty: '0.00850000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'BUY',
                                stopPrice: '23430.00000000',
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.cancel'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderCancel(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderCancelReplace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderCancelReplace() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '99de1036-b5e2-4e0f-9b5c-13d751c93a1a',
                    status: 200,
                    result: {
                        cancelResult: 'SUCCESS',
                        newOrderResult: 'SUCCESS',
                        cancelResponse: {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '4d96324ff9d44481926157',
                            orderId: 125690984230,
                            orderListId: -1,
                            clientOrderId: '91fe37ce9e69c90d6358c0',
                            transactTime: 1684804350068,
                            price: '23450.00000000',
                            origQty: '0.00847000',
                            executedQty: '0.00001000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.23450000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                        newOrderResponse: {
                            symbol: 'BTCUSDT',
                            orderId: 12569099453,
                            orderListId: -1,
                            clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                            transactTime: 1660813156959,
                            price: '23416.10000000',
                            origQty: '0.00847000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 50,
                            count: 1,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'DAY',
                            intervalNum: 1,
                            limit: 160000,
                            count: 1,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderCancelReplace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/order.cancelReplace'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderCancelReplace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderCancelReplace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListCancel()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListCancel() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'c5899911-d3f4-47ae-8835-97da553d27d0',
                    status: 200,
                    result: {
                        orderListId: 1274512,
                        contingencyType: 'OCO',
                        listStatusType: 'ALL_DONE',
                        listOrderStatus: 'ALL_DONE',
                        listClientOrderId: '6023531d7edaad348f5aff',
                        transactionTime: 1660801720215,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138902,
                                clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138901,
                                clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138902,
                                orderListId: 1274512,
                                clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                                transactTime: 1660801720215,
                                price: '23420.00000000',
                                origQty: '0.00650000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'SELL',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138901,
                                orderListId: 1274512,
                                clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                                transactTime: 1660801720215,
                                price: '23410.00000000',
                                origQty: '0.00650000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'SELL',
                                stopPrice: '23405.00000000',
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderListCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/orderList.cancel'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListCancel(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlace() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '57833dc0-e3f2-43fb-ba20-46480973b0aa',
                    status: 200,
                    result: {
                        orderListId: 1274512,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: '08985fedd9ea2cf6b28996',
                        transactionTime: 1660801713793,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138902,
                                clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138901,
                                clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138902,
                                orderListId: 1274512,
                                clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                                transactTime: 1660801713793,
                                price: '23420.00000000',
                                origQty: '0.00650000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'SELL',
                                workingTime: 1660801713793,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569138901,
                                orderListId: 1274512,
                                clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                                transactTime: 1660801713793,
                                price: '23410.00000000',
                                origQty: '0.00650000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'SELL',
                                stopPrice: '23405.00000000',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 50,
                            count: 2,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'DAY',
                            intervalNum: 1,
                            limit: 160000,
                            count: 2,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderListPlaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderListPlaceSideEnum.BUY,
                price: 1.0,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/orderList.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderListPlaceSideEnum.BUY,
                price: 1.0,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderListPlaceSideEnum.BUY,
                price: 1.0,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOco()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOco() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '56374a46-3261-486b-a211-99ed972eb648',
                    status: 200,
                    result: {
                        orderListId: 2,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'cKPMnDCbcLQILtDYM4f4fX',
                        transactionTime: 1711062760648,
                        symbol: 'LTCBNB',
                        orders: [
                            {
                                symbol: 'LTCBNB',
                                orderId: 3,
                                clientOrderId: 'Z2IMlR79XNY5LU0tOxrWyW',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 2,
                                clientOrderId: '0m6I4wfxvTUrOBSMUl0OPU',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'LTCBNB',
                                orderId: 3,
                                orderListId: 2,
                                clientOrderId: 'Z2IMlR79XNY5LU0tOxrWyW',
                                transactTime: 1711062760648,
                                price: '1.49999999',
                                origQty: '1.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'BUY',
                                workingTime: 1711062760648,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 2,
                                orderListId: 2,
                                clientOrderId: '0m6I4wfxvTUrOBSMUl0OPU',
                                transactTime: 1711062760648,
                                price: '1.50000000',
                                origQty: '1.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'BUY',
                                stopPrice: '1.50000001',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 50,
                            count: 2,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'DAY',
                            intervalNum: 1,
                            limit: 160000,
                            count: 2,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderListPlaceOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListPlaceOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListPlaceOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListPlaceOcoBelowTypeEnum.STOP_LOSS,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.oco'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListPlaceOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListPlaceOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListPlaceOcoBelowTypeEnum.STOP_LOSS,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListPlaceOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListPlaceOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListPlaceOcoBelowTypeEnum.STOP_LOSS,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOco(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOpo()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOpo() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '1762941318128',
                    status: 200,
                    result: {
                        orderListId: 2,
                        contingencyType: 'OTO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'OiOgqvRagBefpzdM5gjYX3',
                        transactionTime: 1762941318142,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 3,
                                clientOrderId: 'x7ISSjywZxFXOdzwsThNnd',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 2,
                                clientOrderId: 'pUzhKBbc0ZVdMScIRAqitH',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 3,
                                orderListId: 2,
                                clientOrderId: 'x7ISSjywZxFXOdzwsThNnd',
                                transactTime: 1762941318142,
                                price: '0.00000000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.00000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'PENDING_NEW',
                                timeInForce: 'GTC',
                                type: 'MARKET',
                                side: 'SELL',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 2,
                                orderListId: 2,
                                clientOrderId: 'pUzhKBbc0ZVdMScIRAqitH',
                                transactTime: 1762941318142,
                                price: '101496.00000000',
                                origQty: '0.00070000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.00000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT',
                                side: 'BUY',
                                workingTime: 1762941318142,
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                })
            );
            mockResponse.id = randomString();

            const params: OrderListPlaceOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListPlaceOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListPlaceOpoPendingSideEnum.BUY,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOpo({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.opo'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListPlaceOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListPlaceOpoPendingSideEnum.BUY,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOpo({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListPlaceOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListPlaceOpoPendingSideEnum.BUY,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOpo(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOpoco()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOpoco() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '1763000139090',
                    status: 200,
                    result: {
                        orderListId: 1,
                        contingencyType: 'OTO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'TVbG6ymkYMXTj7tczbOsBf',
                        transactionTime: 1763000139104,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 8,
                                clientOrderId: 'i76cGJWN9J1FpADS56TtQZ',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 7,
                                clientOrderId: 'kyIKnMLKQclE5FmyYgaMSo',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 6,
                                clientOrderId: '3czuJSeyjPwV9Xo28j1Dv3',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 8,
                                orderListId: 1,
                                clientOrderId: 'i76cGJWN9J1FpADS56TtQZ',
                                transactTime: 1763000139104,
                                price: '104261.00000000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.00000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'PENDING_NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'SELL',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 7,
                                orderListId: 1,
                                clientOrderId: 'kyIKnMLKQclE5FmyYgaMSo',
                                transactTime: 1763000139104,
                                price: '101613.00000000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.00000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'PENDING_NEW',
                                timeInForce: 'IOC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'SELL',
                                stopPrice: '10100.00000000',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 6,
                                orderListId: 1,
                                clientOrderId: '3czuJSeyjPwV9Xo28j1Dv3',
                                transactTime: 1763000139104,
                                price: '102496.00000000',
                                origQty: '0.00170000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.00000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT',
                                side: 'BUY',
                                workingTime: 1763000139104,
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                })
            );
            mockResponse.id = randomString();

            const params: OrderListPlaceOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListPlaceOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListPlaceOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOpoco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.opoco'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListPlaceOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListPlaceOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOpoco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListPlaceOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListPlaceOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOpoco(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOto()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOto() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '1712544395950',
                    status: 200,
                    result: {
                        orderListId: 626,
                        contingencyType: 'OTO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'KA4EBjGnzvSwSCQsDdTrlf',
                        transactionTime: 1712544395981,
                        symbol: '1712544378871',
                        orders: [
                            {
                                symbol: 'LTCBNB',
                                orderId: 14,
                                clientOrderId: '9MxJSE1TYkmyx5lbGLve7R',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 13,
                                clientOrderId: 'YiAUtM9yJjl1a2jXHSp9Ny',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'LTCBNB',
                                orderId: 14,
                                orderListId: 626,
                                clientOrderId: '9MxJSE1TYkmyx5lbGLve7R',
                                transactTime: 1712544395981,
                                price: '0.000000',
                                origQty: '1.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'PENDING_NEW',
                                timeInForce: 'GTC',
                                type: 'MARKET',
                                side: 'BUY',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 13,
                                orderListId: 626,
                                clientOrderId: 'YiAUtM9yJjl1a2jXHSp9Ny',
                                transactTime: 1712544395981,
                                price: '1.000000',
                                origQty: '1.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT',
                                side: 'SELL',
                                workingTime: 1712544395981,
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 10000000,
                            count: 10,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 1000,
                            count: 38,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderListPlaceOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListPlaceOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListPlaceOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOto({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.oto'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListPlaceOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListPlaceOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOto({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListPlaceOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListPlaceOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOto(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOtoco()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOtoco() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '1712544408508',
                    status: 200,
                    result: {
                        orderListId: 629,
                        contingencyType: 'OTO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'GaeJHjZPasPItFj4x7Mqm6',
                        transactionTime: 1712544408537,
                        symbol: '1712544378871',
                        orders: [
                            {
                                symbol: 'LTCBNB',
                                orderId: 25,
                                clientOrderId: 'ilpIoShcFZ1ZGgSASKxMPt',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 24,
                                clientOrderId: 'YcCPKCDMQIjNvLtNswt82X',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 23,
                                clientOrderId: 'OVQOpKwfmPCfaBTD0n7e7H',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'LTCBNB',
                                orderId: 25,
                                orderListId: 629,
                                clientOrderId: 'ilpIoShcFZ1ZGgSASKxMPt',
                                transactTime: 1712544408537,
                                price: '5.000000',
                                origQty: '5.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'PENDING_NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'SELL',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 24,
                                orderListId: 629,
                                clientOrderId: 'YcCPKCDMQIjNvLtNswt82X',
                                transactTime: 1712544408537,
                                price: '0.000000',
                                origQty: '5.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'PENDING_NEW',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS',
                                side: 'SELL',
                                stopPrice: '0.500000',
                                workingTime: -1,
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'LTCBNB',
                                orderId: 23,
                                orderListId: 629,
                                clientOrderId: 'OVQOpKwfmPCfaBTD0n7e7H',
                                transactTime: 1712544408537,
                                price: '1.500000',
                                origQty: '1.000000',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'NEW',
                                timeInForce: 'GTC',
                                type: 'LIMIT',
                                side: 'BUY',
                                workingTime: 1712544408537,
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 10000000,
                            count: 18,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 1000,
                            count: 65,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderListPlaceOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListPlaceOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListPlaceOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOtoco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.otoco'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListPlaceOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListPlaceOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOtoco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListPlaceOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListPlaceOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListPlaceOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListPlaceOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOtoco(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderPlace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderPlace() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '56374a46-3061-486b-a311-99ee972eb648',
                    status: 200,
                    result: {
                        symbol: 'BTCUSDT',
                        orderId: 12569099453,
                        orderListId: -1,
                        clientOrderId: '4d96324ff9d44481926157ec08158a40',
                        transactTime: 1660801715793,
                        price: '23416.10000000',
                        origQty: '0.00847000',
                        executedQty: '0.00847000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '198.33521500',
                        status: 'FILLED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1660801715793,
                        selfTradePreventionMode: 'NONE',
                        fills: [
                            {
                                price: '23416.50000000',
                                qty: '0.00212000',
                                commission: '0.000000',
                                commissionAsset: 'BNB',
                                tradeId: 1650422482,
                            },
                            {
                                price: '23416.10000000',
                                qty: '0.00635000',
                                commission: '0.000000',
                                commissionAsset: 'BNB',
                                tradeId: 1650422481,
                            },
                            {
                                price: '23416.50000000',
                                qty: '0.00212000',
                                commission: '0.000000',
                                commissionAsset: 'BNB',
                                tradeId: 1650422482,
                            },
                            {
                                price: '23416.10000000',
                                qty: '0.00635000',
                                commission: '0.000000',
                                commissionAsset: 'BNB',
                                tradeId: 1650422481,
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 50,
                            count: 1,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'DAY',
                            intervalNum: 1,
                            limit: 160000,
                            count: 1,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderPlaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderPlaceSideEnum.BUY,
                type: OrderPlaceTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderPlaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderPlaceSideEnum.BUY,
                type: OrderPlaceTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderPlaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderPlaceSideEnum.BUY,
                type: OrderPlaceTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderPlace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderTest()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderTest() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '6ffebe91-01d9-43ac-be99-57cf062e0e30',
                    status: 200,
                    result: {
                        standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                        specialCommissionForOrder: { maker: '0.05000000', taker: '0.06000000' },
                        taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                        discount: {
                            enabledForAccount: true,
                            enabledForSymbol: true,
                            discountAsset: 'BNB',
                            discount: '0.25000000',
                        },
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderTest({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.test'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderTest({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderTest(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('sorOrderPlace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute sorOrderPlace() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '3a4437e2-41a3-4c19-897c-9cadc5dce8b6',
                    status: 200,
                    result: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 2,
                            orderListId: -1,
                            clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                            transactTime: 1689149087774,
                            price: '31000.00000000',
                            origQty: '0.50000000',
                            executedQty: '0.50000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '14000.00000000',
                            status: 'FILLED',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1689149087774,
                            fills: [
                                {
                                    matchType: 'ONE_PARTY_TRADE_REPORT',
                                    price: '28000.00000000',
                                    qty: '0.50000000',
                                    commission: '0.00000000',
                                    commissionAsset: 'BTC',
                                    tradeId: -1,
                                    allocId: 0,
                                },
                            ],
                            workingFloor: 'SOR',
                            selfTradePreventionMode: 'NONE',
                            usedSor: true,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: SorOrderPlaceRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderPlaceSideEnum.BUY,
                type: SorOrderPlaceTypeEnum.MARKET,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.sorOrderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/sor.order.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: SorOrderPlaceRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderPlaceSideEnum.BUY,
                type: SorOrderPlaceTypeEnum.MARKET,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.sorOrderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: SorOrderPlaceRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderPlaceSideEnum.BUY,
                type: SorOrderPlaceTypeEnum.MARKET,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.sorOrderPlace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('sorOrderTest()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute sorOrderTest() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '3a4437e2-41a3-4c19-897c-9cadc5dce8b6',
                    status: 200,
                    result: {
                        standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                        taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                        discount: {
                            enabledForAccount: true,
                            enabledForSymbol: true,
                            discountAsset: 'BNB',
                            discount: '0.25',
                        },
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.sorOrderTest({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/sor.order.test'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.sorOrderTest({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.sorOrderTest(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });
});
