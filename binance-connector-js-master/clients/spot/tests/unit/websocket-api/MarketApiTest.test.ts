/* eslint-disable @typescript-eslint/no-unused-vars */

/**
 * Binance Spot WebSocket API
 *
 * OpenAPI Specifications for the Binance Spot WebSocket API
 *
 * API documents:
 * - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
 * - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import WebSocketClient from 'ws';
import { EventEmitter } from 'events';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { jest, expect, beforeEach, afterEach, describe, it } from '@jest/globals';
import { ConfigurationWebsocketAPI, WebsocketAPIBase, randomString } from '@binance/common';

import { MarketApi, KlinesIntervalEnum, UiKlinesIntervalEnum } from '../../../src/websocket-api';
import {
    AvgPriceRequest,
    DepthRequest,
    KlinesRequest,
    TradesAggregateRequest,
    TradesHistoricalRequest,
    TradesRecentRequest,
    UiKlinesRequest,
} from '../../../src/websocket-api';

jest.mock('ws');

describe('MarketApi', () => {
    let websocketBase: WebsocketAPIBase;
    let websocketAPIClient: MarketApi;
    let mockWs: jest.Mocked<WebSocketClient> & EventEmitter;
    let mockResponse: {
        id?: string;
        status?: number;
        result?: object | null;
        response?: object | null;
        error?: {
            code?: number;
            msg?: string;
        };
        rateLimits?: object[];
    } = {
        result: {},
        response: {},
        rateLimits: [],
    };

    describe('avgPrice()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute avgPrice() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'ddbfb65f-9ebf-42ec-8240-8f0f91de0867',
                    status: 200,
                    result: { mins: 5, price: '9.35751834', closeTime: 1694061154503 },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.avgPrice({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/avgPrice'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.avgPrice({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.avgPrice(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('depth()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute depth() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '51e2affb-0aba-4821-ba75-f2625006eb43',
                    status: 200,
                    result: {
                        lastUpdateId: 2731179239,
                        bids: [
                            ['0.01379900', '3.43200000'],
                            ['0.01379800', '3.24300000'],
                            ['0.01379700', '10.45500000'],
                            ['0.01379600', '3.82100000'],
                            ['0.01379500', '10.26200000'],
                        ],
                        asks: [
                            ['0.01380000', '5.91700000'],
                            ['0.01380100', '6.01400000'],
                            ['0.01380200', '0.26800000'],
                            ['0.01380300', '0.33800000'],
                            ['0.01380400', '0.26800000'],
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.depth({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/depth'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.depth({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.depth(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('klines()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute klines() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b',
                    status: 200,
                    result: [
                        [
                            1655971200000,
                            '0.01086000',
                            '0.01086600',
                            '0.01083600',
                            '0.01083800',
                            '2290.53800000',
                            1655974799999,
                            '24.85074442',
                            2283,
                            '1171.64000000',
                            '12.71225884',
                            '0',
                        ],
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.klines({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/klines'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.klines({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.klines(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('ticker()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute ticker() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'bdb7c503-542c-495c-b797-4d2ee2e91173',
                    status: 200,
                    result: {
                        symbol: 'BNBBTC',
                        priceChange: '0.00061500',
                        priceChangePercent: '4.735',
                        weightedAvgPrice: '0.01368242',
                        openPrice: '0.01298900',
                        highPrice: '0.01418800',
                        lowPrice: '0.01296000',
                        lastPrice: '0.01360400',
                        volume: '587179.23900000',
                        quoteVolume: '8034.03382165',
                        openTime: 1659580020000,
                        closeTime: 1660184865291,
                        firstId: 192977765,
                        lastId: 195365758,
                        count: 2387994,
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 4,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.ticker({ id: mockResponse?.id });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/ticker'.slice(1),
                        expect.any(Object),
                        { isSigned: false, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.ticker({ id: mockResponse?.id });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.ticker();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('ticker24hr()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute ticker24hr() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '9fa2a91b-3fca-4ed7-a9ad-58e3b67483de',
                    status: 200,
                    result: {
                        symbol: 'BNBBTC',
                        priceChange: '0.00013900',
                        priceChangePercent: '1.020',
                        weightedAvgPrice: '0.01382453',
                        prevClosePrice: '0.01362800',
                        lastPrice: '0.01376700',
                        lastQty: '1.78800000',
                        bidPrice: '0.01376700',
                        bidQty: '4.64600000',
                        askPrice: '0.01376800',
                        askQty: '14.31400000',
                        openPrice: '0.01362800',
                        highPrice: '0.01414900',
                        lowPrice: '0.01346600',
                        volume: '69412.40500000',
                        quoteVolume: '959.59411487',
                        openTime: 1660014164909,
                        closeTime: 1660100564909,
                        firstId: 194696115,
                        lastId: 194968287,
                        count: 272173,
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.ticker24hr({ id: mockResponse?.id });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/ticker.24hr'.slice(1),
                        expect.any(Object),
                        { isSigned: false, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.ticker24hr({ id: mockResponse?.id });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.ticker24hr();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('tickerBook()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute tickerBook() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '9d32157c-a556-4d27-9866-66760a174b57',
                    status: 200,
                    result: {
                        symbol: 'BNBBTC',
                        bidPrice: '0.01358000',
                        bidQty: '12.53400000',
                        askPrice: '0.01358100',
                        askQty: '17.83700000',
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.tickerBook({ id: mockResponse?.id });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/ticker.book'.slice(1),
                        expect.any(Object),
                        { isSigned: false, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.tickerBook({ id: mockResponse?.id });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.tickerBook();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('tickerPrice()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute tickerPrice() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '043a7cf2-bde3-4888-9604-c8ac41fcba4d',
                    status: 200,
                    result: { symbol: 'BNBBTC', price: '0.01361900' },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.tickerPrice({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/ticker.price'.slice(1),
                        expect.any(Object),
                        { isSigned: false, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.tickerPrice({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.tickerPrice();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('tickerTradingDay()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute tickerTradingDay() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'f4b3b507-c8f2-442a-81a6-b2f12daa030f',
                    status: 200,
                    result: [
                        {
                            symbol: 'BNBUSDT',
                            priceChange: '2.60000000',
                            priceChangePercent: '1.238',
                            weightedAvgPrice: '211.92276958',
                            openPrice: '210.00000000',
                            highPrice: '213.70000000',
                            lowPrice: '209.70000000',
                            lastPrice: '212.60000000',
                            volume: '280709.58900000',
                            quoteVolume: '59488753.54750000',
                            openTime: 1695686400000,
                            closeTime: 1695772799999,
                            firstId: 672397461,
                            lastId: 672496158,
                            count: 98698,
                        },
                        {
                            symbol: 'BTCUSDT',
                            priceChange: '-83.13000000',
                            priceChangePercent: '-0.317',
                            weightedAvgPrice: '26234.58803036',
                            openPrice: '26304.80000000',
                            highPrice: '26397.46000000',
                            lowPrice: '26088.34000000',
                            lastPrice: '26221.67000000',
                            volume: '18495.35066000',
                            quoteVolume: '485217905.04210480',
                            openTime: 1695686400000,
                            closeTime: 1695772799999,
                            firstId: 3220151555,
                            lastId: 3220849281,
                            count: 697727,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 8,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.tickerTradingDay({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/ticker.tradingDay'.slice(1),
                        expect.any(Object),
                        { isSigned: false, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.tickerTradingDay({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.tickerTradingDay();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('tradesAggregate()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute tradesAggregate() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '189da436-d4bd-48ca-9f95-9f613d621717',
                    status: 200,
                    result: [
                        {
                            a: 50000000,
                            p: '0.00274100',
                            q: '57.19000000',
                            f: 59120167,
                            l: 59120170,
                            T: 1565877971222,
                            m: true,
                            M: true,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: TradesAggregateRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.tradesAggregate({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/trades.aggregate'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: TradesAggregateRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.tradesAggregate({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: TradesAggregateRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.tradesAggregate(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('tradesHistorical()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute tradesHistorical() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'cffc9c7d-4efc-4ce0-b587-6b87448f052a',
                    status: 200,
                    result: [
                        {
                            id: 0,
                            price: '0.00005000',
                            qty: '40.00000000',
                            quoteQty: '0.00200000',
                            time: 1500004800376,
                            isBuyerMaker: true,
                            isBestMatch: true,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 10,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: TradesHistoricalRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.tradesHistorical({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/trades.historical'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: TradesHistoricalRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.tradesHistorical({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: TradesHistoricalRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.tradesHistorical(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('tradesRecent()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute tradesRecent() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '409a20bd-253d-41db-a6dd-687862a5882f',
                    status: 200,
                    result: [
                        {
                            id: 194686783,
                            price: '0.01361000',
                            qty: '0.01400000',
                            quoteQty: '0.00019054',
                            time: 1660009530807,
                            isBuyerMaker: true,
                            isBestMatch: true,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: TradesRecentRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.tradesRecent({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/trades.recent'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: TradesRecentRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.tradesRecent({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: TradesRecentRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.tradesRecent(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('uiKlines()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute uiKlines() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'b137468a-fb20-4c06-bd6b-625148eec958',
                    status: 200,
                    result: [
                        [
                            1655971200000,
                            '0.01086000',
                            '0.01086600',
                            '0.01083600',
                            '0.01083800',
                            '2290.53800000',
                            1655974799999,
                            '24.85074442',
                            2283,
                            '1171.64000000',
                            '12.71225884',
                            '0',
                        ],
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            count: 2,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.uiKlines({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/uiKlines'.slice(1), params, {
                        isSigned: false,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(conn);
                    const responsePromise = websocketAPIClient.uiKlines({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new MarketApi(websocketBase);
                    const responsePromise = websocketAPIClient.uiKlines(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });
});
