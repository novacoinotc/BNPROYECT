/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    MarketApi,
    DepthSymbolStatusEnum,
    KlinesIntervalEnum,
    TickerWindowSizeEnum,
    TickerTypeEnum,
    TickerSymbolStatusEnum,
    Ticker24hrTypeEnum,
    Ticker24hrSymbolStatusEnum,
    TickerBookTickerSymbolStatusEnum,
    TickerPriceSymbolStatusEnum,
    TickerTradingDayTypeEnum,
    TickerTradingDaySymbolStatusEnum,
    UiKlinesIntervalEnum,
} from '../../../src/rest-api';
import {
    AggTradesRequest,
    AvgPriceRequest,
    DepthRequest,
    GetTradesRequest,
    HistoricalTradesRequest,
    KlinesRequest,
    TickerRequest,
    Ticker24hrRequest,
    TickerBookTickerRequest,
    TickerPriceRequest,
    TickerTradingDayRequest,
    UiKlinesRequest,
} from '../../../src/rest-api';
import type {
    AggTradesResponse,
    AvgPriceResponse,
    DepthResponse,
    GetTradesResponse,
    HistoricalTradesResponse,
    KlinesResponse,
    Ticker24hrResponse,
    TickerBookTickerResponse,
    TickerPriceResponse,
    TickerResponse,
    TickerTradingDayResponse,
    UiKlinesResponse,
} from '../../../src/rest-api/types';

describe('MarketApi', () => {
    let client: MarketApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketApi(config);
    });

    describe('aggTrades()', () => {
        it('should execute aggTrades() successfully with required parameters only', async () => {
            const params: AggTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        a: 26129,
                        p: '0.01633102',
                        q: '4.70443515',
                        f: 27781,
                        l: 27781,
                        T: 1498793709153,
                        m: true,
                        M: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'aggTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AggTradesResponse>)
            );
            const response = await client.aggTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute aggTrades() successfully with optional parameters', async () => {
            const params: AggTradesRequest = {
                symbol: 'BNBUSDT',
                fromId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        a: 26129,
                        p: '0.01633102',
                        q: '4.70443515',
                        f: 27781,
                        l: 27781,
                        T: 1498793709153,
                        m: true,
                        M: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'aggTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AggTradesResponse>)
            );
            const response = await client.aggTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AggTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.aggTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling aggTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AggTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'aggTrades').mockRejectedValueOnce(mockError);
            await expect(client.aggTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('avgPrice()', () => {
        it('should execute avgPrice() successfully with required parameters only', async () => {
            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({ mins: 5, price: '9.35751834', closeTime: 1694061154503 })
            );

            const spy = jest.spyOn(client, 'avgPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AvgPriceResponse>)
            );
            const response = await client.avgPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute avgPrice() successfully with optional parameters', async () => {
            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({ mins: 5, price: '9.35751834', closeTime: 1694061154503 })
            );

            const spy = jest.spyOn(client, 'avgPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AvgPriceResponse>)
            );
            const response = await client.avgPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.avgPrice(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling avgPrice.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'avgPrice').mockRejectedValueOnce(mockError);
            await expect(client.avgPrice(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depth()', () => {
        it('should execute depth() successfully with required parameters only', async () => {
            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 1027024,
                    bids: [['4.00000000', '431.00000000']],
                    asks: [['4.00000200', '12.00000000']],
                })
            );

            const spy = jest.spyOn(client, 'depth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepthResponse>)
            );
            const response = await client.depth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depth() successfully with optional parameters', async () => {
            const params: DepthRequest = {
                symbol: 'BNBUSDT',
                limit: 500,
                symbolStatus: DepthSymbolStatusEnum.TRADING,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 1027024,
                    bids: [['4.00000000', '431.00000000']],
                    asks: [['4.00000200', '12.00000000']],
                })
            );

            const spy = jest.spyOn(client, 'depth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepthResponse>)
            );
            const response = await client.depth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DepthRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.depth(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling depth.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depth').mockRejectedValueOnce(mockError);
            await expect(client.depth(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getTrades()', () => {
        it('should execute getTrades() successfully with required parameters only', async () => {
            const params: GetTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.000012',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isBestMatch: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetTradesResponse>)
            );
            const response = await client.getTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getTrades() successfully with optional parameters', async () => {
            const params: GetTradesRequest = {
                symbol: 'BNBUSDT',
                limit: 500,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.000012',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isBestMatch: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetTradesResponse>)
            );
            const response = await client.getTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getTrades').mockRejectedValueOnce(mockError);
            await expect(client.getTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('historicalTrades()', () => {
        it('should execute historicalTrades() successfully with required parameters only', async () => {
            const params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.000012',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isBestMatch: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'historicalTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalTradesResponse>)
            );
            const response = await client.historicalTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute historicalTrades() successfully with optional parameters', async () => {
            const params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
                limit: 500,
                fromId: 1,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.000012',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isBestMatch: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'historicalTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalTradesResponse>)
            );
            const response = await client.historicalTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.historicalTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling historicalTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'historicalTrades').mockRejectedValueOnce(mockError);
            await expect(client.historicalTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('klines()', () => {
        it('should execute klines() successfully with required parameters only', async () => {
            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1499040000000,
                        '0.01634790',
                        '0.80000000',
                        '0.01575800',
                        '0.01577100',
                        '148976.11427815',
                        1499644799999,
                        '2434.19055334',
                        308,
                        '1756.87402397',
                        '28.46694368',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlinesResponse>)
            );
            const response = await client.klines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klines() successfully with optional parameters', async () => {
            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
                startTime: 1735693200000,
                endTime: 1735693200000,
                timeZone: 'timeZone_example',
                limit: 500,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1499040000000,
                        '0.01634790',
                        '0.80000000',
                        '0.01575800',
                        '0.01577100',
                        '148976.11427815',
                        1499644799999,
                        '2434.19055334',
                        308,
                        '1756.87402397',
                        '28.46694368',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlinesResponse>)
            );
            const response = await client.klines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klines(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klines.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klines(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klines.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klines').mockRejectedValueOnce(mockError);
            await expect(client.klines(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker()', () => {
        it('should execute ticker() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    priceChange: '-8.00000000',
                    priceChangePercent: '-88.889',
                    weightedAvgPrice: '2.60427807',
                    openPrice: '0.10000000',
                    highPrice: '2.00000000',
                    lowPrice: '0.10000000',
                    lastPrice: '2.00000000',
                    volume: '39.00000000',
                    quoteVolume: '13.40000000',
                    openTime: 1656986580000,
                    closeTime: 1657001016795,
                    firstId: 0,
                    lastId: 34,
                    count: 35,
                })
            );

            const spy = jest.spyOn(client, 'ticker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerResponse>)
            );
            const response = await client.ticker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker() successfully with optional parameters', async () => {
            const params: TickerRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                windowSize: TickerWindowSizeEnum.WINDOW_SIZE_1m,
                type: TickerTypeEnum.FULL,
                symbolStatus: TickerSymbolStatusEnum.TRADING,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    priceChange: '-8.00000000',
                    priceChangePercent: '-88.889',
                    weightedAvgPrice: '2.60427807',
                    openPrice: '0.10000000',
                    highPrice: '2.00000000',
                    lowPrice: '0.10000000',
                    lastPrice: '2.00000000',
                    volume: '39.00000000',
                    quoteVolume: '13.40000000',
                    openTime: 1656986580000,
                    closeTime: 1657001016795,
                    firstId: 0,
                    lastId: 34,
                    count: 35,
                })
            );

            const spy = jest.spyOn(client, 'ticker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerResponse>)
            );
            const response = await client.ticker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ticker').mockRejectedValueOnce(mockError);
            await expect(client.ticker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hr()', () => {
        it('should execute ticker24hr() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BNBBTC',
                    priceChange: '-94.99999800',
                    priceChangePercent: '-95.960',
                    weightedAvgPrice: '0.29628482',
                    prevClosePrice: '0.10002000',
                    lastPrice: '4.00000200',
                    lastQty: '200.00000000',
                    bidPrice: '4.00000000',
                    bidQty: '100.00000000',
                    askPrice: '4.00000200',
                    askQty: '100.00000000',
                    openPrice: '99.00000000',
                    highPrice: '100.00000000',
                    lowPrice: '0.10000000',
                    volume: '8913.30000000',
                    quoteVolume: '15.30000000',
                    openTime: 1499783499040,
                    closeTime: 1499869899040,
                    firstId: 28385,
                    lastId: 28460,
                    count: 76,
                })
            );

            const spy = jest.spyOn(client, 'ticker24hr').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrResponse>)
            );
            const response = await client.ticker24hr();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hr() successfully with optional parameters', async () => {
            const params: Ticker24hrRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                type: Ticker24hrTypeEnum.FULL,
                symbolStatus: Ticker24hrSymbolStatusEnum.TRADING,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BNBBTC',
                    priceChange: '-94.99999800',
                    priceChangePercent: '-95.960',
                    weightedAvgPrice: '0.29628482',
                    prevClosePrice: '0.10002000',
                    lastPrice: '4.00000200',
                    lastQty: '200.00000000',
                    bidPrice: '4.00000000',
                    bidQty: '100.00000000',
                    askPrice: '4.00000200',
                    askQty: '100.00000000',
                    openPrice: '99.00000000',
                    highPrice: '100.00000000',
                    lowPrice: '0.10000000',
                    volume: '8913.30000000',
                    quoteVolume: '15.30000000',
                    openTime: 1499783499040,
                    closeTime: 1499869899040,
                    firstId: 28385,
                    lastId: 28460,
                    count: 76,
                })
            );

            const spy = jest.spyOn(client, 'ticker24hr').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrResponse>)
            );
            const response = await client.ticker24hr(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ticker24hr').mockRejectedValueOnce(mockError);
            await expect(client.ticker24hr()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tickerBookTicker()', () => {
        it('should execute tickerBookTicker() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    bidPrice: '4.00000000',
                    bidQty: '431.00000000',
                    askPrice: '4.00000200',
                    askQty: '9.00000000',
                })
            );

            const spy = jest.spyOn(client, 'tickerBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerBookTickerResponse>)
            );
            const response = await client.tickerBookTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tickerBookTicker() successfully with optional parameters', async () => {
            const params: TickerBookTickerRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                symbolStatus: TickerBookTickerSymbolStatusEnum.TRADING,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    bidPrice: '4.00000000',
                    bidQty: '431.00000000',
                    askPrice: '4.00000200',
                    askQty: '9.00000000',
                })
            );

            const spy = jest.spyOn(client, 'tickerBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerBookTickerResponse>)
            );
            const response = await client.tickerBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tickerBookTicker').mockRejectedValueOnce(mockError);
            await expect(client.tickerBookTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tickerPrice()', () => {
        it('should execute tickerPrice() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ symbol: 'LTCBTC', price: '4.00000200' }));

            const spy = jest.spyOn(client, 'tickerPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerPriceResponse>)
            );
            const response = await client.tickerPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tickerPrice() successfully with optional parameters', async () => {
            const params: TickerPriceRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                symbolStatus: TickerPriceSymbolStatusEnum.TRADING,
            };

            mockResponse = JSONParse(JSONStringify({ symbol: 'LTCBTC', price: '4.00000200' }));

            const spy = jest.spyOn(client, 'tickerPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerPriceResponse>)
            );
            const response = await client.tickerPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tickerPrice').mockRejectedValueOnce(mockError);
            await expect(client.tickerPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tickerTradingDay()', () => {
        it('should execute tickerTradingDay() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    priceChange: '-83.13000000',
                    priceChangePercent: '-0.317',
                    weightedAvgPrice: '26234.58803036',
                    openPrice: '26304.80000000',
                    highPrice: '26397.46000000',
                    lowPrice: '26088.34000000',
                    lastPrice: '26221.67000000',
                    volume: '18495.35066000',
                    quoteVolume: '485217905.04210480',
                    openTime: 1695686400000,
                    closeTime: 1695772799999,
                    firstId: 3220151555,
                    lastId: 3220849281,
                    count: 697727,
                })
            );

            const spy = jest.spyOn(client, 'tickerTradingDay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerTradingDayResponse>)
            );
            const response = await client.tickerTradingDay();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tickerTradingDay() successfully with optional parameters', async () => {
            const params: TickerTradingDayRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                timeZone: 'timeZone_example',
                type: TickerTradingDayTypeEnum.FULL,
                symbolStatus: TickerTradingDaySymbolStatusEnum.TRADING,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    priceChange: '-83.13000000',
                    priceChangePercent: '-0.317',
                    weightedAvgPrice: '26234.58803036',
                    openPrice: '26304.80000000',
                    highPrice: '26397.46000000',
                    lowPrice: '26088.34000000',
                    lastPrice: '26221.67000000',
                    volume: '18495.35066000',
                    quoteVolume: '485217905.04210480',
                    openTime: 1695686400000,
                    closeTime: 1695772799999,
                    firstId: 3220151555,
                    lastId: 3220849281,
                    count: 697727,
                })
            );

            const spy = jest.spyOn(client, 'tickerTradingDay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerTradingDayResponse>)
            );
            const response = await client.tickerTradingDay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tickerTradingDay').mockRejectedValueOnce(mockError);
            await expect(client.tickerTradingDay()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('uiKlines()', () => {
        it('should execute uiKlines() successfully with required parameters only', async () => {
            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1499040000000,
                        '0.01634790',
                        '0.80000000',
                        '0.01575800',
                        '0.01577100',
                        '148976.11427815',
                        1499644799999,
                        '2434.19055334',
                        308,
                        '1756.87402397',
                        '28.46694368',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'uiKlines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UiKlinesResponse>)
            );
            const response = await client.uiKlines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute uiKlines() successfully with optional parameters', async () => {
            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
                startTime: 1735693200000,
                endTime: 1735693200000,
                timeZone: 'timeZone_example',
                limit: 500,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1499040000000,
                        '0.01634790',
                        '0.80000000',
                        '0.01575800',
                        '0.01577100',
                        '148976.11427815',
                        1499644799999,
                        '2434.19055334',
                        308,
                        '1756.87402397',
                        '28.46694368',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'uiKlines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UiKlinesResponse>)
            );
            const response = await client.uiKlines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.uiKlines(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling uiKlines.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.uiKlines(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling uiKlines.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'uiKlines').mockRejectedValueOnce(mockError);
            await expect(client.uiKlines(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
