/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    DeleteOrderCancelRestrictionsEnum,
    NewOrderSideEnum,
    NewOrderTypeEnum,
    NewOrderTimeInForceEnum,
    NewOrderNewOrderRespTypeEnum,
    NewOrderSelfTradePreventionModeEnum,
    NewOrderPegPriceTypeEnum,
    NewOrderPegOffsetTypeEnum,
    OrderCancelReplaceSideEnum,
    OrderCancelReplaceTypeEnum,
    OrderCancelReplaceCancelReplaceModeEnum,
    OrderCancelReplaceTimeInForceEnum,
    OrderCancelReplaceNewOrderRespTypeEnum,
    OrderCancelReplaceSelfTradePreventionModeEnum,
    OrderCancelReplaceCancelRestrictionsEnum,
    OrderCancelReplaceOrderRateLimitExceededModeEnum,
    OrderCancelReplacePegPriceTypeEnum,
    OrderCancelReplacePegOffsetTypeEnum,
    OrderListOcoSideEnum,
    OrderListOcoAboveTypeEnum,
    OrderListOcoBelowTypeEnum,
    OrderListOcoAboveTimeInForceEnum,
    OrderListOcoAbovePegPriceTypeEnum,
    OrderListOcoAbovePegOffsetTypeEnum,
    OrderListOcoBelowTimeInForceEnum,
    OrderListOcoBelowPegPriceTypeEnum,
    OrderListOcoBelowPegOffsetTypeEnum,
    OrderListOcoNewOrderRespTypeEnum,
    OrderListOcoSelfTradePreventionModeEnum,
    OrderListOpoWorkingTypeEnum,
    OrderListOpoWorkingSideEnum,
    OrderListOpoPendingTypeEnum,
    OrderListOpoPendingSideEnum,
    OrderListOpoNewOrderRespTypeEnum,
    OrderListOpoSelfTradePreventionModeEnum,
    OrderListOpoWorkingTimeInForceEnum,
    OrderListOpoWorkingPegPriceTypeEnum,
    OrderListOpoWorkingPegOffsetTypeEnum,
    OrderListOpoPendingTimeInForceEnum,
    OrderListOpoPendingPegPriceTypeEnum,
    OrderListOpoPendingPegOffsetTypeEnum,
    OrderListOpocoWorkingTypeEnum,
    OrderListOpocoWorkingSideEnum,
    OrderListOpocoPendingSideEnum,
    OrderListOpocoPendingAboveTypeEnum,
    OrderListOpocoNewOrderRespTypeEnum,
    OrderListOpocoSelfTradePreventionModeEnum,
    OrderListOpocoWorkingTimeInForceEnum,
    OrderListOpocoWorkingPegPriceTypeEnum,
    OrderListOpocoWorkingPegOffsetTypeEnum,
    OrderListOpocoPendingAboveTimeInForceEnum,
    OrderListOpocoPendingAbovePegPriceTypeEnum,
    OrderListOpocoPendingAbovePegOffsetTypeEnum,
    OrderListOpocoPendingBelowTypeEnum,
    OrderListOpocoPendingBelowTimeInForceEnum,
    OrderListOpocoPendingBelowPegPriceTypeEnum,
    OrderListOpocoPendingBelowPegOffsetTypeEnum,
    OrderListOtoWorkingTypeEnum,
    OrderListOtoWorkingSideEnum,
    OrderListOtoPendingTypeEnum,
    OrderListOtoPendingSideEnum,
    OrderListOtoNewOrderRespTypeEnum,
    OrderListOtoSelfTradePreventionModeEnum,
    OrderListOtoWorkingTimeInForceEnum,
    OrderListOtoWorkingPegPriceTypeEnum,
    OrderListOtoWorkingPegOffsetTypeEnum,
    OrderListOtoPendingTimeInForceEnum,
    OrderListOtoPendingPegPriceTypeEnum,
    OrderListOtoPendingPegOffsetTypeEnum,
    OrderListOtocoWorkingTypeEnum,
    OrderListOtocoWorkingSideEnum,
    OrderListOtocoPendingSideEnum,
    OrderListOtocoPendingAboveTypeEnum,
    OrderListOtocoNewOrderRespTypeEnum,
    OrderListOtocoSelfTradePreventionModeEnum,
    OrderListOtocoWorkingTimeInForceEnum,
    OrderListOtocoWorkingPegPriceTypeEnum,
    OrderListOtocoWorkingPegOffsetTypeEnum,
    OrderListOtocoPendingAboveTimeInForceEnum,
    OrderListOtocoPendingAbovePegPriceTypeEnum,
    OrderListOtocoPendingAbovePegOffsetTypeEnum,
    OrderListOtocoPendingBelowTypeEnum,
    OrderListOtocoPendingBelowTimeInForceEnum,
    OrderListOtocoPendingBelowPegPriceTypeEnum,
    OrderListOtocoPendingBelowPegOffsetTypeEnum,
    OrderOcoSideEnum,
    OrderOcoStopLimitTimeInForceEnum,
    OrderOcoNewOrderRespTypeEnum,
    OrderOcoSelfTradePreventionModeEnum,
    OrderTestSideEnum,
    OrderTestTypeEnum,
    OrderTestTimeInForceEnum,
    OrderTestNewOrderRespTypeEnum,
    OrderTestSelfTradePreventionModeEnum,
    OrderTestPegPriceTypeEnum,
    OrderTestPegOffsetTypeEnum,
    SorOrderSideEnum,
    SorOrderTypeEnum,
    SorOrderTimeInForceEnum,
    SorOrderNewOrderRespTypeEnum,
    SorOrderSelfTradePreventionModeEnum,
    SorOrderTestSideEnum,
    SorOrderTestTypeEnum,
    SorOrderTestTimeInForceEnum,
    SorOrderTestNewOrderRespTypeEnum,
    SorOrderTestSelfTradePreventionModeEnum,
} from '../../../src/rest-api';
import {
    DeleteOpenOrdersRequest,
    DeleteOrderRequest,
    DeleteOrderListRequest,
    NewOrderRequest,
    OrderAmendKeepPriorityRequest,
    OrderCancelReplaceRequest,
    OrderListOcoRequest,
    OrderListOpoRequest,
    OrderListOpocoRequest,
    OrderListOtoRequest,
    OrderListOtocoRequest,
    OrderOcoRequest,
    OrderTestRequest,
    SorOrderRequest,
    SorOrderTestRequest,
} from '../../../src/rest-api';
import type {
    DeleteOpenOrdersResponse,
    DeleteOrderListResponse,
    DeleteOrderResponse,
    NewOrderResponse,
    OrderAmendKeepPriorityResponse,
    OrderCancelReplaceResponse,
    OrderListOcoResponse,
    OrderListOpoResponse,
    OrderListOpocoResponse,
    OrderListOtoResponse,
    OrderListOtocoResponse,
    OrderOcoResponse,
    OrderTestResponse,
    SorOrderResponse,
    SorOrderTestResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('deleteOpenOrders()', () => {
        it('should execute deleteOpenOrders() successfully with required parameters only', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                        orderId: 11,
                        orderListId: -1,
                        clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                        transactTime: 1684804350068,
                        price: '0.089853',
                        origQty: '0.178622',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BTCUSDT',
                        origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                        orderId: 13,
                        orderListId: -1,
                        clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                        transactTime: 1684804350069,
                        price: '0.090430',
                        origQty: '0.178622',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        orderListId: 1929,
                        contingencyType: 'OCO',
                        listStatusType: 'ALL_DONE',
                        listOrderStatus: 'ALL_DONE',
                        listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                        transactionTime: 1585230948299,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 20,
                                clientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 21,
                                clientOrderId: '461cPg51vQjV3zIMOXNz39',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                                orderId: 20,
                                orderListId: 1929,
                                clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                                transactTime: 1688005070874,
                                price: '0.668611',
                                origQty: '0.690354',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'BUY',
                                stopPrice: '0.378131',
                                icebergQty: '0.017083',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                                orderId: 21,
                                orderListId: 1929,
                                clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                                transactTime: 1688005070874,
                                price: '0.008791',
                                origQty: '0.690354',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'BUY',
                                icebergQty: '0.639962',
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'deleteOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOpenOrdersResponse>)
            );
            const response = await client.deleteOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOpenOrders() successfully with optional parameters', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                        orderId: 11,
                        orderListId: -1,
                        clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                        transactTime: 1684804350068,
                        price: '0.089853',
                        origQty: '0.178622',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BTCUSDT',
                        origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                        orderId: 13,
                        orderListId: -1,
                        clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                        transactTime: 1684804350069,
                        price: '0.090430',
                        origQty: '0.178622',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        orderListId: 1929,
                        contingencyType: 'OCO',
                        listStatusType: 'ALL_DONE',
                        listOrderStatus: 'ALL_DONE',
                        listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                        transactionTime: 1585230948299,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 20,
                                clientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 21,
                                clientOrderId: '461cPg51vQjV3zIMOXNz39',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                                orderId: 20,
                                orderListId: 1929,
                                clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                                transactTime: 1688005070874,
                                price: '0.668611',
                                origQty: '0.690354',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'BUY',
                                stopPrice: '0.378131',
                                icebergQty: '0.017083',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                                orderId: 21,
                                orderListId: 1929,
                                clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                                transactTime: 1688005070874,
                                price: '0.008791',
                                origQty: '0.690354',
                                executedQty: '0.000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'BUY',
                                icebergQty: '0.639962',
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'deleteOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOpenOrdersResponse>)
            );
            const response = await client.deleteOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.deleteOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOrder()', () => {
        it('should execute deleteOrder() successfully with required parameters only', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    origClientOrderId: 'myOrder1',
                    orderId: 4,
                    orderListId: -1,
                    clientOrderId: 'cancelMyOrder1',
                    transactTime: 1684804350068,
                    price: '2.00000000',
                    origQty: '1.00000000',
                    executedQty: '0.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.00000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'deleteOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderResponse>)
            );
            const response = await client.deleteOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOrder() successfully with optional parameters', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                cancelRestrictions: DeleteOrderCancelRestrictionsEnum.ONLY_NEW,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    origClientOrderId: 'myOrder1',
                    orderId: 4,
                    orderListId: -1,
                    clientOrderId: 'cancelMyOrder1',
                    transactTime: 1684804350068,
                    price: '2.00000000',
                    origQty: '1.00000000',
                    executedQty: '0.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.00000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'deleteOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderResponse>)
            );
            const response = await client.deleteOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOrder').mockRejectedValueOnce(mockError);
            await expect(client.deleteOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOrderList()', () => {
        it('should execute deleteOrderList() successfully with required parameters only', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                    transactionTime: 1574040868128,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                            orderId: 3,
                            orderListId: 0,
                            clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                            transactTime: 1688005070874,
                            price: '3.00000000',
                            origQty: '10.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                            orderId: 2,
                            orderListId: 0,
                            clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                            transactTime: 1688005070874,
                            price: '1.00000000',
                            origQty: '10.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '1.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'deleteOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderListResponse>)
            );
            const response = await client.deleteOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOrderList() successfully with optional parameters', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
                orderListId: 1,
                listClientOrderId: 'listClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                    transactionTime: 1574040868128,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                            orderId: 3,
                            orderListId: 0,
                            clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                            transactTime: 1688005070874,
                            price: '3.00000000',
                            origQty: '10.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                            orderId: 2,
                            orderListId: 0,
                            clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                            transactTime: 1688005070874,
                            price: '1.00000000',
                            origQty: '10.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '1.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'deleteOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderListResponse>)
            );
            const response = await client.deleteOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOrderList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOrderList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOrderList').mockRejectedValueOnce(mockError);
            await expect(client.deleteOrderList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    orderId: 28,
                    orderListId: -1,
                    clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                    transactTime: 1507725176595,
                    price: '0.00000000',
                    origQty: '10.00000000',
                    executedQty: '10.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '10.00000000',
                    status: 'FILLED',
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    side: 'SELL',
                    workingTime: 1507725176595,
                    selfTradePreventionMode: 'NONE',
                    fills: [
                        {
                            price: '3995.00000000',
                            qty: '1.00000000',
                            commission: '3.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 60,
                        },
                        {
                            price: '3997.00000000',
                            qty: '1.00000000',
                            commission: '3.99700000',
                            commissionAsset: 'USDT',
                            tradeId: 59,
                        },
                        {
                            price: '3998.00000000',
                            qty: '2.00000000',
                            commission: '7.99600000',
                            commissionAsset: 'USDT',
                            tradeId: 58,
                        },
                        {
                            price: '3999.00000000',
                            qty: '5.00000000',
                            commission: '19.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 57,
                        },
                        {
                            price: '4000.00000000',
                            qty: '1.00000000',
                            commission: '4.00000000',
                            commissionAsset: 'USDT',
                            tradeId: 56,
                        },
                        {
                            price: '3995.00000000',
                            qty: '1.00000000',
                            commission: '3.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 60,
                        },
                        {
                            price: '3997.00000000',
                            qty: '1.00000000',
                            commission: '3.99700000',
                            commissionAsset: 'USDT',
                            tradeId: 59,
                        },
                        {
                            price: '3998.00000000',
                            qty: '2.00000000',
                            commission: '7.99600000',
                            commissionAsset: 'USDT',
                            tradeId: 58,
                        },
                        {
                            price: '3999.00000000',
                            qty: '5.00000000',
                            commission: '19.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 57,
                        },
                        {
                            price: '4000.00000000',
                            qty: '1.00000000',
                            commission: '4.00000000',
                            commissionAsset: 'USDT',
                            tradeId: 56,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: NewOrderSelfTradePreventionModeEnum.NONE,
                pegPriceType: NewOrderPegPriceTypeEnum.PRIMARY_PEG,
                pegOffsetValue: 1,
                pegOffsetType: NewOrderPegOffsetTypeEnum.PRICE_LEVEL,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    orderId: 28,
                    orderListId: -1,
                    clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                    transactTime: 1507725176595,
                    price: '0.00000000',
                    origQty: '10.00000000',
                    executedQty: '10.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '10.00000000',
                    status: 'FILLED',
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    side: 'SELL',
                    workingTime: 1507725176595,
                    selfTradePreventionMode: 'NONE',
                    fills: [
                        {
                            price: '3995.00000000',
                            qty: '1.00000000',
                            commission: '3.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 60,
                        },
                        {
                            price: '3997.00000000',
                            qty: '1.00000000',
                            commission: '3.99700000',
                            commissionAsset: 'USDT',
                            tradeId: 59,
                        },
                        {
                            price: '3998.00000000',
                            qty: '2.00000000',
                            commission: '7.99600000',
                            commissionAsset: 'USDT',
                            tradeId: 58,
                        },
                        {
                            price: '3999.00000000',
                            qty: '5.00000000',
                            commission: '19.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 57,
                        },
                        {
                            price: '4000.00000000',
                            qty: '1.00000000',
                            commission: '4.00000000',
                            commissionAsset: 'USDT',
                            tradeId: 56,
                        },
                        {
                            price: '3995.00000000',
                            qty: '1.00000000',
                            commission: '3.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 60,
                        },
                        {
                            price: '3997.00000000',
                            qty: '1.00000000',
                            commission: '3.99700000',
                            commissionAsset: 'USDT',
                            tradeId: 59,
                        },
                        {
                            price: '3998.00000000',
                            qty: '2.00000000',
                            commission: '7.99600000',
                            commissionAsset: 'USDT',
                            tradeId: 58,
                        },
                        {
                            price: '3999.00000000',
                            qty: '5.00000000',
                            commission: '19.99500000',
                            commissionAsset: 'USDT',
                            tradeId: 57,
                        },
                        {
                            price: '4000.00000000',
                            qty: '1.00000000',
                            commission: '4.00000000',
                            commissionAsset: 'USDT',
                            tradeId: 56,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderAmendKeepPriority()', () => {
        it('should execute orderAmendKeepPriority() successfully with required parameters only', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    transactTime: 1741669661670,
                    executionId: 22,
                    amendedOrder: {
                        symbol: 'BTCUSDT',
                        orderId: 9,
                        orderListId: 1,
                        origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                        clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                        price: '0.00000000',
                        qty: '4.00000000',
                        executedQty: '0.00000000',
                        preventedQty: '0.00000000',
                        quoteOrderQty: '0.00000000',
                        cumulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'MARKET',
                        side: 'BUY',
                        workingTime: 1741926410242,
                        selfTradePreventionMode: 'NONE',
                    },
                    listStatus: {
                        orderListId: 1,
                        contingencyType: 'OTO',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'AT7FTxZXylVSwRoZs52mt3',
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 9,
                                clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 8,
                                clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 9,
                                clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 8,
                                clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q',
                            },
                        ],
                    },
                })
            );

            const spy = jest.spyOn(client, 'orderAmendKeepPriority').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendKeepPriorityResponse>)
            );
            const response = await client.orderAmendKeepPriority(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderAmendKeepPriority() successfully with optional parameters', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    transactTime: 1741669661670,
                    executionId: 22,
                    amendedOrder: {
                        symbol: 'BTCUSDT',
                        orderId: 9,
                        orderListId: 1,
                        origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                        clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                        price: '0.00000000',
                        qty: '4.00000000',
                        executedQty: '0.00000000',
                        preventedQty: '0.00000000',
                        quoteOrderQty: '0.00000000',
                        cumulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'MARKET',
                        side: 'BUY',
                        workingTime: 1741926410242,
                        selfTradePreventionMode: 'NONE',
                    },
                    listStatus: {
                        orderListId: 1,
                        contingencyType: 'OTO',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'AT7FTxZXylVSwRoZs52mt3',
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 9,
                                clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 8,
                                clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 9,
                                clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 8,
                                clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q',
                            },
                        ],
                    },
                })
            );

            const spy = jest.spyOn(client, 'orderAmendKeepPriority').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendKeepPriorityResponse>)
            );
            const response = await client.orderAmendKeepPriority(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderAmendKeepPriority.'
            );
        });

        it('should throw RequiredError when newQty is missing', async () => {
            const _params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.newQty;

            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow(
                'Required parameter newQty was null or undefined when calling orderAmendKeepPriority.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'orderAmendKeepPriority')
                .mockRejectedValueOnce(mockError);
            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderCancelReplace()', () => {
        it('should execute orderCancelReplace() successfully with required parameters only', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'SUCCESS',
                    cancelResponse: {
                        symbol: 'BTCUSDT',
                        origClientOrderId: 'DnLo3vTAQcjha43lAZhZ0y',
                        orderId: 9,
                        orderListId: -1,
                        clientOrderId: 'osxN3JXAtJvKvCqGeMWMVR',
                        transactTime: 1684804350068,
                        price: '0.01000000',
                        origQty: '0.000100',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        symbol: 'BTCUSDT',
                        orderId: 10,
                        orderListId: -1,
                        clientOrderId: 'wOceeeOzNORyLiQfw7jd8S',
                        transactTime: 1652928801803,
                        price: '0.02000000',
                        origQty: '0.040000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        workingTime: 1669277163808,
                        fills: [],
                        selfTradePreventionMode: 'NONE',
                    },
                    code: -2021,
                    msg: 'Order cancel-replace partially failed.',
                    data: {
                        cancelResult: 'SUCCESS',
                        newOrderResult: 'FAILURE',
                        cancelResponse: {
                            code: -2011,
                            msg: 'Unknown order sent.',
                            symbol: 'LTCBNB',
                            origClientOrderId: 'GKt5zzfOxRDSQLveDYCTkc',
                            orderId: 64,
                            orderListId: -1,
                            clientOrderId: 'loehOJF3FjoreUBDmv739R',
                            transactTime: 1715779007228,
                            price: '1.00',
                            origQty: '10.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                        newOrderResponse: {
                            code: -1015,
                            msg: 'Too many new orders; current limit is 1 orders per 10 SECOND.',
                            symbol: 'BTCUSDT',
                            orderId: 11,
                            orderListId: -1,
                            clientOrderId: 'pfojJMg6IMNDKuJqDxvoxN',
                            transactTime: 1648540168818,
                        },
                    },
                })
            );

            const spy = jest.spyOn(client, 'orderCancelReplace').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderCancelReplaceResponse>)
            );
            const response = await client.orderCancelReplace(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderCancelReplace() successfully with optional parameters', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
                timeInForce: OrderCancelReplaceTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                cancelNewClientOrderId: 'cancelNewClientOrderId_example',
                cancelOrigClientOrderId: 'cancelOrigClientOrderId_example',
                cancelOrderId: 1,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: OrderCancelReplaceNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderCancelReplaceSelfTradePreventionModeEnum.NONE,
                cancelRestrictions: OrderCancelReplaceCancelRestrictionsEnum.ONLY_NEW,
                orderRateLimitExceededMode:
                    OrderCancelReplaceOrderRateLimitExceededModeEnum.DO_NOTHING,
                pegPriceType: OrderCancelReplacePegPriceTypeEnum.PRIMARY_PEG,
                pegOffsetValue: 1,
                pegOffsetType: OrderCancelReplacePegOffsetTypeEnum.PRICE_LEVEL,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'SUCCESS',
                    cancelResponse: {
                        symbol: 'BTCUSDT',
                        origClientOrderId: 'DnLo3vTAQcjha43lAZhZ0y',
                        orderId: 9,
                        orderListId: -1,
                        clientOrderId: 'osxN3JXAtJvKvCqGeMWMVR',
                        transactTime: 1684804350068,
                        price: '0.01000000',
                        origQty: '0.000100',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        symbol: 'BTCUSDT',
                        orderId: 10,
                        orderListId: -1,
                        clientOrderId: 'wOceeeOzNORyLiQfw7jd8S',
                        transactTime: 1652928801803,
                        price: '0.02000000',
                        origQty: '0.040000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        workingTime: 1669277163808,
                        fills: [],
                        selfTradePreventionMode: 'NONE',
                    },
                    code: -2021,
                    msg: 'Order cancel-replace partially failed.',
                    data: {
                        cancelResult: 'SUCCESS',
                        newOrderResult: 'FAILURE',
                        cancelResponse: {
                            code: -2011,
                            msg: 'Unknown order sent.',
                            symbol: 'LTCBNB',
                            origClientOrderId: 'GKt5zzfOxRDSQLveDYCTkc',
                            orderId: 64,
                            orderListId: -1,
                            clientOrderId: 'loehOJF3FjoreUBDmv739R',
                            transactTime: 1715779007228,
                            price: '1.00',
                            origQty: '10.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                        newOrderResponse: {
                            code: -1015,
                            msg: 'Too many new orders; current limit is 1 orders per 10 SECOND.',
                            symbol: 'BTCUSDT',
                            orderId: 11,
                            orderListId: -1,
                            clientOrderId: 'pfojJMg6IMNDKuJqDxvoxN',
                            transactTime: 1648540168818,
                        },
                    },
                })
            );

            const spy = jest.spyOn(client, 'orderCancelReplace').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderCancelReplaceResponse>)
            );
            const response = await client.orderCancelReplace(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw RequiredError when cancelReplaceMode is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.cancelReplaceMode;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter cancelReplaceMode was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderCancelReplace').mockRejectedValueOnce(mockError);
            await expect(client.orderCancelReplace(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOco()', () => {
        it('should execute orderListOco() successfully with required parameters only', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 1,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'lH1YDkuQKWiXVXHPSKYEIp',
                    transactionTime: 1710485608839,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 11, clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK' },
                        { symbol: 'LTCBTC', orderId: 10, clientOrderId: '44nZvqpemY7sVYgPYbvPih' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 11,
                            orderListId: 1,
                            clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK',
                            transactTime: 1710485608839,
                            price: '3.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            workingTime: 1710485608839,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 10,
                            orderListId: 1,
                            clientOrderId: '44nZvqpemY7sVYgPYbvPih',
                            transactTime: 1710485608839,
                            price: '1.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '1.00000000',
                            workingTime: -1,
                            icebergQty: '1.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOcoResponse>)
            );
            const response = await client.orderListOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOco() successfully with optional parameters', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
                listClientOrderId: 'listClientOrderId_example',
                aboveClientOrderId: 'aboveClientOrderId_example',
                aboveIcebergQty: 1,
                abovePrice: 1.0,
                aboveStopPrice: 1.0,
                aboveTrailingDelta: 1,
                aboveTimeInForce: OrderListOcoAboveTimeInForceEnum.GTC,
                aboveStrategyId: 1,
                aboveStrategyType: 1,
                abovePegPriceType: OrderListOcoAbovePegPriceTypeEnum.PRIMARY_PEG,
                abovePegOffsetType: OrderListOcoAbovePegOffsetTypeEnum.PRICE_LEVEL,
                abovePegOffsetValue: 1,
                belowClientOrderId: 'belowClientOrderId_example',
                belowIcebergQty: 1,
                belowPrice: 1.0,
                belowStopPrice: 1.0,
                belowTrailingDelta: 1,
                belowTimeInForce: OrderListOcoBelowTimeInForceEnum.GTC,
                belowStrategyId: 1,
                belowStrategyType: 1,
                belowPegPriceType: OrderListOcoBelowPegPriceTypeEnum.PRIMARY_PEG,
                belowPegOffsetType: OrderListOcoBelowPegOffsetTypeEnum.PRICE_LEVEL,
                belowPegOffsetValue: 1,
                newOrderRespType: OrderListOcoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOcoSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 1,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'lH1YDkuQKWiXVXHPSKYEIp',
                    transactionTime: 1710485608839,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 11, clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK' },
                        { symbol: 'LTCBTC', orderId: 10, clientOrderId: '44nZvqpemY7sVYgPYbvPih' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 11,
                            orderListId: 1,
                            clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK',
                            transactTime: 1710485608839,
                            price: '3.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            workingTime: 1710485608839,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 10,
                            orderListId: 1,
                            clientOrderId: '44nZvqpemY7sVYgPYbvPih',
                            transactTime: 1710485608839,
                            price: '1.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '1.00000000',
                            workingTime: -1,
                            icebergQty: '1.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOcoResponse>)
            );
            const response = await client.orderListOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when aboveType is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.aboveType;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter aboveType was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when belowType is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.belowType;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter belowType was null or undefined when calling orderListOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOpo()', () => {
        it('should execute orderListOpo() successfully with required parameters only', async () => {
            const params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'H94qCqO27P74OEiO4X8HOG',
                    transactionTime: 1762998011671,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 3, clientOrderId: '2ZJCY0IjOhuYIMLGN8kU8S' },
                        { symbol: 'BTCUSDT', orderId: 2, clientOrderId: 'JX6xfdjo0wysiGumfHNmPu' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 3,
                            orderListId: 0,
                            clientOrderId: '2ZJCY0IjOhuYIMLGN8kU8S',
                            transactTime: 1762998011671,
                            price: '0.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'MARKET',
                            side: 'SELL',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 2,
                            orderListId: 0,
                            clientOrderId: 'JX6xfdjo0wysiGumfHNmPu',
                            transactTime: 1762998011671,
                            price: '102264.00000000',
                            origQty: '0.00060000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1762998011671,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOpo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOpoResponse>)
            );
            const response = await client.orderListOpo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOpo() successfully with optional parameters', async () => {
            const params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOpoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOpoSelfTradePreventionModeEnum.NONE,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOpoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                workingPegPriceType: OrderListOpoWorkingPegPriceTypeEnum.PRIMARY_PEG,
                workingPegOffsetType: OrderListOpoWorkingPegOffsetTypeEnum.PRICE_LEVEL,
                workingPegOffsetValue: 1,
                pendingClientOrderId: 'pendingClientOrderId_example',
                pendingPrice: 1.0,
                pendingStopPrice: 1.0,
                pendingTrailingDelta: 1.0,
                pendingIcebergQty: 1.0,
                pendingTimeInForce: OrderListOpoPendingTimeInForceEnum.GTC,
                pendingStrategyId: 1,
                pendingStrategyType: 1,
                pendingPegPriceType: OrderListOpoPendingPegPriceTypeEnum.PRIMARY_PEG,
                pendingPegOffsetType: OrderListOpoPendingPegOffsetTypeEnum.PRICE_LEVEL,
                pendingPegOffsetValue: 1,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'H94qCqO27P74OEiO4X8HOG',
                    transactionTime: 1762998011671,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 3, clientOrderId: '2ZJCY0IjOhuYIMLGN8kU8S' },
                        { symbol: 'BTCUSDT', orderId: 2, clientOrderId: 'JX6xfdjo0wysiGumfHNmPu' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 3,
                            orderListId: 0,
                            clientOrderId: '2ZJCY0IjOhuYIMLGN8kU8S',
                            transactTime: 1762998011671,
                            price: '0.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'MARKET',
                            side: 'SELL',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 2,
                            orderListId: 0,
                            clientOrderId: 'JX6xfdjo0wysiGumfHNmPu',
                            transactTime: 1762998011671,
                            price: '102264.00000000',
                            origQty: '0.00060000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1762998011671,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOpo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOpoResponse>)
            );
            const response = await client.orderListOpo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw RequiredError when pendingType is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingType;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter pendingType was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.orderListOpo(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling orderListOpo.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOpoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOpoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOpoPendingSideEnum.BUY,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOpo').mockRejectedValueOnce(mockError);
            await expect(client.orderListOpo(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOpoco()', () => {
        it('should execute orderListOpoco() successfully with required parameters only', async () => {
            const params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 2,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'bcedxMpQG6nFrZUPQyshoL',
                    transactionTime: 1763000506354,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 11, clientOrderId: 'yINkaXSJeoi3bU5vWMY8Z8' },
                        { symbol: 'BTCUSDT', orderId: 10, clientOrderId: 'mfif39yPTHsB3C0FIXznR2' },
                        { symbol: 'BTCUSDT', orderId: 9, clientOrderId: 'OLSBhMWaIlLSzZ9Zm7fnKB' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 11,
                            orderListId: 2,
                            clientOrderId: 'yINkaXSJeoi3bU5vWMY8Z8',
                            transactTime: 1763000506354,
                            price: '104261.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 10,
                            orderListId: 2,
                            clientOrderId: 'mfif39yPTHsB3C0FIXznR2',
                            transactTime: 1763000506354,
                            price: '101613.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '10100.00000000',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 9,
                            orderListId: 2,
                            clientOrderId: 'OLSBhMWaIlLSzZ9Zm7fnKB',
                            transactTime: 1763000506354,
                            price: '102496.00000000',
                            origQty: '0.00170000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1763000506354,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOpoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOpocoResponse>)
            );
            const response = await client.orderListOpoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOpoco() successfully with optional parameters', async () => {
            const params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOpocoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOpocoSelfTradePreventionModeEnum.NONE,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOpocoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                workingPegPriceType: OrderListOpocoWorkingPegPriceTypeEnum.PRIMARY_PEG,
                workingPegOffsetType: OrderListOpocoWorkingPegOffsetTypeEnum.PRICE_LEVEL,
                workingPegOffsetValue: 1,
                pendingAboveClientOrderId: 'pendingAboveClientOrderId_example',
                pendingAbovePrice: 1.0,
                pendingAboveStopPrice: 1.0,
                pendingAboveTrailingDelta: 1.0,
                pendingAboveIcebergQty: 1.0,
                pendingAboveTimeInForce: OrderListOpocoPendingAboveTimeInForceEnum.GTC,
                pendingAboveStrategyId: 1,
                pendingAboveStrategyType: 1,
                pendingAbovePegPriceType: OrderListOpocoPendingAbovePegPriceTypeEnum.PRIMARY_PEG,
                pendingAbovePegOffsetType: OrderListOpocoPendingAbovePegOffsetTypeEnum.PRICE_LEVEL,
                pendingAbovePegOffsetValue: 1,
                pendingBelowType: OrderListOpocoPendingBelowTypeEnum.STOP_LOSS,
                pendingBelowClientOrderId: 'pendingBelowClientOrderId_example',
                pendingBelowPrice: 1.0,
                pendingBelowStopPrice: 1.0,
                pendingBelowTrailingDelta: 1.0,
                pendingBelowIcebergQty: 1.0,
                pendingBelowTimeInForce: OrderListOpocoPendingBelowTimeInForceEnum.GTC,
                pendingBelowStrategyId: 1,
                pendingBelowStrategyType: 1,
                pendingBelowPegPriceType: OrderListOpocoPendingBelowPegPriceTypeEnum.PRIMARY_PEG,
                pendingBelowPegOffsetType: OrderListOpocoPendingBelowPegOffsetTypeEnum.PRICE_LEVEL,
                pendingBelowPegOffsetValue: 1,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 2,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'bcedxMpQG6nFrZUPQyshoL',
                    transactionTime: 1763000506354,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 11, clientOrderId: 'yINkaXSJeoi3bU5vWMY8Z8' },
                        { symbol: 'BTCUSDT', orderId: 10, clientOrderId: 'mfif39yPTHsB3C0FIXznR2' },
                        { symbol: 'BTCUSDT', orderId: 9, clientOrderId: 'OLSBhMWaIlLSzZ9Zm7fnKB' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 11,
                            orderListId: 2,
                            clientOrderId: 'yINkaXSJeoi3bU5vWMY8Z8',
                            transactTime: 1763000506354,
                            price: '104261.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 10,
                            orderListId: 2,
                            clientOrderId: 'mfif39yPTHsB3C0FIXznR2',
                            transactTime: 1763000506354,
                            price: '101613.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '10100.00000000',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 9,
                            orderListId: 2,
                            clientOrderId: 'OLSBhMWaIlLSzZ9Zm7fnKB',
                            transactTime: 1763000506354,
                            price: '102496.00000000',
                            origQty: '0.00170000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1763000506354,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOpoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOpocoResponse>)
            );
            const response = await client.orderListOpoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw RequiredError when pendingAboveType is missing', async () => {
            const _params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingAboveType;

            await expect(client.orderListOpoco(params)).rejects.toThrow(
                'Required parameter pendingAboveType was null or undefined when calling orderListOpoco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOpocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOpocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOpocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOpocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOpocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOpoco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOpoco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOto()', () => {
        it('should execute orderListOto() successfully with required parameters only', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'yl2ERtcar1o25zcWtqVBTC',
                    transactionTime: 1712289389158,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'arLFo0zGJVDE69cvGBaU0d' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 5,
                            orderListId: 0,
                            clientOrderId: 'arLFo0zGJVDE69cvGBaU0d',
                            transactTime: 1712289389158,
                            price: '0.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'MARKET',
                            side: 'BUY',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 4,
                            orderListId: 0,
                            clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya',
                            transactTime: 1712289389158,
                            price: '1.00000000',
                            origQty: '1.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            workingTime: 1712289389158,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtoResponse>)
            );
            const response = await client.orderListOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOto() successfully with optional parameters', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOtoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOtoSelfTradePreventionModeEnum.NONE,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOtoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                workingPegPriceType: OrderListOtoWorkingPegPriceTypeEnum.PRIMARY_PEG,
                workingPegOffsetType: OrderListOtoWorkingPegOffsetTypeEnum.PRICE_LEVEL,
                workingPegOffsetValue: 1,
                pendingClientOrderId: 'pendingClientOrderId_example',
                pendingPrice: 1.0,
                pendingStopPrice: 1.0,
                pendingTrailingDelta: 1.0,
                pendingIcebergQty: 1.0,
                pendingTimeInForce: OrderListOtoPendingTimeInForceEnum.GTC,
                pendingStrategyId: 1,
                pendingStrategyType: 1,
                pendingPegPriceType: OrderListOtoPendingPegPriceTypeEnum.PRIMARY_PEG,
                pendingPegOffsetType: OrderListOtoPendingPegOffsetTypeEnum.PRICE_LEVEL,
                pendingPegOffsetValue: 1,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'yl2ERtcar1o25zcWtqVBTC',
                    transactionTime: 1712289389158,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'arLFo0zGJVDE69cvGBaU0d' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 5,
                            orderListId: 0,
                            clientOrderId: 'arLFo0zGJVDE69cvGBaU0d',
                            transactTime: 1712289389158,
                            price: '0.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'MARKET',
                            side: 'BUY',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 4,
                            orderListId: 0,
                            clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya',
                            transactTime: 1712289389158,
                            price: '1.00000000',
                            origQty: '1.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            workingTime: 1712289389158,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtoResponse>)
            );
            const response = await client.orderListOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingType is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingType;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingType was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling orderListOto.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOto').mockRejectedValueOnce(mockError);
            await expect(client.orderListOto(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOtoco()', () => {
        it('should execute orderListOtoco() successfully with required parameters only', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 1,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'RumwQpBaDctlUu5jyG5rs0',
                    transactionTime: 1712291372842,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 8, clientOrderId: 'r4JMv9cwAYYUwwBZfbussx' },
                        { symbol: 'LTCBTC', orderId: 7, clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4' },
                        { symbol: 'LTCBTC', orderId: 6, clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 8,
                            orderListId: 1,
                            clientOrderId: 'r4JMv9cwAYYUwwBZfbussx',
                            transactTime: 1712291372842,
                            price: '3.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 7,
                            orderListId: 1,
                            clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4',
                            transactTime: 1712291372842,
                            price: '1.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'IOC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '6.00000000',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 6,
                            orderListId: 1,
                            clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK',
                            transactTime: 1712291372842,
                            price: '1.00000000',
                            origQty: '1.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            workingTime: 1712291372842,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtocoResponse>)
            );
            const response = await client.orderListOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOtoco() successfully with optional parameters', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOtocoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOtocoSelfTradePreventionModeEnum.NONE,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOtocoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                workingPegPriceType: OrderListOtocoWorkingPegPriceTypeEnum.PRIMARY_PEG,
                workingPegOffsetType: OrderListOtocoWorkingPegOffsetTypeEnum.PRICE_LEVEL,
                workingPegOffsetValue: 1,
                pendingAboveClientOrderId: 'pendingAboveClientOrderId_example',
                pendingAbovePrice: 1.0,
                pendingAboveStopPrice: 1.0,
                pendingAboveTrailingDelta: 1.0,
                pendingAboveIcebergQty: 1.0,
                pendingAboveTimeInForce: OrderListOtocoPendingAboveTimeInForceEnum.GTC,
                pendingAboveStrategyId: 1,
                pendingAboveStrategyType: 1,
                pendingAbovePegPriceType: OrderListOtocoPendingAbovePegPriceTypeEnum.PRIMARY_PEG,
                pendingAbovePegOffsetType: OrderListOtocoPendingAbovePegOffsetTypeEnum.PRICE_LEVEL,
                pendingAbovePegOffsetValue: 1,
                pendingBelowType: OrderListOtocoPendingBelowTypeEnum.STOP_LOSS,
                pendingBelowClientOrderId: 'pendingBelowClientOrderId_example',
                pendingBelowPrice: 1.0,
                pendingBelowStopPrice: 1.0,
                pendingBelowTrailingDelta: 1.0,
                pendingBelowIcebergQty: 1.0,
                pendingBelowTimeInForce: OrderListOtocoPendingBelowTimeInForceEnum.GTC,
                pendingBelowStrategyId: 1,
                pendingBelowStrategyType: 1,
                pendingBelowPegPriceType: OrderListOtocoPendingBelowPegPriceTypeEnum.PRIMARY_PEG,
                pendingBelowPegOffsetType: OrderListOtocoPendingBelowPegOffsetTypeEnum.PRICE_LEVEL,
                pendingBelowPegOffsetValue: 1,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 1,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'RumwQpBaDctlUu5jyG5rs0',
                    transactionTime: 1712291372842,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 8, clientOrderId: 'r4JMv9cwAYYUwwBZfbussx' },
                        { symbol: 'LTCBTC', orderId: 7, clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4' },
                        { symbol: 'LTCBTC', orderId: 6, clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 8,
                            orderListId: 1,
                            clientOrderId: 'r4JMv9cwAYYUwwBZfbussx',
                            transactTime: 1712291372842,
                            price: '3.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 7,
                            orderListId: 1,
                            clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4',
                            transactTime: 1712291372842,
                            price: '1.00000000',
                            origQty: '5.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'IOC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '6.00000000',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 6,
                            orderListId: 1,
                            clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK',
                            transactTime: 1712291372842,
                            price: '1.00000000',
                            origQty: '1.00000000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            workingTime: 1712291372842,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderListOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtocoResponse>)
            );
            const response = await client.orderListOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingAboveType is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingAboveType;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingAboveType was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOtoco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOtoco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderOco()', () => {
        it('should execute orderOco() successfully with required parameters only', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                    transactionTime: 1563417480525,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 3,
                            orderListId: 0,
                            clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                            transactTime: 1563417480525,
                            price: '0.036435',
                            origQty: '0.624363',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            workingTime: 1563417480525,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 2,
                            orderListId: 0,
                            clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                            transactTime: 1563417480525,
                            price: '0.000000',
                            origQty: '0.624363',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS',
                            side: 'BUY',
                            stopPrice: '0.960664',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderOcoResponse>)
            );
            const response = await client.orderOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderOco() successfully with optional parameters', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                limitClientOrderId: 'limitClientOrderId_example',
                limitStrategyId: 1,
                limitStrategyType: 1,
                limitIcebergQty: 1.0,
                trailingDelta: 1,
                stopClientOrderId: 'stopClientOrderId_example',
                stopStrategyId: 1,
                stopStrategyType: 1,
                stopLimitPrice: 1.0,
                stopIcebergQty: 1.0,
                stopLimitTimeInForce: OrderOcoStopLimitTimeInForceEnum.GTC,
                newOrderRespType: OrderOcoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderOcoSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 0,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                    transactionTime: 1563417480525,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBTC',
                            orderId: 3,
                            orderListId: 0,
                            clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                            transactTime: 1563417480525,
                            price: '0.036435',
                            origQty: '0.624363',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            workingTime: 1563417480525,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBTC',
                            orderId: 2,
                            orderListId: 0,
                            clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                            transactTime: 1563417480525,
                            price: '0.000000',
                            origQty: '0.624363',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS',
                            side: 'BUY',
                            stopPrice: '0.960664',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'orderOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderOcoResponse>)
            );
            const response = await client.orderOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when stopPrice is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.stopPrice;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter stopPrice was null or undefined when calling orderOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderOco').mockRejectedValueOnce(mockError);
            await expect(client.orderOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderTest()', () => {
        it('should execute orderTest() successfully with required parameters only', async () => {
            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    specialCommissionForOrder: { maker: '0.05000000', taker: '0.06000000' },
                    taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.25000000',
                    },
                })
            );

            const spy = jest.spyOn(client, 'orderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderTestResponse>)
            );
            const response = await client.orderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderTest() successfully with optional parameters', async () => {
            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
                computeCommissionRates: false,
                timeInForce: OrderTestTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: OrderTestNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderTestSelfTradePreventionModeEnum.NONE,
                pegPriceType: OrderTestPegPriceTypeEnum.PRIMARY_PEG,
                pegOffsetValue: 1,
                pegOffsetType: OrderTestPegOffsetTypeEnum.PRICE_LEVEL,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    specialCommissionForOrder: { maker: '0.05000000', taker: '0.06000000' },
                    taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.25000000',
                    },
                })
            );

            const spy = jest.spyOn(client, 'orderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderTestResponse>)
            );
            const response = await client.orderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderTest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderTest.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderTest(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderTest.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.orderTest(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling orderTest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderTest').mockRejectedValueOnce(mockError);
            await expect(client.orderTest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sorOrder()', () => {
        it('should execute sorOrder() successfully with required parameters only', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    orderId: 2,
                    orderListId: -1,
                    clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                    transactTime: 1689149087774,
                    price: '31000.00000000',
                    origQty: '0.50000000',
                    executedQty: '0.50000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '14000.00000000',
                    status: 'FILLED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    workingTime: 1689149087774,
                    fills: [
                        {
                            matchType: 'ONE_PARTY_TRADE_REPORT',
                            price: '28000.00000000',
                            qty: '0.50000000',
                            commission: '0.00000000',
                            commissionAsset: 'BTC',
                            tradeId: -1,
                            allocId: 0,
                        },
                    ],
                    workingFloor: 'SOR',
                    selfTradePreventionMode: 'NONE',
                    usedSor: true,
                })
            );

            const spy = jest.spyOn(client, 'sorOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderResponse>)
            );
            const response = await client.sorOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sorOrder() successfully with optional parameters', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
                timeInForce: SorOrderTimeInForceEnum.GTC,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                icebergQty: 1.0,
                newOrderRespType: SorOrderNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: SorOrderSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    orderId: 2,
                    orderListId: -1,
                    clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                    transactTime: 1689149087774,
                    price: '31000.00000000',
                    origQty: '0.50000000',
                    executedQty: '0.50000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '14000.00000000',
                    status: 'FILLED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    workingTime: 1689149087774,
                    fills: [
                        {
                            matchType: 'ONE_PARTY_TRADE_REPORT',
                            price: '28000.00000000',
                            qty: '0.50000000',
                            commission: '0.00000000',
                            commissionAsset: 'BTC',
                            tradeId: -1,
                            allocId: 0,
                        },
                    ],
                    workingFloor: 'SOR',
                    selfTradePreventionMode: 'NONE',
                    usedSor: true,
                })
            );

            const spy = jest.spyOn(client, 'sorOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderResponse>)
            );
            const response = await client.sorOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling sorOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sorOrder').mockRejectedValueOnce(mockError);
            await expect(client.sorOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sorOrderTest()', () => {
        it('should execute sorOrderTest() successfully with required parameters only', async () => {
            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.25000000',
                    },
                })
            );

            const spy = jest.spyOn(client, 'sorOrderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderTestResponse>)
            );
            const response = await client.sorOrderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sorOrderTest() successfully with optional parameters', async () => {
            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
                computeCommissionRates: false,
                timeInForce: SorOrderTestTimeInForceEnum.GTC,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                icebergQty: 1.0,
                newOrderRespType: SorOrderTestNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: SorOrderTestSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.25000000',
                    },
                })
            );

            const spy = jest.spyOn(client, 'sorOrderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderTestResponse>)
            );
            const response = await client.sorOrderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sorOrderTest').mockRejectedValueOnce(mockError);
            await expect(client.sorOrderTest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
