/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountCommissionRequest,
    AllOrderListRequest,
    AllOrdersRequest,
    GetAccountRequest,
    GetOpenOrdersRequest,
    GetOrderRequest,
    GetOrderListRequest,
    MyAllocationsRequest,
    MyFiltersRequest,
    MyPreventedMatchesRequest,
    MyTradesRequest,
    OpenOrderListRequest,
    OrderAmendmentsRequest,
    RateLimitOrderRequest,
} from '../../../src/rest-api';
import type {
    AccountCommissionResponse,
    AllOrderListResponse,
    AllOrdersResponse,
    GetAccountResponse,
    GetOpenOrdersResponse,
    GetOrderListResponse,
    GetOrderResponse,
    MyAllocationsResponse,
    MyFiltersResponse,
    MyPreventedMatchesResponse,
    MyTradesResponse,
    OpenOrderListResponse,
    OrderAmendmentsResponse,
    RateLimitOrderResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountCommission()', () => {
        it('should execute accountCommission() successfully with required parameters only', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    standardCommission: {
                        maker: '0.00000010',
                        taker: '0.00000020',
                        buyer: '0.00000030',
                        seller: '0.00000040',
                    },
                    specialCommission: {
                        maker: '0.01000000',
                        taker: '0.02000000',
                        buyer: '0.03000000',
                        seller: '0.04000000',
                    },
                    taxCommission: {
                        maker: '0.00000112',
                        taker: '0.00000114',
                        buyer: '0.00000118',
                        seller: '0.00000116',
                    },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.75000000',
                    },
                })
            );

            const spy = jest.spyOn(client, 'accountCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountCommissionResponse>)
            );
            const response = await client.accountCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountCommission() successfully with optional parameters', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    standardCommission: {
                        maker: '0.00000010',
                        taker: '0.00000020',
                        buyer: '0.00000030',
                        seller: '0.00000040',
                    },
                    specialCommission: {
                        maker: '0.01000000',
                        taker: '0.02000000',
                        buyer: '0.03000000',
                        seller: '0.04000000',
                    },
                    taxCommission: {
                        maker: '0.00000112',
                        taker: '0.00000114',
                        buyer: '0.00000118',
                        seller: '0.00000116',
                    },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.75000000',
                    },
                })
            );

            const spy = jest.spyOn(client, 'accountCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountCommissionResponse>)
            );
            const response = await client.accountCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.accountCommission(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling accountCommission.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountCommission').mockRejectedValueOnce(mockError);
            await expect(client.accountCommission(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrderList()', () => {
        it('should execute allOrderList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderListId: 29,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                        transactionTime: 1565245913483,
                        symbol: 'LTCBTC',
                        orders: [
                            {
                                symbol: 'LTCBTC',
                                orderId: 5,
                                clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3',
                            },
                            {
                                symbol: 'LTCBTC',
                                orderId: 4,
                                clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB',
                            },
                        ],
                    },
                    {
                        orderListId: 28,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                        transactionTime: 1565245913407,
                        symbol: 'LTCBTC',
                        orders: [
                            {
                                symbol: 'LTCBTC',
                                orderId: 2,
                                clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP',
                            },
                            {
                                symbol: 'LTCBTC',
                                orderId: 3,
                                clientOrderId: 'z0KCjOdditiLS5ekAFtK81',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrderListResponse>)
            );
            const response = await client.allOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrderList() successfully with optional parameters', async () => {
            const params: AllOrderListRequest = {
                fromId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderListId: 29,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                        transactionTime: 1565245913483,
                        symbol: 'LTCBTC',
                        orders: [
                            {
                                symbol: 'LTCBTC',
                                orderId: 5,
                                clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3',
                            },
                            {
                                symbol: 'LTCBTC',
                                orderId: 4,
                                clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB',
                            },
                        ],
                    },
                    {
                        orderListId: 28,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                        transactionTime: 1565245913407,
                        symbol: 'LTCBTC',
                        orders: [
                            {
                                symbol: 'LTCBTC',
                                orderId: 2,
                                clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP',
                            },
                            {
                                symbol: 'LTCBTC',
                                orderId: 3,
                                clientOrderId: 'z0KCjOdditiLS5ekAFtK81',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrderListResponse>)
            );
            const response = await client.allOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrderList').mockRejectedValueOnce(mockError);
            await expect(client.allOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrders()', () => {
        it('should execute allOrders() successfully with required parameters only', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'LTCBTC',
                        orderId: 1,
                        orderListId: -1,
                        clientOrderId: 'myOrder1',
                        price: '0.1',
                        origQty: '1.0',
                        executedQty: '0.0',
                        cummulativeQuoteQty: '0.0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        stopPrice: '0.0',
                        icebergQty: '0.0',
                        time: 1499827319559,
                        updateTime: 1499827319559,
                        isWorking: true,
                        origQuoteOrderQty: '0.000000',
                        workingTime: 1499827319559,
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrders() successfully with optional parameters', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'LTCBTC',
                        orderId: 1,
                        orderListId: -1,
                        clientOrderId: 'myOrder1',
                        price: '0.1',
                        origQty: '1.0',
                        executedQty: '0.0',
                        cummulativeQuoteQty: '0.0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        stopPrice: '0.0',
                        icebergQty: '0.0',
                        time: 1499827319559,
                        updateTime: 1499827319559,
                        isWorking: true,
                        origQuoteOrderQty: '0.000000',
                        workingTime: 1499827319559,
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.allOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling allOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrders').mockRejectedValueOnce(mockError);
            await expect(client.allOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAccount()', () => {
        it('should execute getAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    makerCommission: 15,
                    takerCommission: 15,
                    buyerCommission: 0,
                    sellerCommission: 0,
                    commissionRates: {
                        maker: '0.00150000',
                        taker: '0.00150000',
                        buyer: '0.00000000',
                        seller: '0.00000000',
                    },
                    canTrade: true,
                    canWithdraw: true,
                    canDeposit: true,
                    brokered: false,
                    requireSelfTradePrevention: false,
                    preventSor: false,
                    updateTime: 123456789,
                    accountType: 'SPOT',
                    balances: [
                        { asset: 'LTC', free: '4763368.68006011', locked: '0.00000000' },
                        { asset: 'BTC', free: '4723846.89208129', locked: '0.00000000' },
                    ],
                    permissions: ['SPOT'],
                    uid: 354937868,
                })
            );

            const spy = jest.spyOn(client, 'getAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAccountResponse>)
            );
            const response = await client.getAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAccount() successfully with optional parameters', async () => {
            const params: GetAccountRequest = {
                omitZeroBalances: false,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    makerCommission: 15,
                    takerCommission: 15,
                    buyerCommission: 0,
                    sellerCommission: 0,
                    commissionRates: {
                        maker: '0.00150000',
                        taker: '0.00150000',
                        buyer: '0.00000000',
                        seller: '0.00000000',
                    },
                    canTrade: true,
                    canWithdraw: true,
                    canDeposit: true,
                    brokered: false,
                    requireSelfTradePrevention: false,
                    preventSor: false,
                    updateTime: 123456789,
                    accountType: 'SPOT',
                    balances: [
                        { asset: 'LTC', free: '4763368.68006011', locked: '0.00000000' },
                        { asset: 'BTC', free: '4723846.89208129', locked: '0.00000000' },
                    ],
                    permissions: ['SPOT'],
                    uid: 354937868,
                })
            );

            const spy = jest.spyOn(client, 'getAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAccountResponse>)
            );
            const response = await client.getAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getAccount').mockRejectedValueOnce(mockError);
            await expect(client.getAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOpenOrders()', () => {
        it('should execute getOpenOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'LTCBTC',
                        orderId: 1,
                        orderListId: -1,
                        clientOrderId: 'myOrder1',
                        price: '0.1',
                        origQty: '1.0',
                        executedQty: '0.0',
                        cummulativeQuoteQty: '0.0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        stopPrice: '0.0',
                        icebergQty: '0.0',
                        time: 1499827319559,
                        updateTime: 1499827319559,
                        isWorking: true,
                        origQuoteOrderQty: '0.000000',
                        workingTime: 1499827319559,
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenOrdersResponse>)
            );
            const response = await client.getOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOpenOrders() successfully with optional parameters', async () => {
            const params: GetOpenOrdersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'LTCBTC',
                        orderId: 1,
                        orderListId: -1,
                        clientOrderId: 'myOrder1',
                        price: '0.1',
                        origQty: '1.0',
                        executedQty: '0.0',
                        cummulativeQuoteQty: '0.0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        stopPrice: '0.0',
                        icebergQty: '0.0',
                        time: 1499827319559,
                        updateTime: 1499827319559,
                        isWorking: true,
                        origQuoteOrderQty: '0.000000',
                        workingTime: 1499827319559,
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenOrdersResponse>)
            );
            const response = await client.getOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.getOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrder()', () => {
        it('should execute getOrder() successfully with required parameters only', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    workingTime: 1499827319559,
                    origQuoteOrderQty: '0.000000',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'getOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderResponse>)
            );
            const response = await client.getOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrder() successfully with optional parameters', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    workingTime: 1499827319559,
                    origQuoteOrderQty: '0.000000',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'getOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderResponse>)
            );
            const response = await client.getOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrder').mockRejectedValueOnce(mockError);
            await expect(client.getOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderList()', () => {
        it('should execute getOrderList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 27,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                    transactionTime: 1565245656253,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderListResponse>)
            );
            const response = await client.getOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderList() successfully with optional parameters', async () => {
            const params: GetOrderListRequest = {
                orderListId: 1,
                origClientOrderId: 'origClientOrderId_example',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderListId: 27,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                    transactionTime: 1565245656253,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderListResponse>)
            );
            const response = await client.getOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrderList').mockRejectedValueOnce(mockError);
            await expect(client.getOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myAllocations()', () => {
        it('should execute myAllocations() successfully with required parameters only', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        allocationId: 0,
                        allocationType: 'SOR',
                        orderId: 1,
                        orderListId: -1,
                        price: '1.00000000',
                        qty: '5.00000000',
                        quoteQty: '5.00000000',
                        commission: '0.00000000',
                        commissionAsset: 'BTC',
                        time: 1687506878118,
                        isBuyer: true,
                        isMaker: false,
                        isAllocator: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'myAllocations').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyAllocationsResponse>)
            );
            const response = await client.myAllocations(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myAllocations() successfully with optional parameters', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
                startTime: 1735693200000,
                endTime: 1735693200000,
                fromAllocationId: 1,
                limit: 500,
                orderId: 1,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        allocationId: 0,
                        allocationType: 'SOR',
                        orderId: 1,
                        orderListId: -1,
                        price: '1.00000000',
                        qty: '5.00000000',
                        quoteQty: '5.00000000',
                        commission: '0.00000000',
                        commissionAsset: 'BTC',
                        time: 1687506878118,
                        isBuyer: true,
                        isMaker: false,
                        isAllocator: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'myAllocations').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyAllocationsResponse>)
            );
            const response = await client.myAllocations(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myAllocations(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myAllocations.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myAllocations').mockRejectedValueOnce(mockError);
            await expect(client.myAllocations(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myFilters()', () => {
        it('should execute myFilters() successfully with required parameters only', async () => {
            const params: MyFiltersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    exchangeFilters: [
                        { filterType: 'EXCHANGE_MAX_NUM_ORDERS', maxNumOrders: 1000 },
                    ],
                    symbolFilters: [{ filterType: 'MAX_NUM_ORDER_LISTS', maxNumOrderLists: 20 }],
                    assetFilters: [
                        { filterType: 'MAX_ASSET', asset: 'JPY', limit: '1000000.00000000' },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                        },
                        { rateLimitType: 'ORDERS', interval: 'DAY', intervalNum: 1, limit: 160000 },
                        {
                            rateLimitType: 'RAW_REQUESTS',
                            interval: 'MINUTE',
                            intervalNum: 5,
                            limit: 61000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'myFilters').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyFiltersResponse>)
            );
            const response = await client.myFilters(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myFilters() successfully with optional parameters', async () => {
            const params: MyFiltersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    exchangeFilters: [
                        { filterType: 'EXCHANGE_MAX_NUM_ORDERS', maxNumOrders: 1000 },
                    ],
                    symbolFilters: [{ filterType: 'MAX_NUM_ORDER_LISTS', maxNumOrderLists: 20 }],
                    assetFilters: [
                        { filterType: 'MAX_ASSET', asset: 'JPY', limit: '1000000.00000000' },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                        },
                        { rateLimitType: 'ORDERS', interval: 'DAY', intervalNum: 1, limit: 160000 },
                        {
                            rateLimitType: 'RAW_REQUESTS',
                            interval: 'MINUTE',
                            intervalNum: 5,
                            limit: 61000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'myFilters').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyFiltersResponse>)
            );
            const response = await client.myFilters(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyFiltersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myFilters(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myFilters.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyFiltersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myFilters').mockRejectedValueOnce(mockError);
            await expect(client.myFilters(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myPreventedMatches()', () => {
        it('should execute myPreventedMatches() successfully with required parameters only', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        preventedMatchId: 1,
                        takerOrderId: 5,
                        makerSymbol: 'BTCUSDT',
                        makerOrderId: 3,
                        tradeGroupId: 1,
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        price: '1.100000',
                        makerPreventedQuantity: '1.300000',
                        transactTime: 1669101687094,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'myPreventedMatches').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyPreventedMatchesResponse>)
            );
            const response = await client.myPreventedMatches(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myPreventedMatches() successfully with optional parameters', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
                preventedMatchId: 1,
                orderId: 1,
                fromPreventedMatchId: 1,
                limit: 500,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        preventedMatchId: 1,
                        takerOrderId: 5,
                        makerSymbol: 'BTCUSDT',
                        makerOrderId: 3,
                        tradeGroupId: 1,
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        price: '1.100000',
                        makerPreventedQuantity: '1.300000',
                        transactTime: 1669101687094,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'myPreventedMatches').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyPreventedMatchesResponse>)
            );
            const response = await client.myPreventedMatches(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myPreventedMatches(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myPreventedMatches.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myPreventedMatches').mockRejectedValueOnce(mockError);
            await expect(client.myPreventedMatches(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myTrades()', () => {
        it('should execute myTrades() successfully with required parameters only', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BNBBTC',
                        id: 28457,
                        orderId: 100234,
                        orderListId: -1,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.000012',
                        commission: '10.10000000',
                        commissionAsset: 'BNB',
                        time: 1499865549590,
                        isBuyer: true,
                        isMaker: false,
                        isBestMatch: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'myTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyTradesResponse>)
            );
            const response = await client.myTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myTrades() successfully with optional parameters', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                fromId: 1,
                limit: 500,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BNBBTC',
                        id: 28457,
                        orderId: 100234,
                        orderListId: -1,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.000012',
                        commission: '10.10000000',
                        commissionAsset: 'BNB',
                        time: 1499865549590,
                        isBuyer: true,
                        isMaker: false,
                        isBestMatch: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'myTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyTradesResponse>)
            );
            const response = await client.myTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myTrades').mockRejectedValueOnce(mockError);
            await expect(client.myTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openOrderList()', () => {
        it('should execute openOrderList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderListId: 31,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                        transactionTime: 1565246080644,
                        symbol: 'LTCBTC',
                        orders: [
                            {
                                symbol: 'LTCBTC',
                                orderId: 5,
                                clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2',
                            },
                            {
                                symbol: 'LTCBTC',
                                orderId: 4,
                                clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenOrderListResponse>)
            );
            const response = await client.openOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openOrderList() successfully with optional parameters', async () => {
            const params: OpenOrderListRequest = {
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderListId: 31,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                        transactionTime: 1565246080644,
                        symbol: 'LTCBTC',
                        orders: [
                            {
                                symbol: 'LTCBTC',
                                orderId: 5,
                                clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2',
                            },
                            {
                                symbol: 'LTCBTC',
                                orderId: 4,
                                clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenOrderListResponse>)
            );
            const response = await client.openOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openOrderList').mockRejectedValueOnce(mockError);
            await expect(client.openOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderAmendments()', () => {
        it('should execute orderAmendments() successfully with required parameters only', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        orderId: 9,
                        executionId: 22,
                        origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                        newClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                        origQty: '5.00000000',
                        newQty: '4.00000000',
                        time: 1741669661670,
                    },
                    {
                        symbol: 'BTCUDST',
                        orderId: 9,
                        executionId: 25,
                        origClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                        newClientOrderId: '5uS0r35ohuQyDlCzZuYXq2',
                        origQty: '4.00000000',
                        newQty: '3.00000000',
                        time: 1741672924895,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'orderAmendments').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendmentsResponse>)
            );
            const response = await client.orderAmendments(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderAmendments() successfully with optional parameters', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                fromExecutionId: 1,
                limit: 500,
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        orderId: 9,
                        executionId: 22,
                        origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                        newClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                        origQty: '5.00000000',
                        newQty: '4.00000000',
                        time: 1741669661670,
                    },
                    {
                        symbol: 'BTCUDST',
                        orderId: 9,
                        executionId: 25,
                        origClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                        newClientOrderId: '5uS0r35ohuQyDlCzZuYXq2',
                        origQty: '4.00000000',
                        newQty: '3.00000000',
                        time: 1741672924895,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'orderAmendments').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendmentsResponse>)
            );
            const response = await client.orderAmendments(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderAmendments(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderAmendments.'
            );
        });

        it('should throw RequiredError when orderId is missing', async () => {
            const _params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.orderId;

            await expect(client.orderAmendments(params)).rejects.toThrow(
                'Required parameter orderId was null or undefined when calling orderAmendments.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderAmendments').mockRejectedValueOnce(mockError);
            await expect(client.orderAmendments(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('rateLimitOrder()', () => {
        it('should execute rateLimitOrder() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 0,
                    },
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'DAY',
                        intervalNum: 1,
                        limit: 160000,
                        count: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'rateLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RateLimitOrderResponse>)
            );
            const response = await client.rateLimitOrder();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute rateLimitOrder() successfully with optional parameters', async () => {
            const params: RateLimitOrderRequest = {
                recvWindow: 5000.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 0,
                    },
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'DAY',
                        intervalNum: 1,
                        limit: 160000,
                        count: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'rateLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RateLimitOrderResponse>)
            );
            const response = await client.rateLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'rateLimitOrder').mockRejectedValueOnce(mockError);
            await expect(client.rateLimitOrder()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
