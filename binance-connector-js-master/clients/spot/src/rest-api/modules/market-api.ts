/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AggTradesResponse,
    AvgPriceResponse,
    DepthResponse,
    GetTradesResponse,
    HistoricalTradesResponse,
    KlinesResponse,
    Ticker24hrResponse,
    TickerBookTickerResponse,
    TickerPriceResponse,
    TickerResponse,
    TickerTradingDayResponse,
    UiKlinesResponse,
} from '../types';

/**
 * MarketApi - axios parameter creator
 */
const MarketApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
         * Weight: 4
         *
         * @summary Compressed/Aggregate trades list
         * @param {string} symbol
         * @param {number | bigint} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        aggTrades: async (
            symbol: string,
            fromId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('aggTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/aggTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Current average price for a symbol.
         * Weight: 2
         *
         * @summary Current average price
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        avgPrice: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('avgPrice', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/avgPrice',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         *
         * Weight: Adjusted based on the limit:
         *
         * |Limit|Request Weight
         * ------|-------
         * 1-100|  5
         * 101-500| 25
         * 501-1000| 50
         * 1001-5000| 250
         *
         * @summary Order book
         * @param {string} symbol
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {DepthSymbolStatusEnum} [symbolStatus]
         *
         * @throws {RequiredError}
         */
        depth: async (
            symbol: string,
            limit?: number,
            symbolStatus?: DepthSymbolStatusEnum
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('depth', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (symbolStatus !== undefined && symbolStatus !== null) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/depth',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get recent trades.
         * Weight: 25
         *
         * @summary Recent trades list
         * @param {string} symbol
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        getTrades: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/trades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get older trades.
         * Weight: 25
         *
         * @summary Old trade lookup
         * @param {string} symbol
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number | bigint} [fromId] ID to get aggregate trades from INCLUSIVE.
         *
         * @throws {RequiredError}
         */
        historicalTrades: async (
            symbol: string,
            limit?: number,
            fromId?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('historicalTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/historicalTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a symbol.
         * Klines are uniquely identified by their open time.
         * Weight: 2
         *
         * @summary Kline/Candlestick data
         * @param {string} symbol
         * @param {KlinesIntervalEnum} interval
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        klines: async (
            symbol: string,
            interval: KlinesIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            timeZone?: string,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('klines', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('klines', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (timeZone !== undefined && timeZone !== null) {
                localVarQueryParameter['timeZone'] = timeZone;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/klines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         *
         * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
         *
         * @summary Rolling window price change statistics
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {TickerWindowSizeEnum} [windowSize]
         * @param {TickerTypeEnum} [type]
         * @param {TickerSymbolStatusEnum} [symbolStatus]
         *
         * @throws {RequiredError}
         */
        ticker: async (
            symbol?: string,
            symbols?: Array<string>,
            windowSize?: TickerWindowSizeEnum,
            type?: TickerTypeEnum,
            symbolStatus?: TickerSymbolStatusEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }
            if (windowSize !== undefined && windowSize !== null) {
                localVarQueryParameter['windowSize'] = windowSize;
            }
            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }
            if (symbolStatus !== undefined && symbolStatus !== null) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
         * Weight: <table>
         * <thead>
         * <tr>
         * <th>Parameter</th>
         * <th>Symbols Provided</th>
         * <th>Weight</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td rowspan="2">symbol</td>
         * <td>1</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>symbol parameter is omitted</td>
         * <td>80</td>
         * </tr>
         * <tr>
         * <td rowspan="4">symbols</td>
         * <td>1-20</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>21-100</td>
         * <td>40</td>
         * </tr>
         * <tr>
         * <td>101 or more</td>
         * <td>80</td>
         * </tr>
         * <tr>
         * <td>symbols parameter is omitted</td>
         * <td>80</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @summary 24hr ticker price change statistics
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {Ticker24hrTypeEnum} [type]
         * @param {Ticker24hrSymbolStatusEnum} [symbolStatus]
         *
         * @throws {RequiredError}
         */
        ticker24hr: async (
            symbol?: string,
            symbols?: Array<string>,
            type?: Ticker24hrTypeEnum,
            symbolStatus?: Ticker24hrSymbolStatusEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }
            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }
            if (symbolStatus !== undefined && symbolStatus !== null) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/24hr',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * Weight: <table>
         * <thead>
         * <tr>
         * <th>Parameter</th>
         * <th>Symbols Provided</th>
         * <th>Weight</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td rowspan="2">symbol</td>
         * <td>1</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>symbol parameter is omitted</td>
         * <td>4</td>
         * </tr>
         * <tr>
         * <td>symbols</td>
         * <td>Any</td>
         * <td>4</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @summary Symbol order book ticker
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {TickerBookTickerSymbolStatusEnum} [symbolStatus]
         *
         * @throws {RequiredError}
         */
        tickerBookTicker: async (
            symbol?: string,
            symbols?: Array<string>,
            symbolStatus?: TickerBookTickerSymbolStatusEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }
            if (symbolStatus !== undefined && symbolStatus !== null) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/bookTicker',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * Weight: <table>
         * <thead>
         * <tr>
         * <th>Parameter</th>
         * <th>Symbols Provided</th>
         * <th>Weight</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td rowspan="2">symbol</td>
         * <td>1</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>symbol parameter is omitted</td>
         * <td>4</td>
         * </tr>
         * <tr>
         * <td>symbols</td>
         * <td>Any</td>
         * <td>4</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @summary Symbol price ticker
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {TickerPriceSymbolStatusEnum} [symbolStatus]
         *
         * @throws {RequiredError}
         */
        tickerPrice: async (
            symbol?: string,
            symbols?: Array<string>,
            symbolStatus?: TickerPriceSymbolStatusEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }
            if (symbolStatus !== undefined && symbolStatus !== null) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/price',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Price change statistics for a trading day.
         * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
         *
         * @summary Trading Day Ticker
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {TickerTradingDayTypeEnum} [type]
         * @param {TickerTradingDaySymbolStatusEnum} [symbolStatus]
         *
         * @throws {RequiredError}
         */
        tickerTradingDay: async (
            symbol?: string,
            symbols?: Array<string>,
            timeZone?: string,
            type?: TickerTradingDayTypeEnum,
            symbolStatus?: TickerTradingDaySymbolStatusEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }
            if (timeZone !== undefined && timeZone !== null) {
                localVarQueryParameter['timeZone'] = timeZone;
            }
            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }
            if (symbolStatus !== undefined && symbolStatus !== null) {
                localVarQueryParameter['symbolStatus'] = symbolStatus;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/tradingDay',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The request is similar to klines having the same parameters and response.
         *
         * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
         * Weight: 2
         *
         * @summary UIKlines
         * @param {string} symbol
         * @param {UiKlinesIntervalEnum} interval
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        uiKlines: async (
            symbol: string,
            interval: UiKlinesIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            timeZone?: string,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('uiKlines', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('uiKlines', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (timeZone !== undefined && timeZone !== null) {
                localVarQueryParameter['timeZone'] = timeZone;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/uiKlines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * MarketApi - interface
 * @interface MarketApi
 */
export interface MarketApiInterface {
    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * Weight: 4
     *
     * @summary Compressed/Aggregate trades list
     * @param {AggTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    aggTrades(requestParameters: AggTradesRequest): Promise<RestApiResponse<AggTradesResponse>>;
    /**
     * Current average price for a symbol.
     * Weight: 2
     *
     * @summary Current average price
     * @param {AvgPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    avgPrice(requestParameters: AvgPriceRequest): Promise<RestApiResponse<AvgPriceResponse>>;
    /**
     *
     * Weight: Adjusted based on the limit:
     *
     * |Limit|Request Weight
     * ------|-------
     * 1-100|  5
     * 101-500| 25
     * 501-1000| 50
     * 1001-5000| 250
     *
     * @summary Order book
     * @param {DepthRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    depth(requestParameters: DepthRequest): Promise<RestApiResponse<DepthResponse>>;
    /**
     * Get recent trades.
     * Weight: 25
     *
     * @summary Recent trades list
     * @param {GetTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    getTrades(requestParameters: GetTradesRequest): Promise<RestApiResponse<GetTradesResponse>>;
    /**
     * Get older trades.
     * Weight: 25
     *
     * @summary Old trade lookup
     * @param {HistoricalTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    historicalTrades(
        requestParameters: HistoricalTradesRequest
    ): Promise<RestApiResponse<HistoricalTradesResponse>>;
    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     * Weight: 2
     *
     * @summary Kline/Candlestick data
     * @param {KlinesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    klines(requestParameters: KlinesRequest): Promise<RestApiResponse<KlinesResponse>>;
    /**
     *
     * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Rolling window price change statistics
     * @param {TickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    ticker(requestParameters?: TickerRequest): Promise<RestApiResponse<TickerResponse>>;
    /**
     * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td rowspan="4">symbols</td>
     * <td>1-20</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>21-100</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>101 or more</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td>symbols parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary 24hr ticker price change statistics
     * @param {Ticker24hrRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    ticker24hr(requestParameters?: Ticker24hrRequest): Promise<RestApiResponse<Ticker24hrResponse>>;
    /**
     * Best price/qty on the order book for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol order book ticker
     * @param {TickerBookTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    tickerBookTicker(
        requestParameters?: TickerBookTickerRequest
    ): Promise<RestApiResponse<TickerBookTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol price ticker
     * @param {TickerPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    tickerPrice(
        requestParameters?: TickerPriceRequest
    ): Promise<RestApiResponse<TickerPriceResponse>>;
    /**
     * Price change statistics for a trading day.
     * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Trading Day Ticker
     * @param {TickerTradingDayRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    tickerTradingDay(
        requestParameters?: TickerTradingDayRequest
    ): Promise<RestApiResponse<TickerTradingDayResponse>>;
    /**
     * The request is similar to klines having the same parameters and response.
     *
     * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
     * Weight: 2
     *
     * @summary UIKlines
     * @param {UiKlinesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    uiKlines(requestParameters: UiKlinesRequest): Promise<RestApiResponse<UiKlinesResponse>>;
}

/**
 * Request parameters for aggTrades operation in MarketApi.
 * @interface AggTradesRequest
 */
export interface AggTradesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiAggTrades
     */
    readonly symbol: string;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiAggTrades
     */
    readonly fromId?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiAggTrades
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiAggTrades
     */
    readonly endTime?: number | bigint;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiAggTrades
     */
    readonly limit?: number;
}

/**
 * Request parameters for avgPrice operation in MarketApi.
 * @interface AvgPriceRequest
 */
export interface AvgPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiAvgPrice
     */
    readonly symbol: string;
}

/**
 * Request parameters for depth operation in MarketApi.
 * @interface DepthRequest
 */
export interface DepthRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiDepth
     */
    readonly symbol: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiDepth
     */
    readonly limit?: number;

    /**
     *
     * @type {'TRADING' | 'END_OF_DAY' | 'HALT' | 'BREAK' | 'NON_REPRESENTABLE'}
     * @memberof MarketApiDepth
     */
    readonly symbolStatus?: DepthSymbolStatusEnum;
}

/**
 * Request parameters for getTrades operation in MarketApi.
 * @interface GetTradesRequest
 */
export interface GetTradesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiGetTrades
     */
    readonly symbol: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiGetTrades
     */
    readonly limit?: number;
}

/**
 * Request parameters for historicalTrades operation in MarketApi.
 * @interface HistoricalTradesRequest
 */
export interface HistoricalTradesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiHistoricalTrades
     */
    readonly symbol: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiHistoricalTrades
     */
    readonly limit?: number;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiHistoricalTrades
     */
    readonly fromId?: number | bigint;
}

/**
 * Request parameters for klines operation in MarketApi.
 * @interface KlinesRequest
 */
export interface KlinesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiKlines
     */
    readonly symbol: string;

    /**
     *
     * @type {'1s' | '1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketApiKlines
     */
    readonly interval: KlinesIntervalEnum;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiKlines
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiKlines
     */
    readonly endTime?: number | bigint;

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof MarketApiKlines
     */
    readonly timeZone?: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiKlines
     */
    readonly limit?: number;
}

/**
 * Request parameters for ticker operation in MarketApi.
 * @interface TickerRequest
 */
export interface TickerRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTicker
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTicker
     */
    readonly symbols?: Array<string>;

    /**
     *
     * @type {'1m' | '2m' | '3m' | '4m' | '5m' | '6m' | '7m' | '8m' | '9m' | '10m' | '11m' | '12m' | '13m' | '14m' | '15m' | '16m' | '17m' | '18m' | '19m' | '20m' | '21m' | '22m' | '23m' | '24m' | '25m' | '26m' | '27m' | '28m' | '29m' | '30m' | '31m' | '32m' | '33m' | '34m' | '35m' | '36m' | '37m' | '38m' | '39m' | '40m' | '41m' | '42m' | '43m' | '44m' | '45m' | '46m' | '47m' | '48m' | '49m' | '50m' | '51m' | '52m' | '53m' | '54m' | '55m' | '56m' | '57m' | '58m' | '59m' | '1h' | '2h' | '3h' | '4h' | '5h' | '6h' | '7h' | '8h' | '9h' | '10h' | '11h' | '12h' | '13h' | '14h' | '15h' | '16h' | '17h' | '18h' | '19h' | '20h' | '21h' | '22h' | '23h' | '1d' | '2d' | '3d' | '4d' | '5d' | '6d'}
     * @memberof MarketApiTicker
     */
    readonly windowSize?: TickerWindowSizeEnum;

    /**
     *
     * @type {'FULL' | 'MINI'}
     * @memberof MarketApiTicker
     */
    readonly type?: TickerTypeEnum;

    /**
     *
     * @type {'TRADING' | 'END_OF_DAY' | 'HALT' | 'BREAK' | 'NON_REPRESENTABLE'}
     * @memberof MarketApiTicker
     */
    readonly symbolStatus?: TickerSymbolStatusEnum;
}

/**
 * Request parameters for ticker24hr operation in MarketApi.
 * @interface Ticker24hrRequest
 */
export interface Ticker24hrRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTicker24hr
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTicker24hr
     */
    readonly symbols?: Array<string>;

    /**
     *
     * @type {'FULL' | 'MINI'}
     * @memberof MarketApiTicker24hr
     */
    readonly type?: Ticker24hrTypeEnum;

    /**
     *
     * @type {'TRADING' | 'END_OF_DAY' | 'HALT' | 'BREAK' | 'NON_REPRESENTABLE'}
     * @memberof MarketApiTicker24hr
     */
    readonly symbolStatus?: Ticker24hrSymbolStatusEnum;
}

/**
 * Request parameters for tickerBookTicker operation in MarketApi.
 * @interface TickerBookTickerRequest
 */
export interface TickerBookTickerRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTickerBookTicker
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTickerBookTicker
     */
    readonly symbols?: Array<string>;

    /**
     *
     * @type {'TRADING' | 'END_OF_DAY' | 'HALT' | 'BREAK' | 'NON_REPRESENTABLE'}
     * @memberof MarketApiTickerBookTicker
     */
    readonly symbolStatus?: TickerBookTickerSymbolStatusEnum;
}

/**
 * Request parameters for tickerPrice operation in MarketApi.
 * @interface TickerPriceRequest
 */
export interface TickerPriceRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTickerPrice
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTickerPrice
     */
    readonly symbols?: Array<string>;

    /**
     *
     * @type {'TRADING' | 'END_OF_DAY' | 'HALT' | 'BREAK' | 'NON_REPRESENTABLE'}
     * @memberof MarketApiTickerPrice
     */
    readonly symbolStatus?: TickerPriceSymbolStatusEnum;
}

/**
 * Request parameters for tickerTradingDay operation in MarketApi.
 * @interface TickerTradingDayRequest
 */
export interface TickerTradingDayRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTickerTradingDay
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTickerTradingDay
     */
    readonly symbols?: Array<string>;

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof MarketApiTickerTradingDay
     */
    readonly timeZone?: string;

    /**
     *
     * @type {'FULL' | 'MINI'}
     * @memberof MarketApiTickerTradingDay
     */
    readonly type?: TickerTradingDayTypeEnum;

    /**
     *
     * @type {'TRADING' | 'END_OF_DAY' | 'HALT' | 'BREAK' | 'NON_REPRESENTABLE'}
     * @memberof MarketApiTickerTradingDay
     */
    readonly symbolStatus?: TickerTradingDaySymbolStatusEnum;
}

/**
 * Request parameters for uiKlines operation in MarketApi.
 * @interface UiKlinesRequest
 */
export interface UiKlinesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiUiKlines
     */
    readonly symbol: string;

    /**
     *
     * @type {'1s' | '1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketApiUiKlines
     */
    readonly interval: UiKlinesIntervalEnum;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiUiKlines
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketApiUiKlines
     */
    readonly endTime?: number | bigint;

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof MarketApiUiKlines
     */
    readonly timeZone?: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiUiKlines
     */
    readonly limit?: number;
}

/**
 * MarketApi - object-oriented interface
 * @class MarketApi
 */
export class MarketApi implements MarketApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration);
    }

    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * Weight: 4
     *
     * @summary Compressed/Aggregate trades list
     * @param {AggTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AggTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#compressedaggregate-trades-list Binance API Documentation}
     */
    public async aggTrades(
        requestParameters: AggTradesRequest
    ): Promise<RestApiResponse<AggTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.aggTrades(
            requestParameters?.symbol,
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<AggTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Current average price for a symbol.
     * Weight: 2
     *
     * @summary Current average price
     * @param {AvgPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AvgPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#current-average-price Binance API Documentation}
     */
    public async avgPrice(
        requestParameters: AvgPriceRequest
    ): Promise<RestApiResponse<AvgPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.avgPrice(
            requestParameters?.symbol
        );
        return sendRequest<AvgPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     *
     * Weight: Adjusted based on the limit:
     *
     * |Limit|Request Weight
     * ------|-------
     * 1-100|  5
     * 101-500| 25
     * 501-1000| 50
     * 1001-5000| 250
     *
     * @summary Order book
     * @param {DepthRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DepthResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#order-book Binance API Documentation}
     */
    public async depth(requestParameters: DepthRequest): Promise<RestApiResponse<DepthResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.depth(
            requestParameters?.symbol,
            requestParameters?.limit,
            requestParameters?.symbolStatus
        );
        return sendRequest<DepthResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get recent trades.
     * Weight: 25
     *
     * @summary Recent trades list
     * @param {GetTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#recent-trades-list Binance API Documentation}
     */
    public async getTrades(
        requestParameters: GetTradesRequest
    ): Promise<RestApiResponse<GetTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getTrades(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<GetTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get older trades.
     * Weight: 25
     *
     * @summary Old trade lookup
     * @param {HistoricalTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<HistoricalTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup Binance API Documentation}
     */
    public async historicalTrades(
        requestParameters: HistoricalTradesRequest
    ): Promise<RestApiResponse<HistoricalTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.historicalTrades(
            requestParameters?.symbol,
            requestParameters?.limit,
            requestParameters?.fromId
        );
        return sendRequest<HistoricalTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     * Weight: 2
     *
     * @summary Kline/Candlestick data
     * @param {KlinesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<KlinesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data Binance API Documentation}
     */
    public async klines(
        requestParameters: KlinesRequest
    ): Promise<RestApiResponse<KlinesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.klines(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.timeZone,
            requestParameters?.limit
        );
        return sendRequest<KlinesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     *
     * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Rolling window price change statistics
     * @param {TickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#rolling-window-price-change-statistics Binance API Documentation}
     */
    public async ticker(
        requestParameters: TickerRequest = {}
    ): Promise<RestApiResponse<TickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.ticker(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.windowSize,
            requestParameters?.type,
            requestParameters?.symbolStatus
        );
        return sendRequest<TickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td rowspan="4">symbols</td>
     * <td>1-20</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>21-100</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>101 or more</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td>symbols parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary 24hr ticker price change statistics
     * @param {Ticker24hrRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<Ticker24hrResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics Binance API Documentation}
     */
    public async ticker24hr(
        requestParameters: Ticker24hrRequest = {}
    ): Promise<RestApiResponse<Ticker24hrResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.ticker24hr(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.type,
            requestParameters?.symbolStatus
        );
        return sendRequest<Ticker24hrResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol order book ticker
     * @param {TickerBookTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerBookTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-order-book-ticker Binance API Documentation}
     */
    public async tickerBookTicker(
        requestParameters: TickerBookTickerRequest = {}
    ): Promise<RestApiResponse<TickerBookTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerBookTicker(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.symbolStatus
        );
        return sendRequest<TickerBookTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol price ticker
     * @param {TickerPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-price-ticker Binance API Documentation}
     */
    public async tickerPrice(
        requestParameters: TickerPriceRequest = {}
    ): Promise<RestApiResponse<TickerPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerPrice(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.symbolStatus
        );
        return sendRequest<TickerPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Price change statistics for a trading day.
     * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Trading Day Ticker
     * @param {TickerTradingDayRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerTradingDayResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#trading-day-ticker Binance API Documentation}
     */
    public async tickerTradingDay(
        requestParameters: TickerTradingDayRequest = {}
    ): Promise<RestApiResponse<TickerTradingDayResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerTradingDay(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.timeZone,
            requestParameters?.type,
            requestParameters?.symbolStatus
        );
        return sendRequest<TickerTradingDayResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The request is similar to klines having the same parameters and response.
     *
     * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
     * Weight: 2
     *
     * @summary UIKlines
     * @param {UiKlinesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UiKlinesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#uiklines Binance API Documentation}
     */
    public async uiKlines(
        requestParameters: UiKlinesRequest
    ): Promise<RestApiResponse<UiKlinesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.uiKlines(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.timeZone,
            requestParameters?.limit
        );
        return sendRequest<UiKlinesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }
}

export enum DepthSymbolStatusEnum {
    TRADING = 'TRADING',
    END_OF_DAY = 'END_OF_DAY',
    HALT = 'HALT',
    BREAK = 'BREAK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum KlinesIntervalEnum {
    INTERVAL_1s = '1s',
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}

export enum TickerWindowSizeEnum {
    WINDOW_SIZE_1m = '1m',
    WINDOW_SIZE_2m = '2m',
    WINDOW_SIZE_3m = '3m',
    WINDOW_SIZE_4m = '4m',
    WINDOW_SIZE_5m = '5m',
    WINDOW_SIZE_6m = '6m',
    WINDOW_SIZE_7m = '7m',
    WINDOW_SIZE_8m = '8m',
    WINDOW_SIZE_9m = '9m',
    WINDOW_SIZE_10m = '10m',
    WINDOW_SIZE_11m = '11m',
    WINDOW_SIZE_12m = '12m',
    WINDOW_SIZE_13m = '13m',
    WINDOW_SIZE_14m = '14m',
    WINDOW_SIZE_15m = '15m',
    WINDOW_SIZE_16m = '16m',
    WINDOW_SIZE_17m = '17m',
    WINDOW_SIZE_18m = '18m',
    WINDOW_SIZE_19m = '19m',
    WINDOW_SIZE_20m = '20m',
    WINDOW_SIZE_21m = '21m',
    WINDOW_SIZE_22m = '22m',
    WINDOW_SIZE_23m = '23m',
    WINDOW_SIZE_24m = '24m',
    WINDOW_SIZE_25m = '25m',
    WINDOW_SIZE_26m = '26m',
    WINDOW_SIZE_27m = '27m',
    WINDOW_SIZE_28m = '28m',
    WINDOW_SIZE_29m = '29m',
    WINDOW_SIZE_30m = '30m',
    WINDOW_SIZE_31m = '31m',
    WINDOW_SIZE_32m = '32m',
    WINDOW_SIZE_33m = '33m',
    WINDOW_SIZE_34m = '34m',
    WINDOW_SIZE_35m = '35m',
    WINDOW_SIZE_36m = '36m',
    WINDOW_SIZE_37m = '37m',
    WINDOW_SIZE_38m = '38m',
    WINDOW_SIZE_39m = '39m',
    WINDOW_SIZE_40m = '40m',
    WINDOW_SIZE_41m = '41m',
    WINDOW_SIZE_42m = '42m',
    WINDOW_SIZE_43m = '43m',
    WINDOW_SIZE_44m = '44m',
    WINDOW_SIZE_45m = '45m',
    WINDOW_SIZE_46m = '46m',
    WINDOW_SIZE_47m = '47m',
    WINDOW_SIZE_48m = '48m',
    WINDOW_SIZE_49m = '49m',
    WINDOW_SIZE_50m = '50m',
    WINDOW_SIZE_51m = '51m',
    WINDOW_SIZE_52m = '52m',
    WINDOW_SIZE_53m = '53m',
    WINDOW_SIZE_54m = '54m',
    WINDOW_SIZE_55m = '55m',
    WINDOW_SIZE_56m = '56m',
    WINDOW_SIZE_57m = '57m',
    WINDOW_SIZE_58m = '58m',
    WINDOW_SIZE_59m = '59m',
    WINDOW_SIZE_1h = '1h',
    WINDOW_SIZE_2h = '2h',
    WINDOW_SIZE_3h = '3h',
    WINDOW_SIZE_4h = '4h',
    WINDOW_SIZE_5h = '5h',
    WINDOW_SIZE_6h = '6h',
    WINDOW_SIZE_7h = '7h',
    WINDOW_SIZE_8h = '8h',
    WINDOW_SIZE_9h = '9h',
    WINDOW_SIZE_10h = '10h',
    WINDOW_SIZE_11h = '11h',
    WINDOW_SIZE_12h = '12h',
    WINDOW_SIZE_13h = '13h',
    WINDOW_SIZE_14h = '14h',
    WINDOW_SIZE_15h = '15h',
    WINDOW_SIZE_16h = '16h',
    WINDOW_SIZE_17h = '17h',
    WINDOW_SIZE_18h = '18h',
    WINDOW_SIZE_19h = '19h',
    WINDOW_SIZE_20h = '20h',
    WINDOW_SIZE_21h = '21h',
    WINDOW_SIZE_22h = '22h',
    WINDOW_SIZE_23h = '23h',
    WINDOW_SIZE_1d = '1d',
    WINDOW_SIZE_2d = '2d',
    WINDOW_SIZE_3d = '3d',
    WINDOW_SIZE_4d = '4d',
    WINDOW_SIZE_5d = '5d',
    WINDOW_SIZE_6d = '6d',
}

export enum TickerTypeEnum {
    FULL = 'FULL',
    MINI = 'MINI',
}

export enum TickerSymbolStatusEnum {
    TRADING = 'TRADING',
    END_OF_DAY = 'END_OF_DAY',
    HALT = 'HALT',
    BREAK = 'BREAK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum Ticker24hrTypeEnum {
    FULL = 'FULL',
    MINI = 'MINI',
}

export enum Ticker24hrSymbolStatusEnum {
    TRADING = 'TRADING',
    END_OF_DAY = 'END_OF_DAY',
    HALT = 'HALT',
    BREAK = 'BREAK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum TickerBookTickerSymbolStatusEnum {
    TRADING = 'TRADING',
    END_OF_DAY = 'END_OF_DAY',
    HALT = 'HALT',
    BREAK = 'BREAK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum TickerPriceSymbolStatusEnum {
    TRADING = 'TRADING',
    END_OF_DAY = 'END_OF_DAY',
    HALT = 'HALT',
    BREAK = 'BREAK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum TickerTradingDayTypeEnum {
    FULL = 'FULL',
    MINI = 'MINI',
}

export enum TickerTradingDaySymbolStatusEnum {
    TRADING = 'TRADING',
    END_OF_DAY = 'END_OF_DAY',
    HALT = 'HALT',
    BREAK = 'BREAK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum UiKlinesIntervalEnum {
    INTERVAL_1s = '1s',
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}
