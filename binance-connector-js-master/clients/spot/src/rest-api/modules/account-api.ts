/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AccountCommissionResponse,
    AllOrderListResponse,
    AllOrdersResponse,
    GetAccountResponse,
    GetOpenOrdersResponse,
    GetOrderListResponse,
    GetOrderResponse,
    MyAllocationsResponse,
    MyFiltersResponse,
    MyPreventedMatchesResponse,
    MyTradesResponse,
    OpenOrderListResponse,
    OrderAmendmentsResponse,
    RateLimitOrderResponse,
} from '../types';

/**
 * AccountApi - axios parameter creator
 */
const AccountApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Get current account commission rates.
         * Weight: 20
         *
         * @summary Query Commission Rates
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        accountCommission: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('accountCommission', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/account/commission',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves all order lists based on provided optional parameters.
         *
         * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
         * Weight: 20
         *
         * @summary Query all Order lists
         * @param {number | bigint} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        allOrderList: async (
            fromId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/allOrderList',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         * Weight: 20
         *
         * @summary All orders
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        allOrders: async (
            symbol: string,
            orderId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('allOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/allOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current account information.
         * Weight: 20
         *
         * @summary Account information
         * @param {boolean} [omitZeroBalances] When set to `true`, emits only the non-zero balances of an account. <br>Default value: `false`
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        getAccount: async (
            omitZeroBalances?: boolean,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (omitZeroBalances !== undefined && omitZeroBalances !== null) {
                localVarQueryParameter['omitZeroBalances'] = omitZeroBalances;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/account',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
         * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
         *
         * @summary Current open orders
         * @param {string} [symbol] Symbol to query
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        getOpenOrders: async (symbol?: string, recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/openOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an order's status.
         * Weight: 4
         *
         * @summary Query order
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        getOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves a specific order list based on provided optional parameters.
         * Weight: 4
         *
         * @summary Query Order list
         * @param {number | bigint} [orderListId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        getOrderList: async (
            orderListId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves allocations resulting from SOR order placement.
         * Weight: 20
         *
         * @summary Query Allocations
         * @param {string} symbol
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [fromAllocationId]
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number | bigint} [orderId]
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        myAllocations: async (
            symbol: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            fromAllocationId?: number,
            limit?: number,
            orderId?: number | bigint,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('myAllocations', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (fromAllocationId !== undefined && fromAllocationId !== null) {
                localVarQueryParameter['fromAllocationId'] = fromAllocationId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/myAllocations',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves the list of [filters](filters.md) relevant to an account on a given symbol. This is the only endpoint that shows if an account has `MAX_ASSET` filters applied to it.
         * Weight: 40
         *
         * @summary Query relevant filters
         * @param {string} symbol
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        myFilters: async (symbol: string, recvWindow?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('myFilters', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/myFilters',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Displays the list of orders that were expired due to STP.
         *
         * These are the combinations supported:
         *
         * `symbol` + `preventedMatchId`
         * `symbol` + `orderId`
         * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
         * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
         * Weight: Case                            | Weight
         * ----                            | -----
         * If `symbol` is invalid          | 2
         * Querying by `preventedMatchId`  | 2
         * Querying by `orderId`           | 20
         *
         * @summary Query Prevented Matches
         * @param {string} symbol
         * @param {number | bigint} [preventedMatchId]
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [fromPreventedMatchId]
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        myPreventedMatches: async (
            symbol: string,
            preventedMatchId?: number | bigint,
            orderId?: number | bigint,
            fromPreventedMatchId?: number | bigint,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('myPreventedMatches', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (preventedMatchId !== undefined && preventedMatchId !== null) {
                localVarQueryParameter['preventedMatchId'] = preventedMatchId;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (fromPreventedMatchId !== undefined && fromPreventedMatchId !== null) {
                localVarQueryParameter['fromPreventedMatchId'] = fromPreventedMatchId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/myPreventedMatches',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get trades for a specific account and symbol.
         * Weight: Condition| Weight|
         * ---| ---
         * |Without orderId|20|
         * |With orderId|5|
         *
         * @summary Account trade list
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number | bigint} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        myTrades: async (
            symbol: string,
            orderId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            fromId?: number | bigint,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('myTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/myTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         *
         * Weight: 6
         *
         * @summary Query Open Order lists
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        openOrderList: async (recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/openOrderList',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Queries all amendments of a single order.
         * Weight: 4
         *
         * @summary Query Order Amendments
         * @param {string} symbol
         * @param {number | bigint} orderId
         * @param {number | bigint} [fromExecutionId]
         * @param {number | bigint} [limit] Default:500; Maximum: 1000
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        orderAmendments: async (
            symbol: string,
            orderId: number | bigint,
            fromExecutionId?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderAmendments', 'symbol', symbol);
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderAmendments', 'orderId', orderId);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (fromExecutionId !== undefined && fromExecutionId !== null) {
                localVarQueryParameter['fromExecutionId'] = fromExecutionId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/amendments',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Displays the user's unfilled order count for all intervals.
         * Weight: 40
         *
         * @summary Query Unfilled Order Count
         * @param {number} [recvWindow] The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
         *
         * @throws {RequiredError}
         */
        rateLimitOrder: async (recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/rateLimit/order',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * AccountApi - interface
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * Get current account commission rates.
     * Weight: 20
     *
     * @summary Query Commission Rates
     * @param {AccountCommissionRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    accountCommission(
        requestParameters: AccountCommissionRequest
    ): Promise<RestApiResponse<AccountCommissionResponse>>;
    /**
     * Retrieves all order lists based on provided optional parameters.
     *
     * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
     * Weight: 20
     *
     * @summary Query all Order lists
     * @param {AllOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    allOrderList(
        requestParameters?: AllOrderListRequest
    ): Promise<RestApiResponse<AllOrderListResponse>>;
    /**
     * Get all account orders; active, canceled, or filled.
     * Weight: 20
     *
     * @summary All orders
     * @param {AllOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    allOrders(requestParameters: AllOrdersRequest): Promise<RestApiResponse<AllOrdersResponse>>;
    /**
     * Get current account information.
     * Weight: 20
     *
     * @summary Account information
     * @param {GetAccountRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getAccount(requestParameters?: GetAccountRequest): Promise<RestApiResponse<GetAccountResponse>>;
    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
     *
     * @summary Current open orders
     * @param {GetOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getOpenOrders(
        requestParameters?: GetOpenOrdersRequest
    ): Promise<RestApiResponse<GetOpenOrdersResponse>>;
    /**
     * Check an order's status.
     * Weight: 4
     *
     * @summary Query order
     * @param {GetOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getOrder(requestParameters: GetOrderRequest): Promise<RestApiResponse<GetOrderResponse>>;
    /**
     * Retrieves a specific order list based on provided optional parameters.
     * Weight: 4
     *
     * @summary Query Order list
     * @param {GetOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getOrderList(
        requestParameters?: GetOrderListRequest
    ): Promise<RestApiResponse<GetOrderListResponse>>;
    /**
     * Retrieves allocations resulting from SOR order placement.
     * Weight: 20
     *
     * @summary Query Allocations
     * @param {MyAllocationsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    myAllocations(
        requestParameters: MyAllocationsRequest
    ): Promise<RestApiResponse<MyAllocationsResponse>>;
    /**
     * Retrieves the list of [filters](filters.md) relevant to an account on a given symbol. This is the only endpoint that shows if an account has `MAX_ASSET` filters applied to it.
     * Weight: 40
     *
     * @summary Query relevant filters
     * @param {MyFiltersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    myFilters(requestParameters: MyFiltersRequest): Promise<RestApiResponse<MyFiltersResponse>>;
    /**
     * Displays the list of orders that were expired due to STP.
     *
     * These are the combinations supported:
     *
     * `symbol` + `preventedMatchId`
     * `symbol` + `orderId`
     * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
     * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
     * Weight: Case                            | Weight
     * ----                            | -----
     * If `symbol` is invalid          | 2
     * Querying by `preventedMatchId`  | 2
     * Querying by `orderId`           | 20
     *
     * @summary Query Prevented Matches
     * @param {MyPreventedMatchesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    myPreventedMatches(
        requestParameters: MyPreventedMatchesRequest
    ): Promise<RestApiResponse<MyPreventedMatchesResponse>>;
    /**
     * Get trades for a specific account and symbol.
     * Weight: Condition| Weight|
     * ---| ---
     * |Without orderId|20|
     * |With orderId|5|
     *
     * @summary Account trade list
     * @param {MyTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    myTrades(requestParameters: MyTradesRequest): Promise<RestApiResponse<MyTradesResponse>>;
    /**
     *
     * Weight: 6
     *
     * @summary Query Open Order lists
     * @param {OpenOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    openOrderList(
        requestParameters?: OpenOrderListRequest
    ): Promise<RestApiResponse<OpenOrderListResponse>>;
    /**
     * Queries all amendments of a single order.
     * Weight: 4
     *
     * @summary Query Order Amendments
     * @param {OrderAmendmentsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    orderAmendments(
        requestParameters: OrderAmendmentsRequest
    ): Promise<RestApiResponse<OrderAmendmentsResponse>>;
    /**
     * Displays the user's unfilled order count for all intervals.
     * Weight: 40
     *
     * @summary Query Unfilled Order Count
     * @param {RateLimitOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    rateLimitOrder(
        requestParameters?: RateLimitOrderRequest
    ): Promise<RestApiResponse<RateLimitOrderResponse>>;
}

/**
 * Request parameters for accountCommission operation in AccountApi.
 * @interface AccountCommissionRequest
 */
export interface AccountCommissionRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiAccountCommission
     */
    readonly symbol: string;
}

/**
 * Request parameters for allOrderList operation in AccountApi.
 * @interface AllOrderListRequest
 */
export interface AllOrderListRequest {
    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiAllOrderList
     */
    readonly fromId?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiAllOrderList
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiAllOrderList
     */
    readonly endTime?: number | bigint;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof AccountApiAllOrderList
     */
    readonly limit?: number;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiAllOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for allOrders operation in AccountApi.
 * @interface AllOrdersRequest
 */
export interface AllOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiAllOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiAllOrders
     */
    readonly orderId?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiAllOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiAllOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof AccountApiAllOrders
     */
    readonly limit?: number;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiAllOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getAccount operation in AccountApi.
 * @interface GetAccountRequest
 */
export interface GetAccountRequest {
    /**
     * When set to `true`, emits only the non-zero balances of an account. <br>Default value: `false`
     * @type {boolean}
     * @memberof AccountApiGetAccount
     */
    readonly omitZeroBalances?: boolean;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiGetAccount
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOpenOrders operation in AccountApi.
 * @interface GetOpenOrdersRequest
 */
export interface GetOpenOrdersRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof AccountApiGetOpenOrders
     */
    readonly symbol?: string;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiGetOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOrder operation in AccountApi.
 * @interface GetOrderRequest
 */
export interface GetOrderRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiGetOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof AccountApiGetOrder
     */
    readonly origClientOrderId?: string;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiGetOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOrderList operation in AccountApi.
 * @interface GetOrderListRequest
 */
export interface GetOrderListRequest {
    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {number | bigint}
     * @memberof AccountApiGetOrderList
     */
    readonly orderListId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof AccountApiGetOrderList
     */
    readonly origClientOrderId?: string;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiGetOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for myAllocations operation in AccountApi.
 * @interface MyAllocationsRequest
 */
export interface MyAllocationsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiMyAllocations
     */
    readonly symbol: string;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiMyAllocations
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiMyAllocations
     */
    readonly endTime?: number | bigint;

    /**
     *
     * @type {number}
     * @memberof AccountApiMyAllocations
     */
    readonly fromAllocationId?: number;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof AccountApiMyAllocations
     */
    readonly limit?: number;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiMyAllocations
     */
    readonly orderId?: number | bigint;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiMyAllocations
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for myFilters operation in AccountApi.
 * @interface MyFiltersRequest
 */
export interface MyFiltersRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiMyFilters
     */
    readonly symbol: string;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiMyFilters
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for myPreventedMatches operation in AccountApi.
 * @interface MyPreventedMatchesRequest
 */
export interface MyPreventedMatchesRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiMyPreventedMatches
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiMyPreventedMatches
     */
    readonly preventedMatchId?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiMyPreventedMatches
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiMyPreventedMatches
     */
    readonly fromPreventedMatchId?: number | bigint;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof AccountApiMyPreventedMatches
     */
    readonly limit?: number;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiMyPreventedMatches
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for myTrades operation in AccountApi.
 * @interface MyTradesRequest
 */
export interface MyTradesRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiMyTrades
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiMyTrades
     */
    readonly orderId?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiMyTrades
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiMyTrades
     */
    readonly endTime?: number | bigint;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiMyTrades
     */
    readonly fromId?: number | bigint;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof AccountApiMyTrades
     */
    readonly limit?: number;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiMyTrades
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for openOrderList operation in AccountApi.
 * @interface OpenOrderListRequest
 */
export interface OpenOrderListRequest {
    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiOpenOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderAmendments operation in AccountApi.
 * @interface OrderAmendmentsRequest
 */
export interface OrderAmendmentsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiOrderAmendments
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiOrderAmendments
     */
    readonly orderId: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiOrderAmendments
     */
    readonly fromExecutionId?: number | bigint;

    /**
     * Default:500; Maximum: 1000
     * @type {number | bigint}
     * @memberof AccountApiOrderAmendments
     */
    readonly limit?: number | bigint;

    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiOrderAmendments
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for rateLimitOrder operation in AccountApi.
 * @interface RateLimitOrderRequest
 */
export interface RateLimitOrderRequest {
    /**
     * The value cannot be greater than `60000`. <br> Supports up to three decimal places of precision (e.g., 6000.346) so that microseconds may be specified.
     * @type {number}
     * @memberof AccountApiRateLimitOrder
     */
    readonly recvWindow?: number;
}

/**
 * AccountApi - object-oriented interface
 * @class AccountApi
 */
export class AccountApi implements AccountApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
    }

    /**
     * Get current account commission rates.
     * Weight: 20
     *
     * @summary Query Commission Rates
     * @param {AccountCommissionRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AccountCommissionResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-commission-rates-user_data Binance API Documentation}
     */
    public async accountCommission(
        requestParameters: AccountCommissionRequest
    ): Promise<RestApiResponse<AccountCommissionResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountCommission(
            requestParameters?.symbol
        );
        return sendRequest<AccountCommissionResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves all order lists based on provided optional parameters.
     *
     * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
     * Weight: 20
     *
     * @summary Query all Order lists
     * @param {AllOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AllOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-all-order-lists-user_data Binance API Documentation}
     */
    public async allOrderList(
        requestParameters: AllOrderListRequest = {}
    ): Promise<RestApiResponse<AllOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrderList(
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AllOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all account orders; active, canceled, or filled.
     * Weight: 20
     *
     * @summary All orders
     * @param {AllOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AllOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#all-orders-user_data Binance API Documentation}
     */
    public async allOrders(
        requestParameters: AllOrdersRequest
    ): Promise<RestApiResponse<AllOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrders(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AllOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current account information.
     * Weight: 20
     *
     * @summary Account information
     * @param {GetAccountRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetAccountResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-information-user_data Binance API Documentation}
     */
    public async getAccount(
        requestParameters: GetAccountRequest = {}
    ): Promise<RestApiResponse<GetAccountResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getAccount(
            requestParameters?.omitZeroBalances,
            requestParameters?.recvWindow
        );
        return sendRequest<GetAccountResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
     *
     * @summary Current open orders
     * @param {GetOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#current-open-orders-user_data Binance API Documentation}
     */
    public async getOpenOrders(
        requestParameters: GetOpenOrdersRequest = {}
    ): Promise<RestApiResponse<GetOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an order's status.
     * Weight: 4
     *
     * @summary Query order
     * @param {GetOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-order-user_data Binance API Documentation}
     */
    public async getOrder(
        requestParameters: GetOrderRequest
    ): Promise<RestApiResponse<GetOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves a specific order list based on provided optional parameters.
     * Weight: 4
     *
     * @summary Query Order list
     * @param {GetOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-order-list-user_data Binance API Documentation}
     */
    public async getOrderList(
        requestParameters: GetOrderListRequest = {}
    ): Promise<RestApiResponse<GetOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrderList(
            requestParameters?.orderListId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves allocations resulting from SOR order placement.
     * Weight: 20
     *
     * @summary Query Allocations
     * @param {MyAllocationsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MyAllocationsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-allocations-user_data Binance API Documentation}
     */
    public async myAllocations(
        requestParameters: MyAllocationsRequest
    ): Promise<RestApiResponse<MyAllocationsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.myAllocations(
            requestParameters?.symbol,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromAllocationId,
            requestParameters?.limit,
            requestParameters?.orderId,
            requestParameters?.recvWindow
        );
        return sendRequest<MyAllocationsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves the list of [filters](filters.md) relevant to an account on a given symbol. This is the only endpoint that shows if an account has `MAX_ASSET` filters applied to it.
     * Weight: 40
     *
     * @summary Query relevant filters
     * @param {MyFiltersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MyFiltersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-relevant-filters-user_data Binance API Documentation}
     */
    public async myFilters(
        requestParameters: MyFiltersRequest
    ): Promise<RestApiResponse<MyFiltersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.myFilters(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<MyFiltersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Displays the list of orders that were expired due to STP.
     *
     * These are the combinations supported:
     *
     * `symbol` + `preventedMatchId`
     * `symbol` + `orderId`
     * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
     * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
     * Weight: Case                            | Weight
     * ----                            | -----
     * If `symbol` is invalid          | 2
     * Querying by `preventedMatchId`  | 2
     * Querying by `orderId`           | 20
     *
     * @summary Query Prevented Matches
     * @param {MyPreventedMatchesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MyPreventedMatchesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-prevented-matches-user_data Binance API Documentation}
     */
    public async myPreventedMatches(
        requestParameters: MyPreventedMatchesRequest
    ): Promise<RestApiResponse<MyPreventedMatchesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.myPreventedMatches(
            requestParameters?.symbol,
            requestParameters?.preventedMatchId,
            requestParameters?.orderId,
            requestParameters?.fromPreventedMatchId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<MyPreventedMatchesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get trades for a specific account and symbol.
     * Weight: Condition| Weight|
     * ---| ---
     * |Without orderId|20|
     * |With orderId|5|
     *
     * @summary Account trade list
     * @param {MyTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MyTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-trade-list-user_data Binance API Documentation}
     */
    public async myTrades(
        requestParameters: MyTradesRequest
    ): Promise<RestApiResponse<MyTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.myTrades(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<MyTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     *
     * Weight: 6
     *
     * @summary Query Open Order lists
     * @param {OpenOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-open-order-lists-user_data Binance API Documentation}
     */
    public async openOrderList(
        requestParameters: OpenOrderListRequest = {}
    ): Promise<RestApiResponse<OpenOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openOrderList(
            requestParameters?.recvWindow
        );
        return sendRequest<OpenOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Queries all amendments of a single order.
     * Weight: 4
     *
     * @summary Query Order Amendments
     * @param {OrderAmendmentsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderAmendmentsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-order-amendments-user_data Binance API Documentation}
     */
    public async orderAmendments(
        requestParameters: OrderAmendmentsRequest
    ): Promise<RestApiResponse<OrderAmendmentsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderAmendments(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.fromExecutionId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderAmendmentsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Displays the user's unfilled order count for all intervals.
     * Weight: 40
     *
     * @summary Query Unfilled Order Count
     * @param {RateLimitOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<RateLimitOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-unfilled-order-count-user_data Binance API Documentation}
     */
    public async rateLimitOrder(
        requestParameters: RateLimitOrderRequest = {}
    ): Promise<RestApiResponse<RateLimitOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.rateLimitOrder(
            requestParameters?.recvWindow
        );
        return sendRequest<RateLimitOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}
