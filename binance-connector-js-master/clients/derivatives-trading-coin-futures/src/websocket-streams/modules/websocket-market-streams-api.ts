/**
 * Binance Derivatives Trading COIN Futures WebSocket Market Streams
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    WebsocketStreamsBase,
    WebsocketStream,
    assertParamExists,
    replaceWebsocketStreamsPlaceholders,
    createStreamHandler,
} from '@binance/common';
import type {
    AggregateTradeStreamsResponse,
    AllBookTickersStreamResponse,
    AllMarketLiquidationOrderStreamsResponse,
    AllMarketMiniTickersStreamResponse,
    AllMarketTickersStreamsResponse,
    ContinuousContractKlineCandlestickStreamsResponse,
    ContractInfoStreamResponse,
    DiffBookDepthStreamsResponse,
    IndexKlineCandlestickStreamsResponse,
    IndexPriceStreamResponse,
    IndividualSymbolBookTickerStreamsResponse,
    IndividualSymbolMiniTickerStreamResponse,
    IndividualSymbolTickerStreamsResponse,
    KlineCandlestickStreamsResponse,
    LiquidationOrderStreamsResponse,
    MarkPriceKlineCandlestickStreamsResponse,
    MarkPriceOfAllSymbolsOfAPairResponse,
    MarkPriceStreamResponse,
    PartialBookDepthStreamsResponse,
} from '../types';

const WebsocketMarketStreamsApiParamCreator = function () {
    return {
        /**
         * The Aggregate Trade Streams push market trade information that is aggregated for fills with same price and taking side every 100 milliseconds.
         *
         * Update Speed: 100ms
         *
         * @summary Aggregate Trade Streams
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        aggregateTradeStreams: (symbol: string, id?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('aggregateTradeStreams', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@aggTrade'.slice(1), {
                symbol,
                id,
            });
        },
        /**
         * Pushes any update to the best bid or ask's price or quantity in real-time for all symbols.
         *
         * Update Speed: Real-time
         *
         * @summary All Book Tickers Stream
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        allBookTickersStream: (id?: string): string => {
            return replaceWebsocketStreamsPlaceholders('/!bookTicker'.slice(1), { id });
        },
        /**
         * The All Liquidation Order Snapshot Streams push force liquidation order information for all symbols in the market.
         * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will be pushed.
         *
         * Update Speed: 1000ms
         *
         * @summary All Market Liquidation Order Streams
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        allMarketLiquidationOrderStreams: (id?: string): string => {
            return replaceWebsocketStreamsPlaceholders('/!forceOrder@arr'.slice(1), { id });
        },
        /**
         * 24hr rolling window mini-ticker statistics for all symbols. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers that have changed will be present in the array.
         *
         * Update Speed: 1000ms
         *
         * @summary All Market Mini Tickers Stream
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        allMarketMiniTickersStream: (id?: string): string => {
            return replaceWebsocketStreamsPlaceholders('/!miniTicker@arr'.slice(1), { id });
        },
        /**
         * 24hr rolling window ticker statistics for all symbols. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers that have changed will be present in the array.
         *
         * Update Speed: 1000ms
         *
         * @summary All Market Tickers Streams
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        allMarketTickersStreams: (id?: string): string => {
            return replaceWebsocketStreamsPlaceholders('/!ticker@arr'.slice(1), { id });
        },
        /**
         * Kline update every second
         *
         * Update Speed: 250ms
         *
         * @summary Continuous Contract Kline/Candlestick Streams
         * @param {string} pair The pair parameter
         * @param {string} contractType The contractType parameter
         * @param {string} interval The interval parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        continuousContractKlineCandlestickStreams: (
            pair: string,
            contractType: string,
            interval: string,
            id?: string
        ): string => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickStreams', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists(
                'continuousContractKlineCandlestickStreams',
                'contractType',
                contractType
            );
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickStreams', 'interval', interval);

            return replaceWebsocketStreamsPlaceholders(
                '/<pair>_<contractType>@continuousKline_<interval>'.slice(1),
                { pair, contractType, interval, id }
            );
        },
        /**
         * ContractInfo stream pushes when contract info updates(listing/settlement/contract bracket update). `bks` field only shows up when bracket gets updated.
         *
         * Update Speed: Real-time
         *
         * @summary Contract Info Stream
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        contractInfoStream: (id?: string): string => {
            return replaceWebsocketStreamsPlaceholders('/!contractInfo'.slice(1), { id });
        },
        /**
         * Bids and asks, pushed every 250 milliseconds, 500 milliseconds, or 100 milliseconds
         *
         * Update Speed: 250ms or 500ms or 100ms
         *
         * @summary Diff. Book Depth Streams
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         * @param {string} [updateSpeed] WebSocket stream update speed
         *
         * @throws {RequiredError}
         */
        diffBookDepthStreams: (symbol: string, id?: string, updateSpeed?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('diffBookDepthStreams', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@depth@<updateSpeed>'.slice(1), {
                symbol,
                id,
                updateSpeed,
            });
        },
        /**
         * Index Kline/Candlestick Streams
         *
         * Update Speed: 250ms
         *
         * @summary Index Kline/Candlestick Streams
         * @param {string} pair The pair parameter
         * @param {string} interval The interval parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        indexKlineCandlestickStreams: (pair: string, interval: string, id?: string): string => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('indexKlineCandlestickStreams', 'pair', pair);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('indexKlineCandlestickStreams', 'interval', interval);

            return replaceWebsocketStreamsPlaceholders(
                '/<pair>@indexPriceKline_<interval>'.slice(1),
                { pair, interval, id }
            );
        },
        /**
         * Index Price Stream
         *
         * Update Speed: 3000ms OR 1000ms
         *
         * @summary Index Price Stream
         * @param {string} pair The pair parameter
         * @param {string} [id] Unique WebSocket request ID.
         * @param {string} [updateSpeed] WebSocket stream update speed
         *
         * @throws {RequiredError}
         */
        indexPriceStream: (pair: string, id?: string, updateSpeed?: string): string => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('indexPriceStream', 'pair', pair);

            return replaceWebsocketStreamsPlaceholders(
                '/<pair>@indexPrice@<updateSpeed>'.slice(1),
                { pair, id, updateSpeed }
            );
        },
        /**
         * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
         *
         * Update Speed: Real-time
         *
         * @summary Individual Symbol Book Ticker Streams
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        individualSymbolBookTickerStreams: (symbol: string, id?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('individualSymbolBookTickerStreams', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@bookTicker'.slice(1), {
                symbol,
                id,
            });
        },
        /**
         * 24hr rolling window mini-ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
         *
         * Update Speed: 500ms
         *
         * @summary Individual Symbol Mini Ticker Stream
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        individualSymbolMiniTickerStream: (symbol: string, id?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('individualSymbolMiniTickerStream', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@miniTicker'.slice(1), {
                symbol,
                id,
            });
        },
        /**
         * 24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
         *
         * Update Speed: 500ms
         *
         * @summary Individual Symbol Ticker Streams
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        individualSymbolTickerStreams: (symbol: string, id?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('individualSymbolTickerStreams', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@ticker'.slice(1), { symbol, id });
        },
        /**
         * The Kline/Candlestick Stream push updates to the current klines/candlestick every 250 milliseconds (if existing).
         *
         * Update Speed: 250ms
         *
         * @summary Kline/Candlestick Streams
         * @param {string} symbol The symbol parameter
         * @param {string} interval The interval parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        klineCandlestickStreams: (symbol: string, interval: string, id?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('klineCandlestickStreams', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('klineCandlestickStreams', 'interval', interval);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@kline_<interval>'.slice(1), {
                symbol,
                interval,
                id,
            });
        },
        /**
         * The Liquidation Order Snapshot Streams push force liquidation order information for specific symbol.
         *
         * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will be pushed.
         *
         * Update Speed: 1000ms
         *
         * @summary Liquidation Order Streams
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        liquidationOrderStreams: (symbol: string, id?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('liquidationOrderStreams', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders('/<symbol>@forceOrder'.slice(1), {
                symbol,
                id,
            });
        },
        /**
         * Mark Price Kline/Candlestick Streams
         *
         * Update Speed: 250ms
         *
         * @summary Mark Price Kline/Candlestick Streams
         * @param {string} symbol The symbol parameter
         * @param {string} interval The interval parameter
         * @param {string} [id] Unique WebSocket request ID.
         *
         * @throws {RequiredError}
         */
        markPriceKlineCandlestickStreams: (
            symbol: string,
            interval: string,
            id?: string
        ): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('markPriceKlineCandlestickStreams', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('markPriceKlineCandlestickStreams', 'interval', interval);

            return replaceWebsocketStreamsPlaceholders(
                '/<symbol>@markPriceKline_<interval>'.slice(1),
                { symbol, interval, id }
            );
        },
        /**
         * Mark Price of All Symbols of a Pair
         *
         * Update Speed: 3000ms OR 1000ms
         *
         * @summary Mark Price of All Symbols of a Pair
         * @param {string} pair The pair parameter
         * @param {string} [id] Unique WebSocket request ID.
         * @param {string} [updateSpeed] WebSocket stream update speed
         *
         * @throws {RequiredError}
         */
        markPriceOfAllSymbolsOfAPair: (pair: string, id?: string, updateSpeed?: string): string => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('markPriceOfAllSymbolsOfAPair', 'pair', pair);

            return replaceWebsocketStreamsPlaceholders('/<pair>@markPrice@<updateSpeed>'.slice(1), {
                pair,
                id,
                updateSpeed,
            });
        },
        /**
         * Mark price update stream
         *
         * Update Speed: 3000ms OR 1000ms
         *
         * @summary Mark Price Stream
         * @param {string} symbol The symbol parameter
         * @param {string} [id] Unique WebSocket request ID.
         * @param {string} [updateSpeed] WebSocket stream update speed
         *
         * @throws {RequiredError}
         */
        markPriceStream: (symbol: string, id?: string, updateSpeed?: string): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('markPriceStream', 'symbol', symbol);

            return replaceWebsocketStreamsPlaceholders(
                '/<symbol>@markPrice@<updateSpeed>'.slice(1),
                { symbol, id, updateSpeed }
            );
        },
        /**
         * Top **<levels\>** bids and asks, Valid **<levels\>** are 5, 10, or 20.
         *
         * Update Speed: 250ms, 500ms or 100ms
         *
         * @summary Partial Book Depth Streams
         * @param {string} symbol The symbol parameter
         * @param {number | bigint} levels The levels parameter
         * @param {string} [id] Unique WebSocket request ID.
         * @param {string} [updateSpeed] WebSocket stream update speed
         *
         * @throws {RequiredError}
         */
        partialBookDepthStreams: (
            symbol: string,
            levels: number | bigint,
            id?: string,
            updateSpeed?: string
        ): string => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('partialBookDepthStreams', 'symbol', symbol);
            // verify required parameter 'levels' is not null or undefined
            assertParamExists('partialBookDepthStreams', 'levels', levels);

            return replaceWebsocketStreamsPlaceholders(
                '/<symbol>@depth<levels>@<updateSpeed>'.slice(1),
                { symbol, levels, id, updateSpeed }
            );
        },
    };
};

/**
 * WebsocketMarketStreamsApi - interface
 * @interface WebsocketMarketStreamsApi
 */
export interface WebsocketMarketStreamsApiInterface {
    /**
     * The Aggregate Trade Streams push market trade information that is aggregated for fills with same price and taking side every 100 milliseconds.
     *
     * Update Speed: 100ms
     *
     * @summary Aggregate Trade Streams
     * @param {AggregateTradeStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<AggregateTradeStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    aggregateTradeStreams(
        requestParameters: AggregateTradeStreamsRequest
    ): WebsocketStream<AggregateTradeStreamsResponse>;

    /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for all symbols.
     *
     * Update Speed: Real-time
     *
     * @summary All Book Tickers Stream
     * @param {AllBookTickersStreamRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<AllBookTickersStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    allBookTickersStream(
        requestParameters?: AllBookTickersStreamRequest
    ): WebsocketStream<AllBookTickersStreamResponse>;

    /**
     * The All Liquidation Order Snapshot Streams push force liquidation order information for all symbols in the market.
     * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will be pushed.
     *
     * Update Speed: 1000ms
     *
     * @summary All Market Liquidation Order Streams
     * @param {AllMarketLiquidationOrderStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<AllMarketLiquidationOrderStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    allMarketLiquidationOrderStreams(
        requestParameters?: AllMarketLiquidationOrderStreamsRequest
    ): WebsocketStream<AllMarketLiquidationOrderStreamsResponse>;

    /**
     * 24hr rolling window mini-ticker statistics for all symbols. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers that have changed will be present in the array.
     *
     * Update Speed: 1000ms
     *
     * @summary All Market Mini Tickers Stream
     * @param {AllMarketMiniTickersStreamRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<AllMarketMiniTickersStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    allMarketMiniTickersStream(
        requestParameters?: AllMarketMiniTickersStreamRequest
    ): WebsocketStream<AllMarketMiniTickersStreamResponse>;

    /**
     * 24hr rolling window ticker statistics for all symbols. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers that have changed will be present in the array.
     *
     * Update Speed: 1000ms
     *
     * @summary All Market Tickers Streams
     * @param {AllMarketTickersStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<AllMarketTickersStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    allMarketTickersStreams(
        requestParameters?: AllMarketTickersStreamsRequest
    ): WebsocketStream<AllMarketTickersStreamsResponse>;

    /**
     * Kline update every second
     *
     * Update Speed: 250ms
     *
     * @summary Continuous Contract Kline/Candlestick Streams
     * @param {ContinuousContractKlineCandlestickStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<ContinuousContractKlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    continuousContractKlineCandlestickStreams(
        requestParameters: ContinuousContractKlineCandlestickStreamsRequest
    ): WebsocketStream<ContinuousContractKlineCandlestickStreamsResponse>;

    /**
     * ContractInfo stream pushes when contract info updates(listing/settlement/contract bracket update). `bks` field only shows up when bracket gets updated.
     *
     * Update Speed: Real-time
     *
     * @summary Contract Info Stream
     * @param {ContractInfoStreamRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<ContractInfoStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    contractInfoStream(
        requestParameters?: ContractInfoStreamRequest
    ): WebsocketStream<ContractInfoStreamResponse>;

    /**
     * Bids and asks, pushed every 250 milliseconds, 500 milliseconds, or 100 milliseconds
     *
     * Update Speed: 250ms or 500ms or 100ms
     *
     * @summary Diff. Book Depth Streams
     * @param {DiffBookDepthStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<DiffBookDepthStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    diffBookDepthStreams(
        requestParameters: DiffBookDepthStreamsRequest
    ): WebsocketStream<DiffBookDepthStreamsResponse>;

    /**
     * Index Kline/Candlestick Streams
     *
     * Update Speed: 250ms
     *
     * @summary Index Kline/Candlestick Streams
     * @param {IndexKlineCandlestickStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<IndexKlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    indexKlineCandlestickStreams(
        requestParameters: IndexKlineCandlestickStreamsRequest
    ): WebsocketStream<IndexKlineCandlestickStreamsResponse>;

    /**
     * Index Price Stream
     *
     * Update Speed: 3000ms OR 1000ms
     *
     * @summary Index Price Stream
     * @param {IndexPriceStreamRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<IndexPriceStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    indexPriceStream(
        requestParameters: IndexPriceStreamRequest
    ): WebsocketStream<IndexPriceStreamResponse>;

    /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
     *
     * Update Speed: Real-time
     *
     * @summary Individual Symbol Book Ticker Streams
     * @param {IndividualSymbolBookTickerStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<IndividualSymbolBookTickerStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    individualSymbolBookTickerStreams(
        requestParameters: IndividualSymbolBookTickerStreamsRequest
    ): WebsocketStream<IndividualSymbolBookTickerStreamsResponse>;

    /**
     * 24hr rolling window mini-ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
     *
     * Update Speed: 500ms
     *
     * @summary Individual Symbol Mini Ticker Stream
     * @param {IndividualSymbolMiniTickerStreamRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<IndividualSymbolMiniTickerStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    individualSymbolMiniTickerStream(
        requestParameters: IndividualSymbolMiniTickerStreamRequest
    ): WebsocketStream<IndividualSymbolMiniTickerStreamResponse>;

    /**
     * 24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
     *
     * Update Speed: 500ms
     *
     * @summary Individual Symbol Ticker Streams
     * @param {IndividualSymbolTickerStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<IndividualSymbolTickerStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    individualSymbolTickerStreams(
        requestParameters: IndividualSymbolTickerStreamsRequest
    ): WebsocketStream<IndividualSymbolTickerStreamsResponse>;

    /**
     * The Kline/Candlestick Stream push updates to the current klines/candlestick every 250 milliseconds (if existing).
     *
     * Update Speed: 250ms
     *
     * @summary Kline/Candlestick Streams
     * @param {KlineCandlestickStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<KlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    klineCandlestickStreams(
        requestParameters: KlineCandlestickStreamsRequest
    ): WebsocketStream<KlineCandlestickStreamsResponse>;

    /**
     * The Liquidation Order Snapshot Streams push force liquidation order information for specific symbol.
     *
     * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will be pushed.
     *
     * Update Speed: 1000ms
     *
     * @summary Liquidation Order Streams
     * @param {LiquidationOrderStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<LiquidationOrderStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    liquidationOrderStreams(
        requestParameters: LiquidationOrderStreamsRequest
    ): WebsocketStream<LiquidationOrderStreamsResponse>;

    /**
     * Mark Price Kline/Candlestick Streams
     *
     * Update Speed: 250ms
     *
     * @summary Mark Price Kline/Candlestick Streams
     * @param {MarkPriceKlineCandlestickStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<MarkPriceKlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    markPriceKlineCandlestickStreams(
        requestParameters: MarkPriceKlineCandlestickStreamsRequest
    ): WebsocketStream<MarkPriceKlineCandlestickStreamsResponse>;

    /**
     * Mark Price of All Symbols of a Pair
     *
     * Update Speed: 3000ms OR 1000ms
     *
     * @summary Mark Price of All Symbols of a Pair
     * @param {MarkPriceOfAllSymbolsOfAPairRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<MarkPriceOfAllSymbolsOfAPairResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    markPriceOfAllSymbolsOfAPair(
        requestParameters: MarkPriceOfAllSymbolsOfAPairRequest
    ): WebsocketStream<MarkPriceOfAllSymbolsOfAPairResponse>;

    /**
     * Mark price update stream
     *
     * Update Speed: 3000ms OR 1000ms
     *
     * @summary Mark Price Stream
     * @param {MarkPriceStreamRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<MarkPriceStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    markPriceStream(
        requestParameters: MarkPriceStreamRequest
    ): WebsocketStream<MarkPriceStreamResponse>;

    /**
     * Top **<levels\>** bids and asks, Valid **<levels\>** are 5, 10, or 20.
     *
     * Update Speed: 250ms, 500ms or 100ms
     *
     * @summary Partial Book Depth Streams
     * @param {PartialBookDepthStreamsRequest} requestParameters Request parameters.
     *
     * @returns {WebsocketStream<PartialBookDepthStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApiInterface
     */
    partialBookDepthStreams(
        requestParameters: PartialBookDepthStreamsRequest
    ): WebsocketStream<PartialBookDepthStreamsResponse>;
}

/**
 * Request parameters for aggregateTradeStreams operation in WebsocketMarketStreamsApi.
 * @interface AggregateTradeStreamsRequest
 */
export interface AggregateTradeStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiAggregateTradeStreams
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiAggregateTradeStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for allBookTickersStream operation in WebsocketMarketStreamsApi.
 * @interface AllBookTickersStreamRequest
 */
export interface AllBookTickersStreamRequest {
    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiAllBookTickersStream
     */
    readonly id?: string;
}

/**
 * Request parameters for allMarketLiquidationOrderStreams operation in WebsocketMarketStreamsApi.
 * @interface AllMarketLiquidationOrderStreamsRequest
 */
export interface AllMarketLiquidationOrderStreamsRequest {
    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiAllMarketLiquidationOrderStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for allMarketMiniTickersStream operation in WebsocketMarketStreamsApi.
 * @interface AllMarketMiniTickersStreamRequest
 */
export interface AllMarketMiniTickersStreamRequest {
    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiAllMarketMiniTickersStream
     */
    readonly id?: string;
}

/**
 * Request parameters for allMarketTickersStreams operation in WebsocketMarketStreamsApi.
 * @interface AllMarketTickersStreamsRequest
 */
export interface AllMarketTickersStreamsRequest {
    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiAllMarketTickersStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for continuousContractKlineCandlestickStreams operation in WebsocketMarketStreamsApi.
 * @interface ContinuousContractKlineCandlestickStreamsRequest
 */
export interface ContinuousContractKlineCandlestickStreamsRequest {
    /**
     * The pair parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiContinuousContractKlineCandlestickStreams
     */
    readonly pair: string;

    /**
     * The contractType parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiContinuousContractKlineCandlestickStreams
     */
    readonly contractType: string;

    /**
     * The interval parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiContinuousContractKlineCandlestickStreams
     */
    readonly interval: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiContinuousContractKlineCandlestickStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for contractInfoStream operation in WebsocketMarketStreamsApi.
 * @interface ContractInfoStreamRequest
 */
export interface ContractInfoStreamRequest {
    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiContractInfoStream
     */
    readonly id?: string;
}

/**
 * Request parameters for diffBookDepthStreams operation in WebsocketMarketStreamsApi.
 * @interface DiffBookDepthStreamsRequest
 */
export interface DiffBookDepthStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiDiffBookDepthStreams
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiDiffBookDepthStreams
     */
    readonly id?: string;

    /**
     * WebSocket stream update speed
     * @type {string}
     * @memberof WebsocketMarketStreamsApiDiffBookDepthStreams
     */
    readonly updateSpeed?: string;
}

/**
 * Request parameters for indexKlineCandlestickStreams operation in WebsocketMarketStreamsApi.
 * @interface IndexKlineCandlestickStreamsRequest
 */
export interface IndexKlineCandlestickStreamsRequest {
    /**
     * The pair parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndexKlineCandlestickStreams
     */
    readonly pair: string;

    /**
     * The interval parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndexKlineCandlestickStreams
     */
    readonly interval: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndexKlineCandlestickStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for indexPriceStream operation in WebsocketMarketStreamsApi.
 * @interface IndexPriceStreamRequest
 */
export interface IndexPriceStreamRequest {
    /**
     * The pair parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndexPriceStream
     */
    readonly pair: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndexPriceStream
     */
    readonly id?: string;

    /**
     * WebSocket stream update speed
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndexPriceStream
     */
    readonly updateSpeed?: string;
}

/**
 * Request parameters for individualSymbolBookTickerStreams operation in WebsocketMarketStreamsApi.
 * @interface IndividualSymbolBookTickerStreamsRequest
 */
export interface IndividualSymbolBookTickerStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndividualSymbolBookTickerStreams
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndividualSymbolBookTickerStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for individualSymbolMiniTickerStream operation in WebsocketMarketStreamsApi.
 * @interface IndividualSymbolMiniTickerStreamRequest
 */
export interface IndividualSymbolMiniTickerStreamRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndividualSymbolMiniTickerStream
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndividualSymbolMiniTickerStream
     */
    readonly id?: string;
}

/**
 * Request parameters for individualSymbolTickerStreams operation in WebsocketMarketStreamsApi.
 * @interface IndividualSymbolTickerStreamsRequest
 */
export interface IndividualSymbolTickerStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndividualSymbolTickerStreams
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiIndividualSymbolTickerStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for klineCandlestickStreams operation in WebsocketMarketStreamsApi.
 * @interface KlineCandlestickStreamsRequest
 */
export interface KlineCandlestickStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiKlineCandlestickStreams
     */
    readonly symbol: string;

    /**
     * The interval parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiKlineCandlestickStreams
     */
    readonly interval: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiKlineCandlestickStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for liquidationOrderStreams operation in WebsocketMarketStreamsApi.
 * @interface LiquidationOrderStreamsRequest
 */
export interface LiquidationOrderStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiLiquidationOrderStreams
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiLiquidationOrderStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for markPriceKlineCandlestickStreams operation in WebsocketMarketStreamsApi.
 * @interface MarkPriceKlineCandlestickStreamsRequest
 */
export interface MarkPriceKlineCandlestickStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceKlineCandlestickStreams
     */
    readonly symbol: string;

    /**
     * The interval parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceKlineCandlestickStreams
     */
    readonly interval: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceKlineCandlestickStreams
     */
    readonly id?: string;
}

/**
 * Request parameters for markPriceOfAllSymbolsOfAPair operation in WebsocketMarketStreamsApi.
 * @interface MarkPriceOfAllSymbolsOfAPairRequest
 */
export interface MarkPriceOfAllSymbolsOfAPairRequest {
    /**
     * The pair parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceOfAllSymbolsOfAPair
     */
    readonly pair: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceOfAllSymbolsOfAPair
     */
    readonly id?: string;

    /**
     * WebSocket stream update speed
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceOfAllSymbolsOfAPair
     */
    readonly updateSpeed?: string;
}

/**
 * Request parameters for markPriceStream operation in WebsocketMarketStreamsApi.
 * @interface MarkPriceStreamRequest
 */
export interface MarkPriceStreamRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceStream
     */
    readonly symbol: string;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceStream
     */
    readonly id?: string;

    /**
     * WebSocket stream update speed
     * @type {string}
     * @memberof WebsocketMarketStreamsApiMarkPriceStream
     */
    readonly updateSpeed?: string;
}

/**
 * Request parameters for partialBookDepthStreams operation in WebsocketMarketStreamsApi.
 * @interface PartialBookDepthStreamsRequest
 */
export interface PartialBookDepthStreamsRequest {
    /**
     * The symbol parameter
     * @type {string}
     * @memberof WebsocketMarketStreamsApiPartialBookDepthStreams
     */
    readonly symbol: string;

    /**
     * The levels parameter
     * @type {number | bigint}
     * @memberof WebsocketMarketStreamsApiPartialBookDepthStreams
     */
    readonly levels: number | bigint;

    /**
     * Unique WebSocket request ID.
     * @type {string}
     * @memberof WebsocketMarketStreamsApiPartialBookDepthStreams
     */
    readonly id?: string;

    /**
     * WebSocket stream update speed
     * @type {string}
     * @memberof WebsocketMarketStreamsApiPartialBookDepthStreams
     */
    readonly updateSpeed?: string;
}

/**
 * WebsocketMarketStreamsApi - interface
 * @class WebsocketMarketStreamsApi
 * @extends {WebsocketStreamsBase}
 */
export class WebsocketMarketStreamsApi implements WebsocketMarketStreamsApiInterface {
    private readonly websocketBase: WebsocketStreamsBase;
    private localVarParamCreator;

    constructor(websocketBase: WebsocketStreamsBase) {
        this.websocketBase = websocketBase;
        this.localVarParamCreator = WebsocketMarketStreamsApiParamCreator();
    }

    /**
     * The Aggregate Trade Streams push market trade information that is aggregated for fills with same price and taking side every 100 milliseconds.
     *
     * Update Speed: 100ms
     *
     * @summary Aggregate Trade Streams
     * @param {AggregateTradeStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<AggregateTradeStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Aggregate-Trade-Streams Binance API Documentation}
     */
    public aggregateTradeStreams(
        requestParameters: AggregateTradeStreamsRequest
    ): WebsocketStream<AggregateTradeStreamsResponse> {
        const stream = this.localVarParamCreator.aggregateTradeStreams(
            requestParameters?.symbol,
            requestParameters?.id
        );

        return createStreamHandler<AggregateTradeStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for all symbols.
     *
     * Update Speed: Real-time
     *
     * @summary All Book Tickers Stream
     * @param {AllBookTickersStreamRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<AllBookTickersStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Book-Tickers-Stream Binance API Documentation}
     */
    public allBookTickersStream(
        requestParameters: AllBookTickersStreamRequest = {}
    ): WebsocketStream<AllBookTickersStreamResponse> {
        const stream = this.localVarParamCreator.allBookTickersStream(requestParameters?.id);

        return createStreamHandler<AllBookTickersStreamResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * The All Liquidation Order Snapshot Streams push force liquidation order information for all symbols in the market.
     * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will be pushed.
     *
     * Update Speed: 1000ms
     *
     * @summary All Market Liquidation Order Streams
     * @param {AllMarketLiquidationOrderStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<AllMarketLiquidationOrderStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Liquidation-Order-Streams Binance API Documentation}
     */
    public allMarketLiquidationOrderStreams(
        requestParameters: AllMarketLiquidationOrderStreamsRequest = {}
    ): WebsocketStream<AllMarketLiquidationOrderStreamsResponse> {
        const stream = this.localVarParamCreator.allMarketLiquidationOrderStreams(
            requestParameters?.id
        );

        return createStreamHandler<AllMarketLiquidationOrderStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * 24hr rolling window mini-ticker statistics for all symbols. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers that have changed will be present in the array.
     *
     * Update Speed: 1000ms
     *
     * @summary All Market Mini Tickers Stream
     * @param {AllMarketMiniTickersStreamRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<AllMarketMiniTickersStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream Binance API Documentation}
     */
    public allMarketMiniTickersStream(
        requestParameters: AllMarketMiniTickersStreamRequest = {}
    ): WebsocketStream<AllMarketMiniTickersStreamResponse> {
        const stream = this.localVarParamCreator.allMarketMiniTickersStream(requestParameters?.id);

        return createStreamHandler<AllMarketMiniTickersStreamResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * 24hr rolling window ticker statistics for all symbols. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers that have changed will be present in the array.
     *
     * Update Speed: 1000ms
     *
     * @summary All Market Tickers Streams
     * @param {AllMarketTickersStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<AllMarketTickersStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/All-Market-Tickers-Streams Binance API Documentation}
     */
    public allMarketTickersStreams(
        requestParameters: AllMarketTickersStreamsRequest = {}
    ): WebsocketStream<AllMarketTickersStreamsResponse> {
        const stream = this.localVarParamCreator.allMarketTickersStreams(requestParameters?.id);

        return createStreamHandler<AllMarketTickersStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Kline update every second
     *
     * Update Speed: 250ms
     *
     * @summary Continuous Contract Kline/Candlestick Streams
     * @param {ContinuousContractKlineCandlestickStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<ContinuousContractKlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Continuous-Contract-Kline-Candlestick-Streams Binance API Documentation}
     */
    public continuousContractKlineCandlestickStreams(
        requestParameters: ContinuousContractKlineCandlestickStreamsRequest
    ): WebsocketStream<ContinuousContractKlineCandlestickStreamsResponse> {
        const stream = this.localVarParamCreator.continuousContractKlineCandlestickStreams(
            requestParameters?.pair,
            requestParameters?.contractType,
            requestParameters?.interval,
            requestParameters?.id
        );

        return createStreamHandler<ContinuousContractKlineCandlestickStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * ContractInfo stream pushes when contract info updates(listing/settlement/contract bracket update). `bks` field only shows up when bracket gets updated.
     *
     * Update Speed: Real-time
     *
     * @summary Contract Info Stream
     * @param {ContractInfoStreamRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<ContractInfoStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Contract-Info-Stream Binance API Documentation}
     */
    public contractInfoStream(
        requestParameters: ContractInfoStreamRequest = {}
    ): WebsocketStream<ContractInfoStreamResponse> {
        const stream = this.localVarParamCreator.contractInfoStream(requestParameters?.id);

        return createStreamHandler<ContractInfoStreamResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Bids and asks, pushed every 250 milliseconds, 500 milliseconds, or 100 milliseconds
     *
     * Update Speed: 250ms or 500ms or 100ms
     *
     * @summary Diff. Book Depth Streams
     * @param {DiffBookDepthStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<DiffBookDepthStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams Binance API Documentation}
     */
    public diffBookDepthStreams(
        requestParameters: DiffBookDepthStreamsRequest
    ): WebsocketStream<DiffBookDepthStreamsResponse> {
        const stream = this.localVarParamCreator.diffBookDepthStreams(
            requestParameters?.symbol,
            requestParameters?.id,
            requestParameters?.updateSpeed
        );

        return createStreamHandler<DiffBookDepthStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Index Kline/Candlestick Streams
     *
     * Update Speed: 250ms
     *
     * @summary Index Kline/Candlestick Streams
     * @param {IndexKlineCandlestickStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<IndexKlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Index-Kline-Candlestick-Streams Binance API Documentation}
     */
    public indexKlineCandlestickStreams(
        requestParameters: IndexKlineCandlestickStreamsRequest
    ): WebsocketStream<IndexKlineCandlestickStreamsResponse> {
        const stream = this.localVarParamCreator.indexKlineCandlestickStreams(
            requestParameters?.pair,
            requestParameters?.interval,
            requestParameters?.id
        );

        return createStreamHandler<IndexKlineCandlestickStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Index Price Stream
     *
     * Update Speed: 3000ms OR 1000ms
     *
     * @summary Index Price Stream
     * @param {IndexPriceStreamRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<IndexPriceStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Index-Price-Stream Binance API Documentation}
     */
    public indexPriceStream(
        requestParameters: IndexPriceStreamRequest
    ): WebsocketStream<IndexPriceStreamResponse> {
        const stream = this.localVarParamCreator.indexPriceStream(
            requestParameters?.pair,
            requestParameters?.id,
            requestParameters?.updateSpeed
        );

        return createStreamHandler<IndexPriceStreamResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
     *
     * Update Speed: Real-time
     *
     * @summary Individual Symbol Book Ticker Streams
     * @param {IndividualSymbolBookTickerStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<IndividualSymbolBookTickerStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Book-Ticker-Streams Binance API Documentation}
     */
    public individualSymbolBookTickerStreams(
        requestParameters: IndividualSymbolBookTickerStreamsRequest
    ): WebsocketStream<IndividualSymbolBookTickerStreamsResponse> {
        const stream = this.localVarParamCreator.individualSymbolBookTickerStreams(
            requestParameters?.symbol,
            requestParameters?.id
        );

        return createStreamHandler<IndividualSymbolBookTickerStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * 24hr rolling window mini-ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
     *
     * Update Speed: 500ms
     *
     * @summary Individual Symbol Mini Ticker Stream
     * @param {IndividualSymbolMiniTickerStreamRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<IndividualSymbolMiniTickerStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Mini-Ticker-Stream Binance API Documentation}
     */
    public individualSymbolMiniTickerStream(
        requestParameters: IndividualSymbolMiniTickerStreamRequest
    ): WebsocketStream<IndividualSymbolMiniTickerStreamResponse> {
        const stream = this.localVarParamCreator.individualSymbolMiniTickerStream(
            requestParameters?.symbol,
            requestParameters?.id
        );

        return createStreamHandler<IndividualSymbolMiniTickerStreamResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * 24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
     *
     * Update Speed: 500ms
     *
     * @summary Individual Symbol Ticker Streams
     * @param {IndividualSymbolTickerStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<IndividualSymbolTickerStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams Binance API Documentation}
     */
    public individualSymbolTickerStreams(
        requestParameters: IndividualSymbolTickerStreamsRequest
    ): WebsocketStream<IndividualSymbolTickerStreamsResponse> {
        const stream = this.localVarParamCreator.individualSymbolTickerStreams(
            requestParameters?.symbol,
            requestParameters?.id
        );

        return createStreamHandler<IndividualSymbolTickerStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * The Kline/Candlestick Stream push updates to the current klines/candlestick every 250 milliseconds (if existing).
     *
     * Update Speed: 250ms
     *
     * @summary Kline/Candlestick Streams
     * @param {KlineCandlestickStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<KlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Kline-Candlestick-Streams Binance API Documentation}
     */
    public klineCandlestickStreams(
        requestParameters: KlineCandlestickStreamsRequest
    ): WebsocketStream<KlineCandlestickStreamsResponse> {
        const stream = this.localVarParamCreator.klineCandlestickStreams(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.id
        );

        return createStreamHandler<KlineCandlestickStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * The Liquidation Order Snapshot Streams push force liquidation order information for specific symbol.
     *
     * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will be pushed.
     *
     * Update Speed: 1000ms
     *
     * @summary Liquidation Order Streams
     * @param {LiquidationOrderStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<LiquidationOrderStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Liquidation-Order-Streams Binance API Documentation}
     */
    public liquidationOrderStreams(
        requestParameters: LiquidationOrderStreamsRequest
    ): WebsocketStream<LiquidationOrderStreamsResponse> {
        const stream = this.localVarParamCreator.liquidationOrderStreams(
            requestParameters?.symbol,
            requestParameters?.id
        );

        return createStreamHandler<LiquidationOrderStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Mark Price Kline/Candlestick Streams
     *
     * Update Speed: 250ms
     *
     * @summary Mark Price Kline/Candlestick Streams
     * @param {MarkPriceKlineCandlestickStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<MarkPriceKlineCandlestickStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Mark-Price-Kline-Candlestick-Streams Binance API Documentation}
     */
    public markPriceKlineCandlestickStreams(
        requestParameters: MarkPriceKlineCandlestickStreamsRequest
    ): WebsocketStream<MarkPriceKlineCandlestickStreamsResponse> {
        const stream = this.localVarParamCreator.markPriceKlineCandlestickStreams(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.id
        );

        return createStreamHandler<MarkPriceKlineCandlestickStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Mark Price of All Symbols of a Pair
     *
     * Update Speed: 3000ms OR 1000ms
     *
     * @summary Mark Price of All Symbols of a Pair
     * @param {MarkPriceOfAllSymbolsOfAPairRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<MarkPriceOfAllSymbolsOfAPairResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Mark-Price-of-All-Symbols-of-a-Pair Binance API Documentation}
     */
    public markPriceOfAllSymbolsOfAPair(
        requestParameters: MarkPriceOfAllSymbolsOfAPairRequest
    ): WebsocketStream<MarkPriceOfAllSymbolsOfAPairResponse> {
        const stream = this.localVarParamCreator.markPriceOfAllSymbolsOfAPair(
            requestParameters?.pair,
            requestParameters?.id,
            requestParameters?.updateSpeed
        );

        return createStreamHandler<MarkPriceOfAllSymbolsOfAPairResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Mark price update stream
     *
     * Update Speed: 3000ms OR 1000ms
     *
     * @summary Mark Price Stream
     * @param {MarkPriceStreamRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<MarkPriceStreamResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Mark-Price-Stream Binance API Documentation}
     */
    public markPriceStream(
        requestParameters: MarkPriceStreamRequest
    ): WebsocketStream<MarkPriceStreamResponse> {
        const stream = this.localVarParamCreator.markPriceStream(
            requestParameters?.symbol,
            requestParameters?.id,
            requestParameters?.updateSpeed
        );

        return createStreamHandler<MarkPriceStreamResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }

    /**
     * Top **<levels\>** bids and asks, Valid **<levels\>** are 5, 10, or 20.
     *
     * Update Speed: 250ms, 500ms or 100ms
     *
     * @summary Partial Book Depth Streams
     * @param {PartialBookDepthStreamsRequest} requestParameters Request parameters.
     * @returns {WebsocketStream<PartialBookDepthStreamsResponse>}
     * @throws {RequiredError}
     * @memberof WebsocketMarketStreamsApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams Binance API Documentation}
     */
    public partialBookDepthStreams(
        requestParameters: PartialBookDepthStreamsRequest
    ): WebsocketStream<PartialBookDepthStreamsResponse> {
        const stream = this.localVarParamCreator.partialBookDepthStreams(
            requestParameters?.symbol,
            requestParameters?.levels,
            requestParameters?.id,
            requestParameters?.updateSpeed
        );

        return createStreamHandler<PartialBookDepthStreamsResponse>(
            this.websocketBase,
            stream,
            requestParameters?.id
        );
    }
}
