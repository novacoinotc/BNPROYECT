/**
 * Binance Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    ChangeMarginTypeMarginTypeEnum,
    ModifyIsolatedPositionMarginTypeEnum,
    ModifyIsolatedPositionMarginPositionSideEnum,
    ModifyOrderSideEnum,
    ModifyOrderPriceMatchEnum,
    NewOrderSideEnum,
    NewOrderTypeEnum,
    NewOrderPositionSideEnum,
    NewOrderTimeInForceEnum,
    NewOrderWorkingTypeEnum,
    NewOrderNewOrderRespTypeEnum,
    NewOrderPriceMatchEnum,
    NewOrderSelfTradePreventionModeEnum,
    UsersForceOrdersAutoCloseTypeEnum,
} from '../../../src/rest-api';
import {
    AccountTradeListRequest,
    AllOrdersRequest,
    AutoCancelAllOpenOrdersRequest,
    CancelAllOpenOrdersRequest,
    CancelMultipleOrdersRequest,
    CancelOrderRequest,
    ChangeInitialLeverageRequest,
    ChangeMarginTypeRequest,
    ChangePositionModeRequest,
    CurrentAllOpenOrdersRequest,
    GetOrderModifyHistoryRequest,
    GetPositionMarginChangeHistoryRequest,
    ModifyIsolatedPositionMarginRequest,
    ModifyMultipleOrdersRequest,
    ModifyOrderRequest,
    NewOrderRequest,
    PlaceMultipleOrdersRequest,
    PositionAdlQuantileEstimationRequest,
    PositionInformationRequest,
    QueryCurrentOpenOrderRequest,
    QueryOrderRequest,
    UsersForceOrdersRequest,
} from '../../../src/rest-api';
import type {
    AccountTradeListResponse,
    AllOrdersResponse,
    AutoCancelAllOpenOrdersResponse,
    CancelAllOpenOrdersResponse,
    CancelMultipleOrdersResponse,
    CancelOrderResponse,
    ChangeInitialLeverageResponse,
    ChangeMarginTypeResponse,
    ChangePositionModeResponse,
    CurrentAllOpenOrdersResponse,
    GetOrderModifyHistoryResponse,
    GetPositionMarginChangeHistoryResponse,
    ModifyIsolatedPositionMarginResponse,
    ModifyMultipleOrdersResponse,
    ModifyOrderResponse,
    NewOrderResponse,
    PlaceMultipleOrdersResponse,
    PositionAdlQuantileEstimationResponse,
    PositionInformationResponse,
    QueryCurrentOpenOrderResponse,
    QueryOrderResponse,
    UsersForceOrdersResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('accountTradeList()', () => {
        it('should execute accountTradeList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_200626',
                        id: 6,
                        orderId: 28,
                        pair: 'BTCUSD',
                        side: 'SELL',
                        price: '8800',
                        qty: '1',
                        realizedPnl: '0',
                        marginAsset: 'BTC',
                        baseQty: '0.01136364',
                        commission: '0.00000454',
                        commissionAsset: 'BTC',
                        time: 1590743483586,
                        positionSide: 'BOTH',
                        buyer: false,
                        maker: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountTradeList() successfully with optional parameters', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
                orderId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_200626',
                        id: 6,
                        orderId: 28,
                        pair: 'BTCUSD',
                        side: 'SELL',
                        price: '8800',
                        qty: '1',
                        realizedPnl: '0',
                        marginAsset: 'BTC',
                        baseQty: '0.01136364',
                        commission: '0.00000454',
                        commissionAsset: 'BTC',
                        time: 1590743483586,
                        positionSide: 'BOTH',
                        buyer: false,
                        maker: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountTradeList').mockRejectedValueOnce(mockError);
            await expect(client.accountTradeList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrders()', () => {
        it('should execute allOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.0',
                        clientOrderId: 'abc',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrders() successfully with optional parameters', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.0',
                        clientOrderId: 'abc',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrders').mockRejectedValueOnce(mockError);
            await expect(client.allOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('autoCancelAllOpenOrders()', () => {
        it('should execute autoCancelAllOpenOrders() successfully with required parameters only', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSD_200925', countdownTime: '100000' })
            );

            const spy = jest.spyOn(client, 'autoCancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AutoCancelAllOpenOrdersResponse>)
            );
            const response = await client.autoCancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute autoCancelAllOpenOrders() successfully with optional parameters', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSD_200925', countdownTime: '100000' })
            );

            const spy = jest.spyOn(client, 'autoCancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AutoCancelAllOpenOrdersResponse>)
            );
            const response = await client.autoCancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling autoCancelAllOpenOrders.'
            );
        });

        it('should throw RequiredError when countdownTime is missing', async () => {
            const _params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.countdownTime;

            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter countdownTime was null or undefined when calling autoCancelAllOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'autoCancelAllOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAllOpenOrders()', () => {
        it('should execute cancelAllOpenOrders() successfully with required parameters only', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ code: 200, msg: 'The operation of cancel all open order is done.' })
            );

            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOpenOrdersResponse>)
            );
            const response = await client.cancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllOpenOrders() successfully with optional parameters', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ code: 200, msg: 'The operation of cancel all open order is done.' })
            );

            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOpenOrdersResponse>)
            );
            const response = await client.cancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.cancelAllOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelMultipleOrders()', () => {
        it('should execute cancelMultipleOrders() successfully with required parameters only', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.0',
                        clientOrderId: 'myOrder1',
                        cumQty: '0',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 283194212,
                        origQty: '11',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'CANCELED',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSD_200925',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        updateTime: 1571110484038,
                    },
                    { code: -2011, msg: 'Unknown order sent.' },
                ])
            );

            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOrdersResponse>)
            );
            const response = await client.cancelMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMultipleOrders() successfully with optional parameters', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
                orderIdList: [1234567],
                origClientOrderIdList: ['my_id_1'],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.0',
                        clientOrderId: 'myOrder1',
                        cumQty: '0',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 283194212,
                        origQty: '11',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'CANCELED',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSD_200925',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        updateTime: 1571110484038,
                    },
                    { code: -2011, msg: 'Unknown order sent.' },
                ])
            );

            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOrdersResponse>)
            );
            const response = await client.cancelMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMultipleOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.cancelMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelOrder()', () => {
        it('should execute cancelOrder() successfully with required parameters only', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.0',
                    clientOrderId: 'myOrder1',
                    cumQty: '0',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 283194212,
                    origQty: '11',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'CANCELED',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1571110484038,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'cancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOrderResponse>)
            );
            const response = await client.cancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelOrder() successfully with optional parameters', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.0',
                    clientOrderId: 'myOrder1',
                    cumQty: '0',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 283194212,
                    origQty: '11',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'CANCELED',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1571110484038,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'cancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOrderResponse>)
            );
            const response = await client.cancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeInitialLeverage()', () => {
        it('should execute changeInitialLeverage() successfully with required parameters only', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxQty: '1000', symbol: 'BTCUSD_200925' })
            );

            const spy = jest.spyOn(client, 'changeInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeInitialLeverageResponse>)
            );
            const response = await client.changeInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeInitialLeverage() successfully with optional parameters', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxQty: '1000', symbol: 'BTCUSD_200925' })
            );

            const spy = jest.spyOn(client, 'changeInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeInitialLeverageResponse>)
            );
            const response = await client.changeInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeInitialLeverage(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeInitialLeverage.'
            );
        });

        it('should throw RequiredError when leverage is missing', async () => {
            const _params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.leverage;

            await expect(client.changeInitialLeverage(params)).rejects.toThrow(
                'Required parameter leverage was null or undefined when calling changeInitialLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeInitialLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeInitialLeverage(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeMarginType()', () => {
        it('should execute changeMarginType() successfully with required parameters only', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeMarginType').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMarginTypeResponse>)
            );
            const response = await client.changeMarginType(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeMarginType() successfully with optional parameters', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeMarginType').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMarginTypeResponse>)
            );
            const response = await client.changeMarginType(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeMarginType(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeMarginType.'
            );
        });

        it('should throw RequiredError when marginType is missing', async () => {
            const _params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };
            const params = Object.assign({ ..._params });
            delete params?.marginType;

            await expect(client.changeMarginType(params)).rejects.toThrow(
                'Required parameter marginType was null or undefined when calling changeMarginType.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changeMarginType').mockRejectedValueOnce(mockError);
            await expect(client.changeMarginType(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changePositionMode()', () => {
        it('should execute changePositionMode() successfully with required parameters only', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changePositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePositionModeResponse>)
            );
            const response = await client.changePositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changePositionMode() successfully with optional parameters', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changePositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePositionModeResponse>)
            );
            const response = await client.changePositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when dualSidePosition is missing', async () => {
            const _params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.dualSidePosition;

            await expect(client.changePositionMode(params)).rejects.toThrow(
                'Required parameter dualSidePosition was null or undefined when calling changePositionMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changePositionMode').mockRejectedValueOnce(mockError);
            await expect(client.changePositionMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('currentAllOpenOrders()', () => {
        it('should execute currentAllOpenOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.0',
                        clientOrderId: 'abc',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSD_200925',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllOpenOrdersResponse>)
            );
            const response = await client.currentAllOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute currentAllOpenOrders() successfully with optional parameters', async () => {
            const params: CurrentAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.0',
                        clientOrderId: 'abc',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSD_200925',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllOpenOrdersResponse>)
            );
            const response = await client.currentAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.currentAllOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderModifyHistory()', () => {
        it('should execute getOrderModifyHistory() successfully with required parameters only', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        amendmentId: 5363,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184560899,
                        amendment: {
                            price: { before: '30004', after: '30003.2' },
                            origQty: { before: '1', after: '1' },
                            count: 3,
                        },
                    },
                    {
                        amendmentId: 5361,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184533946,
                        amendment: {
                            price: { before: '30005', after: '30004' },
                            origQty: { before: '1', after: '1' },
                            count: 2,
                        },
                    },
                    {
                        amendmentId: 5325,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629182711787,
                        amendment: {
                            price: { before: '30002', after: '30005' },
                            origQty: { before: '1', after: '1' },
                            count: 1,
                        },
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getOrderModifyHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderModifyHistoryResponse>)
            );
            const response = await client.getOrderModifyHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderModifyHistory() successfully with optional parameters', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        amendmentId: 5363,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184560899,
                        amendment: {
                            price: { before: '30004', after: '30003.2' },
                            origQty: { before: '1', after: '1' },
                            count: 3,
                        },
                    },
                    {
                        amendmentId: 5361,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184533946,
                        amendment: {
                            price: { before: '30005', after: '30004' },
                            origQty: { before: '1', after: '1' },
                            count: 2,
                        },
                    },
                    {
                        amendmentId: 5325,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629182711787,
                        amendment: {
                            price: { before: '30002', after: '30005' },
                            origQty: { before: '1', after: '1' },
                            count: 1,
                        },
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getOrderModifyHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderModifyHistoryResponse>)
            );
            const response = await client.getOrderModifyHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getOrderModifyHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getOrderModifyHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOrderModifyHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOrderModifyHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getPositionMarginChangeHistory()', () => {
        it('should execute getPositionMarginChangeHistory() successfully with required parameters only', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        amount: '23.36332311',
                        asset: 'BTC',
                        symbol: 'BTCUSD_200925',
                        time: 1578047897183,
                        type: 1,
                        positionSide: 'BOTH',
                    },
                    {
                        amount: '100',
                        asset: 'BTC',
                        symbol: 'BTCUSD_200925',
                        time: 1578047900425,
                        type: 1,
                        positionSide: 'LONG',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getPositionMarginChangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPositionMarginChangeHistoryResponse>)
            );
            const response = await client.getPositionMarginChangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPositionMarginChangeHistory() successfully with optional parameters', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
                type: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        amount: '23.36332311',
                        asset: 'BTC',
                        symbol: 'BTCUSD_200925',
                        time: 1578047897183,
                        type: 1,
                        positionSide: 'BOTH',
                    },
                    {
                        amount: '100',
                        asset: 'BTC',
                        symbol: 'BTCUSD_200925',
                        time: 1578047900425,
                        type: 1,
                        positionSide: 'LONG',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getPositionMarginChangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPositionMarginChangeHistoryResponse>)
            );
            const response = await client.getPositionMarginChangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getPositionMarginChangeHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getPositionMarginChangeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPositionMarginChangeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPositionMarginChangeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('modifyIsolatedPositionMargin()', () => {
        it('should execute modifyIsolatedPositionMargin() successfully with required parameters only', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: ModifyIsolatedPositionMarginTypeEnum.LIMIT,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    amount: 100,
                    code: 200,
                    msg: 'Successfully modify position margin.',
                    type: 1,
                })
            );

            const spy = jest.spyOn(client, 'modifyIsolatedPositionMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyIsolatedPositionMarginResponse>)
            );
            const response = await client.modifyIsolatedPositionMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyIsolatedPositionMargin() successfully with optional parameters', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: ModifyIsolatedPositionMarginTypeEnum.LIMIT,
                positionSide: ModifyIsolatedPositionMarginPositionSideEnum.BOTH,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    amount: 100,
                    code: 200,
                    msg: 'Successfully modify position margin.',
                    type: 1,
                })
            );

            const spy = jest.spyOn(client, 'modifyIsolatedPositionMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyIsolatedPositionMarginResponse>)
            );
            const response = await client.modifyIsolatedPositionMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: ModifyIsolatedPositionMarginTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: ModifyIsolatedPositionMarginTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: ModifyIsolatedPositionMarginTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: ModifyIsolatedPositionMarginTypeEnum.LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'modifyIsolatedPositionMargin')
                .mockRejectedValueOnce(mockError);
            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('modifyMultipleOrders()', () => {
        it('should execute modifyMultipleOrders() successfully with required parameters only', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 20072994037,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        status: 'NEW',
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        price: '30005',
                        avgPrice: '0.0',
                        origQty: '1',
                        executedQty: '0',
                        cumQty: '0',
                        cumBase: '0',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'LONG',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        updateTime: 1629182711600,
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyMultipleOrdersResponse>)
            );
            const response = await client.modifyMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyMultipleOrders() successfully with optional parameters', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 20072994037,
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        status: 'NEW',
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        price: '30005',
                        avgPrice: '0.0',
                        origQty: '1',
                        executedQty: '0',
                        cumQty: '0',
                        cumBase: '0',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'LONG',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        updateTime: 1629182711600,
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyMultipleOrdersResponse>)
            );
            const response = await client.modifyMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when batchOrders is missing', async () => {
            const _params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.batchOrders;

            await expect(client.modifyMultipleOrders(params)).rejects.toThrow(
                'Required parameter batchOrders was null or undefined when calling modifyMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.modifyMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('modifyOrder()', () => {
        it('should execute modifyOrder() successfully with required parameters only', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 20072994037,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    status: 'NEW',
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    price: '30005',
                    avgPrice: '0.0',
                    origQty: '1',
                    executedQty: '0',
                    cumQty: '0',
                    cumBase: '0',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'LONG',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    origType: 'LIMIT',
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1629182711600,
                })
            );

            const spy = jest.spyOn(client, 'modifyOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyOrderResponse>)
            );
            const response = await client.modifyOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyOrder() successfully with optional parameters', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                orderId: 1,
                origClientOrderId: '1',
                quantity: 1.0,
                price: 1.0,
                priceMatch: ModifyOrderPriceMatchEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 20072994037,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    status: 'NEW',
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    price: '30005',
                    avgPrice: '0.0',
                    origQty: '1',
                    executedQty: '0',
                    cumQty: '0',
                    cumBase: '0',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'LONG',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    origType: 'LIMIT',
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1629182711600,
                })
            );

            const spy = jest.spyOn(client, 'modifyOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyOrderResponse>)
            );
            const response = await client.modifyOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyOrder').mockRejectedValueOnce(mockError);
            await expect(client.modifyOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.0',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                positionSide: NewOrderPositionSideEnum.BOTH,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                reduceOnly: 'false',
                price: 1.0,
                newClientOrderId: '1',
                stopPrice: 1.0,
                closePosition: 'closePosition_example',
                activationPrice: 1.0,
                callbackRate: 1.0,
                workingType: NewOrderWorkingTypeEnum.MARK_PRICE,
                priceProtect: 'false',
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                priceMatch: NewOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: NewOrderSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.0',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('placeMultipleOrders()', () => {
        it('should execute placeMultipleOrders() successfully with required parameters only', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        clientOrderId: 'testOrder',
                        cumQty: '0',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 22542179,
                        avgPrice: '0.0',
                        origQty: '10',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        origType: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1566818724722,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute placeMultipleOrders() successfully with optional parameters', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        clientOrderId: 'testOrder',
                        cumQty: '0',
                        cumBase: '0',
                        executedQty: '0',
                        orderId: 22542179,
                        avgPrice: '0.0',
                        origQty: '10',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        origType: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1566818724722,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when batchOrders is missing', async () => {
            const _params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.batchOrders;

            await expect(client.placeMultipleOrders(params)).rejects.toThrow(
                'Required parameter batchOrders was null or undefined when calling placeMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'placeMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.placeMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionAdlQuantileEstimation()', () => {
        it('should execute positionAdlQuantileEstimation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'BTCUSD_200925', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                    { symbol: 'BTCUSD_201225', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
                ])
            );

            const spy = jest.spyOn(client, 'positionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionAdlQuantileEstimationResponse>)
            );
            const response = await client.positionAdlQuantileEstimation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionAdlQuantileEstimation() successfully with optional parameters', async () => {
            const params: PositionAdlQuantileEstimationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'BTCUSD_200925', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                    { symbol: 'BTCUSD_201225', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
                ])
            );

            const spy = jest.spyOn(client, 'positionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionAdlQuantileEstimationResponse>)
            );
            const response = await client.positionAdlQuantileEstimation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionAdlQuantileEstimation')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionAdlQuantileEstimation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionInformation()', () => {
        it('should execute positionInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        markPrice: '0.00000000',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '0',
                        leverage: '125',
                        maxQty: '50',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'BOTH',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        breakEvenPrice: '11707.80000005',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '11667.63509587',
                        leverage: '125',
                        maxQty: '50',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        markPrice: '0.00000000',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '0',
                        leverage: '125',
                        maxQty: '50',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'SHORT',
                        updateTime: 1627026881327,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'positionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationResponse>)
            );
            const response = await client.positionInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionInformation() successfully with optional parameters', async () => {
            const params: PositionInformationRequest = {
                marginAsset: 'marginAsset_example',
                pair: 'pair_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        markPrice: '0.00000000',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '0',
                        leverage: '125',
                        maxQty: '50',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'BOTH',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        breakEvenPrice: '11707.80000005',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '11667.63509587',
                        leverage: '125',
                        maxQty: '50',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        markPrice: '0.00000000',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '0',
                        leverage: '125',
                        maxQty: '50',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'SHORT',
                        updateTime: 1627026881327,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'positionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationResponse>)
            );
            const response = await client.positionInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'positionInformation').mockRejectedValueOnce(mockError);
            await expect(client.positionInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentOpenOrder()', () => {
        it('should execute queryCurrentOpenOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'queryCurrentOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOrderResponse>)
            );
            const response = await client.queryCurrentOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentOpenOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'queryCurrentOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOrderResponse>)
            );
            const response = await client.queryCurrentOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentOpenOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentOpenOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentOpenOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentOpenOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryOrder()', () => {
        it('should execute queryOrder() successfully with required parameters only', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'queryOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOrderResponse>)
            );
            const response = await client.queryOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryOrder() successfully with optional parameters', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                })
            );

            const spy = jest.spyOn(client, 'queryOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOrderResponse>)
            );
            const response = await client.queryOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryOrder').mockRejectedValueOnce(mockError);
            await expect(client.queryOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('usersForceOrders()', () => {
        it('should execute usersForceOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 165123080,
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        status: 'FILLED',
                        clientOrderId: 'autoclose-1596542005017000006',
                        price: '11326.9',
                        avgPrice: '11326.9',
                        origQty: '1',
                        executedQty: '1',
                        cumBase: '0.00882854',
                        timeInForce: 'IOC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'BOTH',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        time: 1596542005019,
                        updateTime: 1596542005050,
                    },
                    {
                        orderId: 207251986,
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        status: 'FILLED',
                        clientOrderId: 'autoclose-1597307316020000006',
                        price: '11619.4',
                        avgPrice: '11661.2',
                        origQty: '1',
                        executedQty: '1',
                        cumBase: '0.00857544',
                        timeInForce: 'IOC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'LONG',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        time: 1597307316022,
                        updateTime: 1597307316035,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'usersForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UsersForceOrdersResponse>)
            );
            const response = await client.usersForceOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute usersForceOrders() successfully with optional parameters', async () => {
            const params: UsersForceOrdersRequest = {
                symbol: 'symbol_example',
                autoCloseType: UsersForceOrdersAutoCloseTypeEnum.LIQUIDATION,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 165123080,
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        status: 'FILLED',
                        clientOrderId: 'autoclose-1596542005017000006',
                        price: '11326.9',
                        avgPrice: '11326.9',
                        origQty: '1',
                        executedQty: '1',
                        cumBase: '0.00882854',
                        timeInForce: 'IOC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'BOTH',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        time: 1596542005019,
                        updateTime: 1596542005050,
                    },
                    {
                        orderId: 207251986,
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        status: 'FILLED',
                        clientOrderId: 'autoclose-1597307316020000006',
                        price: '11619.4',
                        avgPrice: '11661.2',
                        origQty: '1',
                        executedQty: '1',
                        cumBase: '0.00857544',
                        timeInForce: 'IOC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'LONG',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        time: 1597307316022,
                        updateTime: 1597307316035,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'usersForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UsersForceOrdersResponse>)
            );
            const response = await client.usersForceOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'usersForceOrders').mockRejectedValueOnce(mockError);
            await expect(client.usersForceOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
