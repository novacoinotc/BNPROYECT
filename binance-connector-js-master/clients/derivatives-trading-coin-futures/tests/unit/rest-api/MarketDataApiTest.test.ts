/**
 * Binance Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    MarketDataApi,
    BasisContractTypeEnum,
    BasisPeriodEnum,
    ContinuousContractKlineCandlestickDataContractTypeEnum,
    ContinuousContractKlineCandlestickDataIntervalEnum,
    IndexPriceKlineCandlestickDataIntervalEnum,
    KlineCandlestickDataIntervalEnum,
    LongShortRatioPeriodEnum,
    MarkPriceKlineCandlestickDataIntervalEnum,
    OpenInterestStatisticsContractTypeEnum,
    OpenInterestStatisticsPeriodEnum,
    PremiumIndexKlineDataIntervalEnum,
    TakerBuySellVolumeContractTypeEnum,
    TakerBuySellVolumePeriodEnum,
    TopTraderLongShortRatioAccountsPeriodEnum,
    TopTraderLongShortRatioPositionsPeriodEnum,
} from '../../../src/rest-api';
import {
    BasisRequest,
    CompressedAggregateTradesListRequest,
    ContinuousContractKlineCandlestickDataRequest,
    GetFundingRateHistoryOfPerpetualFuturesRequest,
    IndexPriceAndMarkPriceRequest,
    IndexPriceKlineCandlestickDataRequest,
    KlineCandlestickDataRequest,
    LongShortRatioRequest,
    MarkPriceKlineCandlestickDataRequest,
    OldTradesLookupRequest,
    OpenInterestRequest,
    OpenInterestStatisticsRequest,
    OrderBookRequest,
    PremiumIndexKlineDataRequest,
    QueryIndexPriceConstituentsRequest,
    RecentTradesListRequest,
    SymbolOrderBookTickerRequest,
    SymbolPriceTickerRequest,
    TakerBuySellVolumeRequest,
    Ticker24hrPriceChangeStatisticsRequest,
    TopTraderLongShortRatioAccountsRequest,
    TopTraderLongShortRatioPositionsRequest,
} from '../../../src/rest-api';
import type {
    BasisResponse,
    CheckServerTimeResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryOfPerpetualFuturesResponse,
    GetFundingRateInfoResponse,
    IndexPriceAndMarkPriceResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QueryIndexPriceConstituentsResponse,
    RecentTradesListResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('basis()', () => {
        it('should execute basis() successfully with required parameters only', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        indexPrice: '29269.93972727',
                        contractType: 'CURRENT_QUARTER',
                        basisRate: '0.0024',
                        futuresPrice: '29341.3',
                        annualizedBasisRate: '0.0283',
                        basis: '71.36027273',
                        pair: 'BTCUSD',
                        timestamp: 1653381600000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute basis() successfully with optional parameters', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        indexPrice: '29269.93972727',
                        contractType: 'CURRENT_QUARTER',
                        basisRate: '0.0024',
                        futuresPrice: '29341.3',
                        annualizedBasisRate: '0.0283',
                        basis: '71.36027273',
                        pair: 'BTCUSD',
                        timestamp: 1653381600000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling basis.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'basis').mockRejectedValueOnce(mockError);
            await expect(client.basis(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('checkServerTime()', () => {
        it('should execute checkServerTime() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ serverTime: 1499827319559 }));

            const spy = jest.spyOn(client, 'checkServerTime').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckServerTimeResponse>)
            );
            const response = await client.checkServerTime();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'checkServerTime').mockRejectedValueOnce(mockError);
            await expect(client.checkServerTime()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('compressedAggregateTradesList()', () => {
        it('should execute compressedAggregateTradesList() successfully with required parameters only', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        a: 416690,
                        p: '9642.4',
                        q: '3',
                        f: 595259,
                        l: 595259,
                        T: 1591250548649,
                        m: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute compressedAggregateTradesList() successfully with optional parameters', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        a: 416690,
                        p: '9642.4',
                        q: '3',
                        f: 595259,
                        l: 595259,
                        T: 1591250548649,
                        m: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling compressedAggregateTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'compressedAggregateTradesList')
                .mockRejectedValueOnce(mockError);
            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('continuousContractKlineCandlestickData()', () => {
        it('should execute continuousContractKlineCandlestickData() successfully with required parameters only', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591258320000,
                        '9640.7',
                        '9642.4',
                        '9640.6',
                        '9642.0',
                        '206',
                        1591258379999,
                        '2.13660389',
                        48,
                        '119',
                        '1.23424865',
                        '0',
                    ],
                ])
            );

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute continuousContractKlineCandlestickData() successfully with optional parameters', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591258320000,
                        '9640.7',
                        '9642.4',
                        '9640.6',
                        '9642.0',
                        '206',
                        1591258379999,
                        '2.13660389',
                        48,
                        '119',
                        '1.23424865',
                        '0',
                    ],
                ])
            );

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('exchangeInformation()', () => {
        it('should execute exchangeInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    exchangeFilters: [],
                    rateLimits: [
                        {
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            rateLimitType: 'REQUEST_WEIGHT',
                        },
                        {
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 6000,
                            rateLimitType: 'ORDERS',
                        },
                    ],
                    serverTime: 1565613908500,
                    symbols: [
                        {
                            filters: [
                                {
                                    filterType: 'PRICE_FILTER',
                                    maxPrice: '100000',
                                    minPrice: '0.1',
                                    tickSize: '0.1',
                                },
                                {
                                    filterType: 'LOT_SIZE',
                                    maxQty: '100000',
                                    minQty: '1',
                                    stepSize: '1',
                                },
                                {
                                    filterType: 'MARKET_LOT_SIZE',
                                    maxQty: '100000',
                                    minQty: '1',
                                    stepSize: '1',
                                },
                                { filterType: 'MAX_NUM_ORDERS', limit: 200 },
                                {
                                    filterType: 'PERCENT_PRICE',
                                    multiplierUp: '1.0500',
                                    multiplierDown: '0.9500',
                                    multiplierDecimal: '4',
                                },
                            ],
                            OrderType: [
                                'LIMIT',
                                'MARKET',
                                'STOP',
                                'TAKE_PROFIT',
                                'TRAILING_STOP_MARKET',
                            ],
                            timeInForce: ['GTC', 'IOC', 'FOK', 'GTX'],
                            liquidationFee: '0.010000',
                            marketTakeBound: '0.30',
                            symbol: 'BTCUSD_200925',
                            pair: 'BTCUSD',
                            contractType: 'CURRENT_QUARTER',
                            deliveryDate: 1601020800000,
                            onboardDate: 1590739200000,
                            contractStatus: 'TRADING',
                            contractSize: 100,
                            quoteAsset: 'USD',
                            baseAsset: 'BTC',
                            marginAsset: 'BTC',
                            pricePrecision: 1,
                            quantityPrecision: 0,
                            baseAssetPrecision: 8,
                            quotePrecision: 8,
                            equalQtyPrecision: 4,
                            triggerProtect: '0.0500',
                            maintMarginPercent: '2.5000',
                            requiredMarginPercent: '5.0000',
                            underlyingType: 'COIN',
                            underlyingSubType: [],
                        },
                    ],
                    timezone: 'UTC',
                })
            );

            const spy = jest.spyOn(client, 'exchangeInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInformationResponse>)
            );
            const response = await client.exchangeInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInformation').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFundingRateHistoryOfPerpetualFutures()', () => {
        it('should execute getFundingRateHistoryOfPerpetualFutures() successfully with required parameters only', async () => {
            const params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        fundingTime: 1596038400000,
                        fundingRate: '-0.00300000',
                    },
                    {
                        symbol: 'BTCUSD_PERP',
                        fundingTime: 1596067200000,
                        fundingRate: '-0.00300000',
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'getFundingRateHistoryOfPerpetualFutures')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>)
                );
            const response = await client.getFundingRateHistoryOfPerpetualFutures(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFundingRateHistoryOfPerpetualFutures() successfully with optional parameters', async () => {
            const params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        fundingTime: 1596038400000,
                        fundingRate: '-0.00300000',
                    },
                    {
                        symbol: 'BTCUSD_PERP',
                        fundingTime: 1596067200000,
                        fundingRate: '-0.00300000',
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'getFundingRateHistoryOfPerpetualFutures')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>)
                );
            const response = await client.getFundingRateHistoryOfPerpetualFutures(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getFundingRateHistoryOfPerpetualFutures(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getFundingRateHistoryOfPerpetualFutures.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFundingRateHistoryOfPerpetualFutures')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateHistoryOfPerpetualFutures(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFundingRateInfo()', () => {
        it('should execute getFundingRateInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        adjustedFundingRateCap: '0.02500000',
                        adjustedFundingRateFloor: '-0.02500000',
                        fundingIntervalHours: 8,
                        disclaimer: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getFundingRateInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateInfoResponse>)
            );
            const response = await client.getFundingRateInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getFundingRateInfo').mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexPriceAndMarkPrice()', () => {
        it('should execute indexPriceAndMarkPrice() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        markPrice: '11029.69574559',
                        indexPrice: '10979.14437500',
                        estimatedSettlePrice: '10981.74168236',
                        lastFundingRate: '0.00071003',
                        interestRate: '0.00010000',
                        nextFundingTime: 1596096000000,
                        time: 1596094042000,
                    },
                    {
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        markPrice: '12077.01343750',
                        indexPrice: '10979.10312500',
                        estimatedSettlePrice: '10981.74168236',
                        lastFundingRate: '',
                        interestRate: '',
                        nextFundingTime: 0,
                        time: 1596094042000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'indexPriceAndMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceAndMarkPriceResponse>)
            );
            const response = await client.indexPriceAndMarkPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPriceAndMarkPrice() successfully with optional parameters', async () => {
            const params: IndexPriceAndMarkPriceRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        pair: 'BTCUSD',
                        markPrice: '11029.69574559',
                        indexPrice: '10979.14437500',
                        estimatedSettlePrice: '10981.74168236',
                        lastFundingRate: '0.00071003',
                        interestRate: '0.00010000',
                        nextFundingTime: 1596096000000,
                        time: 1596094042000,
                    },
                    {
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        markPrice: '12077.01343750',
                        indexPrice: '10979.10312500',
                        estimatedSettlePrice: '10981.74168236',
                        lastFundingRate: '',
                        interestRate: '',
                        nextFundingTime: 0,
                        time: 1596094042000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'indexPriceAndMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceAndMarkPriceResponse>)
            );
            const response = await client.indexPriceAndMarkPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexPriceAndMarkPrice')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexPriceAndMarkPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexPriceKlineCandlestickData()', () => {
        it('should execute indexPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256400000,
                        '9653.69440000',
                        '9653.69640000',
                        '9651.38600000',
                        '9651.55200000',
                        '0',
                        1591256459999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256400000,
                        '9653.69440000',
                        '9653.69640000',
                        '9651.38600000',
                        '9651.55200000',
                        '0',
                        1591256459999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('klineCandlestickData()', () => {
        it('should execute klineCandlestickData() successfully with required parameters only', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591258320000,
                        '9640.7',
                        '9642.4',
                        '9640.6',
                        '9642.0',
                        '206',
                        1591258379999,
                        '2.13660389',
                        48,
                        '119',
                        '1.23424865',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klineCandlestickData() successfully with optional parameters', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591258320000,
                        '9640.7',
                        '9642.4',
                        '9640.6',
                        '9642.0',
                        '206',
                        1591258379999,
                        '2.13660389',
                        48,
                        '119',
                        '1.23424865',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klineCandlestickData').mockRejectedValueOnce(mockError);
            await expect(client.klineCandlestickData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('longShortRatio()', () => {
        it('should execute longShortRatio() successfully with required parameters only', async () => {
            const params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '0.1960',
                        longAccount: '0.6622',
                        shortAccount: '0.3378',
                        timestamp: 1583139600000,
                    },
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.9559',
                        longAccount: '0.6617',
                        shortAccount: '0.3382',
                        timestamp: 1583139900000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute longShortRatio() successfully with optional parameters', async () => {
            const params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '0.1960',
                        longAccount: '0.6622',
                        shortAccount: '0.3378',
                        timestamp: 1583139600000,
                    },
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.9559',
                        longAccount: '0.6617',
                        shortAccount: '0.3382',
                        timestamp: 1583139900000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'longShortRatio').mockRejectedValueOnce(mockError);
            await expect(client.longShortRatio(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('markPriceKlineCandlestickData()', () => {
        it('should execute markPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256460000,
                        '9653.29201333',
                        '9654.56401333',
                        '9653.07367333',
                        '9653.07367333',
                        '0',
                        1591256519999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute markPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256460000,
                        '9653.29201333',
                        '9654.56401333',
                        '9653.07367333',
                        '9653.07367333',
                        '0',
                        1591256519999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'markPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('oldTradesLookup()', () => {
        it('should execute oldTradesLookup() successfully with required parameters only', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 595103,
                        price: '9642.2',
                        qty: '1',
                        baseQty: '0.01037108',
                        time: 1499865549590,
                        isBuyerMaker: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oldTradesLookup() successfully with optional parameters', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
                limit: 100,
                fromId: 1,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 595103,
                        price: '9642.2',
                        qty: '1',
                        baseQty: '0.01037108',
                        time: 1499865549590,
                        isBuyerMaker: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.oldTradesLookup(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling oldTradesLookup.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'oldTradesLookup').mockRejectedValueOnce(mockError);
            await expect(client.oldTradesLookup(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterest()', () => {
        it('should execute openInterest() successfully with required parameters only', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSD_200626',
                    pair: 'BTCUSD',
                    openInterest: '15004',
                    contractType: 'CURRENT_QUARTER',
                    time: 1591261042378,
                })
            );

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterest() successfully with optional parameters', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSD_200626',
                    pair: 'BTCUSD',
                    openInterest: '15004',
                    contractType: 'CURRENT_QUARTER',
                    time: 1591261042378,
                })
            );

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling openInterest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openInterest').mockRejectedValueOnce(mockError);
            await expect(client.openInterest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterestStatistics()', () => {
        it('should execute openInterestStatistics() successfully with required parameters only', async () => {
            const params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        sumOpenInterest: '20403',
                        sumOpenInterestValue: '176196512.23400000',
                        timestamp: 1591261042378,
                    },
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        sumOpenInterest: '20401',
                        sumOpenInterestValue: '176178704.98700000',
                        timestamp: 1583128200000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterestStatistics() successfully with optional parameters', async () => {
            const params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        sumOpenInterest: '20403',
                        sumOpenInterestValue: '176196512.23400000',
                        timestamp: 1591261042378,
                    },
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        sumOpenInterest: '20401',
                        sumOpenInterestValue: '176178704.98700000',
                        timestamp: 1583128200000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'openInterestStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.openInterestStatistics(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderBook()', () => {
        it('should execute orderBook() successfully with required parameters only', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 16769853,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    E: 1591250106370,
                    T: 1591250106368,
                    bids: [['9638.0', '431']],
                    asks: [['9638.2', '12']],
                })
            );

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderBook() successfully with optional parameters', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 16769853,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    E: 1591250106370,
                    T: 1591250106368,
                    bids: [['9638.0', '431']],
                    asks: [['9638.2', '12']],
                })
            );

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderBook').mockRejectedValueOnce(mockError);
            await expect(client.orderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('premiumIndexKlineData()', () => {
        it('should execute premiumIndexKlineData() successfully with required parameters only', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1691603820000,
                        '-0.00042931',
                        '-0.00023641',
                        '-0.00059406',
                        '-0.00043659',
                        '0',
                        1691603879999,
                        '0',
                        12,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute premiumIndexKlineData() successfully with optional parameters', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1691603820000,
                        '-0.00042931',
                        '-0.00023641',
                        '-0.00059406',
                        '-0.00043659',
                        '0',
                        1691603879999,
                        '0',
                        12,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'premiumIndexKlineData')
                .mockRejectedValueOnce(mockError);
            await expect(client.premiumIndexKlineData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryIndexPriceConstituents()', () => {
        it('should execute queryIndexPriceConstituents() successfully with required parameters only', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSD',
                    time: 1697422647853,
                    constituents: [
                        { exchange: 'bitstamp', symbol: 'btcusd' },
                        { exchange: 'coinbase', symbol: 'BTC-USD' },
                        { exchange: 'kraken', symbol: 'XBT/USD' },
                        { exchange: 'binance_cross', symbol: 'BTCUSDC*index(USDCUSD)' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIndexPriceConstituents() successfully with optional parameters', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSD',
                    time: 1697422647853,
                    constituents: [
                        { exchange: 'bitstamp', symbol: 'btcusd' },
                        { exchange: 'coinbase', symbol: 'BTC-USD' },
                        { exchange: 'kraken', symbol: 'XBT/USD' },
                        { exchange: 'binance_cross', symbol: 'BTCUSDC*index(USDCUSD)' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryIndexPriceConstituents.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIndexPriceConstituents')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('recentTradesList()', () => {
        it('should execute recentTradesList() successfully with required parameters only', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '9635.0',
                        qty: '1',
                        baseQty: '0.01037883',
                        time: 1591250192508,
                        isBuyerMaker: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentTradesList() successfully with optional parameters', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '9635.0',
                        qty: '1',
                        baseQty: '0.01037883',
                        time: 1591250192508,
                        isBuyerMaker: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.recentTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling recentTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'recentTradesList').mockRejectedValueOnce(mockError);
            await expect(client.recentTradesList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolOrderBookTicker()', () => {
        it('should execute symbolOrderBookTicker() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        lastUpdateId: 1027024,
                        symbol: 'BTCUSD_200626',
                        pair: 'BTCUSD',
                        bidPrice: '9650.1',
                        bidQty: '16',
                        askPrice: '9650.3',
                        askQty: '7',
                        time: 1591257300345,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolOrderBookTicker() successfully with optional parameters', async () => {
            const params: SymbolOrderBookTickerRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        lastUpdateId: 1027024,
                        symbol: 'BTCUSD_200626',
                        pair: 'BTCUSD',
                        bidPrice: '9650.1',
                        bidQty: '16',
                        askPrice: '9650.3',
                        askQty: '7',
                        time: 1591257300345,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'symbolOrderBookTicker')
                .mockRejectedValueOnce(mockError);
            await expect(client.symbolOrderBookTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTicker()', () => {
        it('should execute symbolPriceTicker() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'BTCUSD_200626', ps: '9647.8', price: '9647.8', time: 1591257246176 },
                ])
            );

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTicker() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'BTCUSD_200626', ps: '9647.8', price: '9647.8', time: 1591257246176 },
                ])
            );

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTicker').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('takerBuySellVolume()', () => {
        it('should execute takerBuySellVolume() successfully with required parameters only', async () => {
            const params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        takerBuyVol: '387',
                        takerSellVol: '248',
                        takerBuyVolValue: '2342.1220',
                        takerSellVolValue: '4213.9800',
                        timestamp: 1591261042378,
                    },
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        takerBuyVol: '234',
                        takerSellVol: '121',
                        takerBuyVolValue: '4563.1320',
                        takerSellVolValue: '3313.3940',
                        timestamp: 1585615200000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute takerBuySellVolume() successfully with optional parameters', async () => {
            const params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        takerBuyVol: '387',
                        takerSellVol: '248',
                        takerBuyVolValue: '2342.1220',
                        takerSellVolValue: '4213.9800',
                        timestamp: 1591261042378,
                    },
                    {
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        takerBuyVol: '234',
                        takerSellVol: '121',
                        takerBuyVolValue: '4563.1320',
                        takerSellVolValue: '3313.3940',
                        timestamp: 1585615200000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'takerBuySellVolume').mockRejectedValueOnce(mockError);
            await expect(client.takerBuySellVolume(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testConnectivity()', () => {
        it('should execute testConnectivity() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'testConnectivity').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.testConnectivity();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testConnectivity').mockRejectedValueOnce(mockError);
            await expect(client.testConnectivity()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hrPriceChangeStatistics()', () => {
        it('should execute ticker24hrPriceChangeStatistics() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        priceChange: '136.6',
                        priceChangePercent: '1.436',
                        weightedAvgPrice: '9547.3',
                        lastPrice: '9651.6',
                        lastQty: '1',
                        openPrice: '9515.0',
                        highPrice: '9687.0',
                        lowPrice: '9499.5',
                        volume: '494109',
                        baseVolume: '5192.94797687',
                        openTime: 1591170300000,
                        closeTime: 1591256718418,
                        firstId: 600507,
                        lastId: 697803,
                        count: 97297,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hrPriceChangeStatistics() successfully with optional parameters', async () => {
            const params: Ticker24hrPriceChangeStatisticsRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        priceChange: '136.6',
                        priceChangePercent: '1.436',
                        weightedAvgPrice: '9547.3',
                        lastPrice: '9651.6',
                        lastQty: '1',
                        openPrice: '9515.0',
                        highPrice: '9687.0',
                        lowPrice: '9499.5',
                        volume: '494109',
                        baseVolume: '5192.94797687',
                        openTime: 1591170300000,
                        closeTime: 1591256718418,
                        firstId: 600507,
                        lastId: 697803,
                        count: 97297,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'ticker24hrPriceChangeStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.ticker24hrPriceChangeStatistics()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioAccounts()', () => {
        it('should execute topTraderLongShortRatioAccounts() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.8105',
                        longAccount: '0.6442',
                        shortAccount: '0.3558',
                        timestamp: 1591261042378,
                    },
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.1110',
                        longAccount: '0.5263',
                        shortAccount: '0.4737',
                        timestamp: 1592870400000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioAccounts() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.8105',
                        longAccount: '0.6442',
                        shortAccount: '0.3558',
                        timestamp: 1591261042378,
                    },
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.1110',
                        longAccount: '0.5263',
                        shortAccount: '0.4737',
                        timestamp: 1592870400000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioAccounts')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioPositions()', () => {
        it('should execute topTraderLongShortRatioPositions() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '0.7869',
                        longPosition: '0.6442',
                        shortPosition: '0.4404',
                        timestamp: 1592870400000,
                    },
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.1231',
                        longPosition: '0.2363',
                        shortPosition: '0.4537',
                        timestamp: 1592956800000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioPositions() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '0.7869',
                        longPosition: '0.6442',
                        shortPosition: '0.4404',
                        timestamp: 1592870400000,
                    },
                    {
                        pair: 'BTCUSD',
                        longShortRatio: '1.1231',
                        longPosition: '0.2363',
                        shortPosition: '0.4537',
                        timestamp: 1592956800000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioPositions')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
