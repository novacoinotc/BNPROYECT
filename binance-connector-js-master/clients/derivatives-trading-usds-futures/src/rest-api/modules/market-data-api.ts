/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AdlRiskResponse,
    BasisResponse,
    CheckServerTimeResponse,
    CompositeIndexSymbolInformationResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryResponse,
    GetFundingRateInfoResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    MarkPriceResponse,
    MultiAssetsModeAssetIndexResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QuarterlyContractSettlementPriceResponse,
    QueryIndexPriceConstituentsResponse,
    QueryInsuranceFundBalanceSnapshotResponse,
    RecentTradesListResponse,
    RpiOrderBookResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    SymbolPriceTickerV2Response,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
    TradingScheduleResponse,
} from '../types';

/**
 * MarketDataApi - axios parameter creator
 */
const MarketDataApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Query the symbol-level ADL risk rating.
         * The ADL risk rating measures the likelihood of ADL during liquidation, and the rating takes into account the insurance fund balance, position concentration on the symbol, order book depth, price volatility, average leverage, unrealized PnL, and margin utilization at the symbol level.
         * The rating can be high, medium and low, and is updated every 30 minutes.
         *
         * Weight: 1
         *
         * @summary ADL Risk
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        adlRisk: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/symbolAdlRisk',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query future basis
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 0
         *
         * @summary Basis
         * @param {string} pair
         * @param {BasisContractTypeEnum} contractType
         * @param {BasisPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number | bigint} limit Default 30,Max 500
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         *
         * @throws {RequiredError}
         */
        basis: async (
            pair: string,
            contractType: BasisContractTypeEnum,
            period: BasisPeriodEnum,
            limit: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('basis', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('basis', 'contractType', contractType);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('basis', 'period', period);
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('basis', 'limit', limit);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }
            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/basis',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         *
         * Weight: 1
         *
         * @summary Check Server Time
         *
         * @throws {RequiredError}
         */
        checkServerTime: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/time',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query composite index symbol information
         *
         * Only for composite index symbols
         *
         * Weight: 1
         *
         * @summary Composite Index Symbol Information
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        compositeIndexSymbolInformation: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/indexInfo',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         *
         *
         * Retail Price Improvement(RPI) orders are aggregated and without special tags to be distinguished.
         * support querying futures trade histories that are not older than one year
         * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
         * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
         * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
         * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
         *
         * Weight: 20
         *
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol
         * @param {number | bigint} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        compressedAggregateTradesList: async (
            symbol: string,
            fromId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('compressedAggregateTradesList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/aggTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type.
         * Klines are uniquely identified by their open time.
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         * Contract type:
         * PERPETUAL
         * CURRENT_QUARTER
         * NEXT_QUARTER
         * TRADIFI_PERPETUAL
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair
         * @param {ContinuousContractKlineCandlestickDataContractTypeEnum} contractType
         * @param {ContinuousContractKlineCandlestickDataIntervalEnum} interval
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        continuousContractKlineCandlestickData: async (
            pair: string,
            contractType: ContinuousContractKlineCandlestickDataContractTypeEnum,
            interval: ContinuousContractKlineCandlestickDataIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickData', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists(
                'continuousContractKlineCandlestickData',
                'contractType',
                contractType
            );
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/continuousKlines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         *
         * Weight: 1
         *
         * @summary Exchange Information
         *
         * @throws {RequiredError}
         */
        exchangeInformation: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/exchangeInfo',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Funding Rate History
         *
         *
         * If `startTime` and `endTime` are not sent, the most recent 200 records are returned.
         * If the number of data between `startTime` and `endTime` is larger than `limit`, return as `startTime` + `limit`.
         * In ascending order.
         *
         * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
         *
         * @summary Get Funding Rate History
         * @param {string} [symbol]
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        getFundingRateHistory: async (
            symbol?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/fundingRate',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         *
         * Weight: 0
         * share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
         *
         * @summary Get Funding Rate Info
         *
         * @throws {RequiredError}
         */
        getFundingRateInfo: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/fundingInfo',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair.
         * Klines are uniquely identified by their open time.
         *
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair
         * @param {IndexPriceKlineCandlestickDataIntervalEnum} interval
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        indexPriceKlineCandlestickData: async (
            pair: string,
            interval: IndexPriceKlineCandlestickDataIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('indexPriceKlineCandlestickData', 'pair', pair);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('indexPriceKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/indexPriceKlines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a symbol.
         * Klines are uniquely identified by their open time.
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Kline/Candlestick Data
         * @param {string} symbol
         * @param {KlineCandlestickDataIntervalEnum} interval
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        klineCandlestickData: async (
            symbol: string,
            interval: KlineCandlestickDataIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('klineCandlestickData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('klineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/klines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Long/Short Ratio
         * @param {string} symbol
         * @param {LongShortRatioPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         *
         * @throws {RequiredError}
         */
        longShortRatio: async (
            symbol: string,
            period: LongShortRatioPeriodEnum,
            limit?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('longShortRatio', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('longShortRatio', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/globalLongShortAccountRatio',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Mark Price and Funding Rate
         *
         * Weight: 1 with symbol, 10Â without symbol
         *
         * @summary Mark Price
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        markPrice: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/premiumIndex',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol.
         * Klines are uniquely identified by their open time.
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol
         * @param {MarkPriceKlineCandlestickDataIntervalEnum} interval
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        markPriceKlineCandlestickData: async (
            symbol: string,
            interval: MarkPriceKlineCandlestickDataIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('markPriceKlineCandlestickData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('markPriceKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/markPriceKlines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * asset index for Multi-Assets mode
         *
         * Weight: 1 for a single symbol; 10 when the symbol parameter is omitted
         *
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        multiAssetsModeAssetIndex: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/assetIndex',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get older market historical trades.
         *
         * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
         * Only supports data from within the last three months
         *
         * Weight: 20
         *
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [fromId] ID to get aggregate trades from INCLUSIVE.
         *
         * @throws {RequiredError}
         */
        oldTradesLookup: async (
            symbol: string,
            limit?: number | bigint,
            fromId?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('oldTradesLookup', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/historicalTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         *
         * Weight: 1
         *
         * @summary Open Interest
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        openInterest: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('openInterest', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/openInterest',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Open Interest Statistics
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 1 month is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Open Interest Statistics
         * @param {string} symbol
         * @param {OpenInterestStatisticsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         *
         * @throws {RequiredError}
         */
        openInterestStatistics: async (
            symbol: string,
            period: OpenInterestStatisticsPeriodEnum,
            limit?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('openInterestStatistics', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('openInterestStatistics', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/openInterestHist',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query symbol orderbook
         *
         * Retail Price Improvement(RPI) orders are not visible and excluded in the response message.
         *
         * Weight: Adjusted based on the limit:
         * | Limit         | Weight |
         * | ------------- | ------ |
         * | 5, 10, 20, 50 | 2      |
         * | 100           | 5      |
         * | 500           | 10     |
         * | 1000          | 20     |
         *
         * @summary Order Book
         * @param {string} symbol
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        orderBook: async (symbol: string, limit?: number | bigint): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderBook', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/depth',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         *
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Premium index Kline Data
         * @param {string} symbol
         * @param {PremiumIndexKlineDataIntervalEnum} interval
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        premiumIndexKlineData: async (
            symbol: string,
            interval: PremiumIndexKlineDataIntervalEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('premiumIndexKlineData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('premiumIndexKlineData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/premiumIndexKlines',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * Weight: 0
         *
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair
         *
         * @throws {RequiredError}
         */
        quarterlyContractSettlementPrice: async (pair: string): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('quarterlyContractSettlementPrice', 'pair', pair);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/delivery-price',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query index price constituents
         *
         *
         **Note**:
         *
         * Prices from constituents of TradFi perps will be hiden and displayed as -1.
         *
         * Weight: 2
         *
         * @summary Query Index Price Constituents
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        queryIndexPriceConstituents: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryIndexPriceConstituents', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/constituents',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Insurance Fund Balance Snapshot
         *
         * Weight: 1
         *
         * @summary Query Insurance Fund Balance Snapshot
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        queryInsuranceFundBalanceSnapshot: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/insuranceBalance',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get recent market trades
         *
         * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
         *
         * Weight: 5
         *
         * @summary Recent Trades List
         * @param {string} symbol
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        recentTradesList: async (symbol: string, limit?: number | bigint): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('recentTradesList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/trades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query symbol orderbook with RPI orders
         *
         * RPI(Retail Price Improvement) orders are included and aggreated in the response message. Crossed price levels are hidden and invisible.
         *
         * Weight: Adjusted based on the limit:
         * | Limit         | Weight |
         * | ------------- | ------ |
         * | 1000          | 20     |
         *
         * @summary RPI Order Book
         * @param {string} symbol
         * @param {number | bigint} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        rpiOrderBook: async (symbol: string, limit?: number | bigint): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('rpiOrderBook', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/rpiDepth',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         *
         * Retail Price Improvement(RPI) orders are not visible and excluded in the response message.
         * If the symbol is not sent, bookTickers for all symbols will be returned in an array.
         * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
         *
         * Weight: 2 for a single symbol;
         * 5 when the symbol parameter is omitted
         *
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        symbolOrderBookTicker: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ticker/bookTicker',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * If the symbol is not sent, prices for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol;
         * 2 when the symbol parameter is omitted
         *
         * @summary Symbol Price Ticker
         * @param {string} [symbol]
         *
         * @deprecated
         * @throws {RequiredError}
         */
        symbolPriceTicker: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ticker/price',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * If the symbol is not sent, prices for all symbols will be returned in an array.
         * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
         *
         * Weight: 1 for a single symbol;
         * 2 when the symbol parameter is omitted
         *
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        symbolPriceTickerV2: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v2/ticker/price',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Taker Buy/Sell Volume
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol
         * @param {TakerBuySellVolumePeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         *
         * @throws {RequiredError}
         */
        takerBuySellVolume: async (
            symbol: string,
            period: TakerBuySellVolumePeriodEnum,
            limit?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('takerBuySellVolume', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('takerBuySellVolume', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/takerlongshortRatio',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test connectivity to the Rest API.
         *
         * Weight: 1
         *
         * @summary Test Connectivity
         *
         * @throws {RequiredError}
         */
        testConnectivity: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ping',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         **Careful** when accessing this with no symbol.
         *
         * If the symbol is not sent, tickers for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol;
         * 40 when the symbol parameter is omitted
         *
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        ticker24hrPriceChangeStatistics: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ticker/24hr',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
         * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
         * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
         * Long/Short Ratio (Accounts) = Long Account % / Short Account %
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol
         * @param {TopTraderLongShortRatioAccountsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         *
         * @throws {RequiredError}
         */
        topTraderLongShortRatioAccounts: async (
            symbol: string,
            period: TopTraderLongShortRatioAccountsPeriodEnum,
            limit?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('topTraderLongShortRatioAccounts', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('topTraderLongShortRatioAccounts', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/topLongShortAccountRatio',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
         * Long Position % = Long positions of top traders / Total open positions of top traders
         * Short Position % = Short positions of top traders / Total open positions of top traders
         * Long/Short Ratio (Positions) = Long Position % / Short Position %
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol
         * @param {TopTraderLongShortRatioPositionsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [startTime]
         * @param {number | bigint} [endTime]
         *
         * @throws {RequiredError}
         */
        topTraderLongShortRatioPositions: async (
            symbol: string,
            period: TopTraderLongShortRatioPositionsPeriodEnum,
            limit?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('topTraderLongShortRatioPositions', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('topTraderLongShortRatioPositions', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/topLongShortPositionRatio',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Trading session schedules for the underlying assets of TradFi Perps are provided for a one-week period starting from the day prior to the query time, covering both the U.S. equity and commodity markets. Equity market session types include "PRE_MARKET", "REGULAR", "AFTER_MARKET", "OVERNIGHT", and "NO_TRADING", while commodity market session types include "REGULAR" and "NO_TRADING".
         *
         * Weight: 5
         *
         * @summary Trading Schedule
         *
         * @throws {RequiredError}
         */
        tradingSchedule: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/tradingSchedule',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * MarketDataApi - interface
 * @interface MarketDataApi
 */
export interface MarketDataApiInterface {
    /**
     * Query the symbol-level ADL risk rating.
     * The ADL risk rating measures the likelihood of ADL during liquidation, and the rating takes into account the insurance fund balance, position concentration on the symbol, order book depth, price volatility, average leverage, unrealized PnL, and margin utilization at the symbol level.
     * The rating can be high, medium and low, and is updated every 30 minutes.
     *
     * Weight: 1
     *
     * @summary ADL Risk
     * @param {AdlRiskRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    adlRisk(requestParameters?: AdlRiskRequest): Promise<RestApiResponse<AdlRiskResponse>>;
    /**
     * Query future basis
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 0
     *
     * @summary Basis
     * @param {BasisRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    basis(requestParameters: BasisRequest): Promise<RestApiResponse<BasisResponse>>;
    /**
     * Test connectivity to the Rest API and get the current server time.
     *
     * Weight: 1
     *
     * @summary Check Server Time
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    checkServerTime(): Promise<RestApiResponse<CheckServerTimeResponse>>;
    /**
     * Query composite index symbol information
     *
     * Only for composite index symbols
     *
     * Weight: 1
     *
     * @summary Composite Index Symbol Information
     * @param {CompositeIndexSymbolInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    compositeIndexSymbolInformation(
        requestParameters?: CompositeIndexSymbolInformationRequest
    ): Promise<RestApiResponse<CompositeIndexSymbolInformationResponse>>;
    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     *
     *
     * Retail Price Improvement(RPI) orders are aggregated and without special tags to be distinguished.
     * support querying futures trade histories that are not older than one year
     * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
     * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
     * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
     * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
     *
     * Weight: 20
     *
     * @summary Compressed/Aggregate Trades List
     * @param {CompressedAggregateTradesListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    compressedAggregateTradesList(
        requestParameters: CompressedAggregateTradesListRequest
    ): Promise<RestApiResponse<CompressedAggregateTradesListResponse>>;
    /**
     * Kline/candlestick bars for a specific contract type.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     * Contract type:
     * PERPETUAL
     * CURRENT_QUARTER
     * NEXT_QUARTER
     * TRADIFI_PERPETUAL
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {ContinuousContractKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    continuousContractKlineCandlestickData(
        requestParameters: ContinuousContractKlineCandlestickDataRequest
    ): Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>>;
    /**
     * Current exchange trading rules and symbol information
     *
     * Weight: 1
     *
     * @summary Exchange Information
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    exchangeInformation(): Promise<RestApiResponse<ExchangeInformationResponse>>;
    /**
     * Get Funding Rate History
     *
     *
     * If `startTime` and `endTime` are not sent, the most recent 200 records are returned.
     * If the number of data between `startTime` and `endTime` is larger than `limit`, return as `startTime` + `limit`.
     * In ascending order.
     *
     * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate History
     * @param {GetFundingRateHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    getFundingRateHistory(
        requestParameters?: GetFundingRateHistoryRequest
    ): Promise<RestApiResponse<GetFundingRateHistoryResponse>>;
    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     *
     * Weight: 0
     * share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate Info
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    getFundingRateInfo(): Promise<RestApiResponse<GetFundingRateInfoResponse>>;
    /**
     * Kline/candlestick bars for the index price of a pair.
     * Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Index Price Kline/Candlestick Data
     * @param {IndexPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    indexPriceKlineCandlestickData(
        requestParameters: IndexPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>>;
    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Kline/Candlestick Data
     * @param {KlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    klineCandlestickData(
        requestParameters: KlineCandlestickDataRequest
    ): Promise<RestApiResponse<KlineCandlestickDataResponse>>;
    /**
     * Query symbol Long/Short Ratio
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Long/Short Ratio
     * @param {LongShortRatioRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    longShortRatio(
        requestParameters: LongShortRatioRequest
    ): Promise<RestApiResponse<LongShortRatioResponse>>;
    /**
     * Mark Price and Funding Rate
     *
     * Weight: 1 with symbol, 10Â without symbol
     *
     * @summary Mark Price
     * @param {MarkPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    markPrice(requestParameters?: MarkPriceRequest): Promise<RestApiResponse<MarkPriceResponse>>;
    /**
     * Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarkPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    markPriceKlineCandlestickData(
        requestParameters: MarkPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>>;
    /**
     * asset index for Multi-Assets mode
     *
     * Weight: 1 for a single symbol; 10 when the symbol parameter is omitted
     *
     * @summary Multi-Assets Mode Asset Index
     * @param {MultiAssetsModeAssetIndexRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    multiAssetsModeAssetIndex(
        requestParameters?: MultiAssetsModeAssetIndexRequest
    ): Promise<RestApiResponse<MultiAssetsModeAssetIndexResponse>>;
    /**
     * Get older market historical trades.
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     * Only supports data from within the last three months
     *
     * Weight: 20
     *
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {OldTradesLookupRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    oldTradesLookup(
        requestParameters: OldTradesLookupRequest
    ): Promise<RestApiResponse<OldTradesLookupResponse>>;
    /**
     * Get present open interest of a specific symbol.
     *
     * Weight: 1
     *
     * @summary Open Interest
     * @param {OpenInterestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    openInterest(
        requestParameters: OpenInterestRequest
    ): Promise<RestApiResponse<OpenInterestResponse>>;
    /**
     * Open Interest Statistics
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 1 month is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Open Interest Statistics
     * @param {OpenInterestStatisticsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    openInterestStatistics(
        requestParameters: OpenInterestStatisticsRequest
    ): Promise<RestApiResponse<OpenInterestStatisticsResponse>>;
    /**
     * Query symbol orderbook
     *
     * Retail Price Improvement(RPI) orders are not visible and excluded in the response message.
     *
     * Weight: Adjusted based on the limit:
     * | Limit         | Weight |
     * | ------------- | ------ |
     * | 5, 10, 20, 50 | 2      |
     * | 100           | 5      |
     * | 500           | 10     |
     * | 1000          | 20     |
     *
     * @summary Order Book
     * @param {OrderBookRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    orderBook(requestParameters: OrderBookRequest): Promise<RestApiResponse<OrderBookResponse>>;
    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Premium index Kline Data
     * @param {PremiumIndexKlineDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    premiumIndexKlineData(
        requestParameters: PremiumIndexKlineDataRequest
    ): Promise<RestApiResponse<PremiumIndexKlineDataResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * Weight: 0
     *
     * @summary Quarterly Contract Settlement Price
     * @param {QuarterlyContractSettlementPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    quarterlyContractSettlementPrice(
        requestParameters: QuarterlyContractSettlementPriceRequest
    ): Promise<RestApiResponse<QuarterlyContractSettlementPriceResponse>>;
    /**
     * Query index price constituents
     *
     *
     **Note**:
     *
     * Prices from constituents of TradFi perps will be hiden and displayed as -1.
     *
     * Weight: 2
     *
     * @summary Query Index Price Constituents
     * @param {QueryIndexPriceConstituentsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    queryIndexPriceConstituents(
        requestParameters: QueryIndexPriceConstituentsRequest
    ): Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>>;
    /**
     * Query Insurance Fund Balance Snapshot
     *
     * Weight: 1
     *
     * @summary Query Insurance Fund Balance Snapshot
     * @param {QueryInsuranceFundBalanceSnapshotRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    queryInsuranceFundBalanceSnapshot(
        requestParameters?: QueryInsuranceFundBalanceSnapshotRequest
    ): Promise<RestApiResponse<QueryInsuranceFundBalanceSnapshotResponse>>;
    /**
     * Get recent market trades
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 5
     *
     * @summary Recent Trades List
     * @param {RecentTradesListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    recentTradesList(
        requestParameters: RecentTradesListRequest
    ): Promise<RestApiResponse<RecentTradesListResponse>>;
    /**
     * Query symbol orderbook with RPI orders
     *
     * RPI(Retail Price Improvement) orders are included and aggreated in the response message. Crossed price levels are hidden and invisible.
     *
     * Weight: Adjusted based on the limit:
     * | Limit         | Weight |
     * | ------------- | ------ |
     * | 1000          | 20     |
     *
     * @summary RPI Order Book
     * @param {RpiOrderBookRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    rpiOrderBook(
        requestParameters: RpiOrderBookRequest
    ): Promise<RestApiResponse<RpiOrderBookResponse>>;
    /**
     * Best price/qty on the order book for a symbol or symbols.
     *
     * Retail Price Improvement(RPI) orders are not visible and excluded in the response message.
     * If the symbol is not sent, bookTickers for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 2 for a single symbol;
     * 5 when the symbol parameter is omitted
     *
     * @summary Symbol Order Book Ticker
     * @param {SymbolOrderBookTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolOrderBookTicker(
        requestParameters?: SymbolOrderBookTickerRequest
    ): Promise<RestApiResponse<SymbolOrderBookTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker
     * @param {SymbolPriceTickerRequest} requestParameters Request parameters.
     *
     * @deprecated
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolPriceTicker(
        requestParameters?: SymbolPriceTickerRequest
    ): Promise<RestApiResponse<SymbolPriceTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker V2
     * @param {SymbolPriceTickerV2Request} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolPriceTickerV2(
        requestParameters?: SymbolPriceTickerV2Request
    ): Promise<RestApiResponse<SymbolPriceTickerV2Response>>;
    /**
     * Taker Buy/Sell Volume
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Taker Buy/Sell Volume
     * @param {TakerBuySellVolumeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    takerBuySellVolume(
        requestParameters: TakerBuySellVolumeRequest
    ): Promise<RestApiResponse<TakerBuySellVolumeResponse>>;
    /**
     * Test connectivity to the Rest API.
     *
     * Weight: 1
     *
     * @summary Test Connectivity
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    testConnectivity(): Promise<RestApiResponse<void>>;
    /**
     * 24 hour rolling window price change statistics.
     **Careful** when accessing this with no symbol.
     *
     * If the symbol is not sent, tickers for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 40 when the symbol parameter is omitted
     *
     * @summary 24hr Ticker Price Change Statistics
     * @param {Ticker24hrPriceChangeStatisticsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    ticker24hrPriceChangeStatistics(
        requestParameters?: Ticker24hrPriceChangeStatisticsRequest
    ): Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>>;
    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
     * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
     * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
     * Long/Short Ratio (Accounts) = Long Account % / Short Account %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {TopTraderLongShortRatioAccountsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    topTraderLongShortRatioAccounts(
        requestParameters: TopTraderLongShortRatioAccountsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>>;
    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
     * Long Position % = Long positions of top traders / Total open positions of top traders
     * Short Position % = Short positions of top traders / Total open positions of top traders
     * Long/Short Ratio (Positions) = Long Position % / Short Position %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {TopTraderLongShortRatioPositionsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    topTraderLongShortRatioPositions(
        requestParameters: TopTraderLongShortRatioPositionsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>>;
    /**
     * Trading session schedules for the underlying assets of TradFi Perps are provided for a one-week period starting from the day prior to the query time, covering both the U.S. equity and commodity markets. Equity market session types include "PRE_MARKET", "REGULAR", "AFTER_MARKET", "OVERNIGHT", and "NO_TRADING", while commodity market session types include "REGULAR" and "NO_TRADING".
     *
     * Weight: 5
     *
     * @summary Trading Schedule
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    tradingSchedule(): Promise<RestApiResponse<TradingScheduleResponse>>;
}

/**
 * Request parameters for adlRisk operation in MarketDataApi.
 * @interface AdlRiskRequest
 */
export interface AdlRiskRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiAdlRisk
     */
    readonly symbol?: string;
}

/**
 * Request parameters for basis operation in MarketDataApi.
 * @interface BasisRequest
 */
export interface BasisRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiBasis
     */
    readonly pair: string;

    /**
     *
     * @type {'PERPETUAL' | 'CURRENT_MONTH' | 'NEXT_MONTH' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiBasis
     */
    readonly contractType: BasisContractTypeEnum;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiBasis
     */
    readonly period: BasisPeriodEnum;

    /**
     * Default 30,Max 500
     * @type {number | bigint}
     * @memberof MarketDataApiBasis
     */
    readonly limit: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiBasis
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiBasis
     */
    readonly endTime?: number | bigint;
}

/**
 * Request parameters for compositeIndexSymbolInformation operation in MarketDataApi.
 * @interface CompositeIndexSymbolInformationRequest
 */
export interface CompositeIndexSymbolInformationRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiCompositeIndexSymbolInformation
     */
    readonly symbol?: string;
}

/**
 * Request parameters for compressedAggregateTradesList operation in MarketDataApi.
 * @interface CompressedAggregateTradesListRequest
 */
export interface CompressedAggregateTradesListRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly symbol: string;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly fromId?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for continuousContractKlineCandlestickData operation in MarketDataApi.
 * @interface ContinuousContractKlineCandlestickDataRequest
 */
export interface ContinuousContractKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly pair: string;

    /**
     *
     * @type {'PERPETUAL' | 'CURRENT_MONTH' | 'NEXT_MONTH' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly contractType: ContinuousContractKlineCandlestickDataContractTypeEnum;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly interval: ContinuousContractKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for getFundingRateHistory operation in MarketDataApi.
 * @interface GetFundingRateHistoryRequest
 */
export interface GetFundingRateHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for indexPriceKlineCandlestickData operation in MarketDataApi.
 * @interface IndexPriceKlineCandlestickDataRequest
 */
export interface IndexPriceKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly pair: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly interval: IndexPriceKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for klineCandlestickData operation in MarketDataApi.
 * @interface KlineCandlestickDataRequest
 */
export interface KlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly interval: KlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for longShortRatio operation in MarketDataApi.
 * @interface LongShortRatioRequest
 */
export interface LongShortRatioRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly period: LongShortRatioPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly endTime?: number | bigint;
}

/**
 * Request parameters for markPrice operation in MarketDataApi.
 * @interface MarkPriceRequest
 */
export interface MarkPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMarkPrice
     */
    readonly symbol?: string;
}

/**
 * Request parameters for markPriceKlineCandlestickData operation in MarketDataApi.
 * @interface MarkPriceKlineCandlestickDataRequest
 */
export interface MarkPriceKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly interval: MarkPriceKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for multiAssetsModeAssetIndex operation in MarketDataApi.
 * @interface MultiAssetsModeAssetIndexRequest
 */
export interface MultiAssetsModeAssetIndexRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMultiAssetsModeAssetIndex
     */
    readonly symbol?: string;
}

/**
 * Request parameters for oldTradesLookup operation in MarketDataApi.
 * @interface OldTradesLookupRequest
 */
export interface OldTradesLookupRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly limit?: number | bigint;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number | bigint}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly fromId?: number | bigint;
}

/**
 * Request parameters for openInterest operation in MarketDataApi.
 * @interface OpenInterestRequest
 */
export interface OpenInterestRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOpenInterest
     */
    readonly symbol: string;
}

/**
 * Request parameters for openInterestStatistics operation in MarketDataApi.
 * @interface OpenInterestStatisticsRequest
 */
export interface OpenInterestStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly period: OpenInterestStatisticsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly endTime?: number | bigint;
}

/**
 * Request parameters for orderBook operation in MarketDataApi.
 * @interface OrderBookRequest
 */
export interface OrderBookRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOrderBook
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiOrderBook
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for premiumIndexKlineData operation in MarketDataApi.
 * @interface PremiumIndexKlineDataRequest
 */
export interface PremiumIndexKlineDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly interval: PremiumIndexKlineDataIntervalEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for quarterlyContractSettlementPrice operation in MarketDataApi.
 * @interface QuarterlyContractSettlementPriceRequest
 */
export interface QuarterlyContractSettlementPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiQuarterlyContractSettlementPrice
     */
    readonly pair: string;
}

/**
 * Request parameters for queryIndexPriceConstituents operation in MarketDataApi.
 * @interface QueryIndexPriceConstituentsRequest
 */
export interface QueryIndexPriceConstituentsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiQueryIndexPriceConstituents
     */
    readonly symbol: string;
}

/**
 * Request parameters for queryInsuranceFundBalanceSnapshot operation in MarketDataApi.
 * @interface QueryInsuranceFundBalanceSnapshotRequest
 */
export interface QueryInsuranceFundBalanceSnapshotRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiQueryInsuranceFundBalanceSnapshot
     */
    readonly symbol?: string;
}

/**
 * Request parameters for recentTradesList operation in MarketDataApi.
 * @interface RecentTradesListRequest
 */
export interface RecentTradesListRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiRecentTradesList
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiRecentTradesList
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for rpiOrderBook operation in MarketDataApi.
 * @interface RpiOrderBookRequest
 */
export interface RpiOrderBookRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiRpiOrderBook
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiRpiOrderBook
     */
    readonly limit?: number | bigint;
}

/**
 * Request parameters for symbolOrderBookTicker operation in MarketDataApi.
 * @interface SymbolOrderBookTickerRequest
 */
export interface SymbolOrderBookTickerRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolOrderBookTicker
     */
    readonly symbol?: string;
}

/**
 * Request parameters for symbolPriceTicker operation in MarketDataApi.
 * @interface SymbolPriceTickerRequest
 */
export interface SymbolPriceTickerRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolPriceTicker
     */
    readonly symbol?: string;
}

/**
 * Request parameters for symbolPriceTickerV2 operation in MarketDataApi.
 * @interface SymbolPriceTickerV2Request
 */
export interface SymbolPriceTickerV2Request {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolPriceTickerV2
     */
    readonly symbol?: string;
}

/**
 * Request parameters for takerBuySellVolume operation in MarketDataApi.
 * @interface TakerBuySellVolumeRequest
 */
export interface TakerBuySellVolumeRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly period: TakerBuySellVolumePeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly endTime?: number | bigint;
}

/**
 * Request parameters for ticker24hrPriceChangeStatistics operation in MarketDataApi.
 * @interface Ticker24hrPriceChangeStatisticsRequest
 */
export interface Ticker24hrPriceChangeStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTicker24hrPriceChangeStatistics
     */
    readonly symbol?: string;
}

/**
 * Request parameters for topTraderLongShortRatioAccounts operation in MarketDataApi.
 * @interface TopTraderLongShortRatioAccountsRequest
 */
export interface TopTraderLongShortRatioAccountsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly period: TopTraderLongShortRatioAccountsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly endTime?: number | bigint;
}

/**
 * Request parameters for topTraderLongShortRatioPositions operation in MarketDataApi.
 * @interface TopTraderLongShortRatioPositionsRequest
 */
export interface TopTraderLongShortRatioPositionsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly period: TopTraderLongShortRatioPositionsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly startTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly endTime?: number | bigint;
}

/**
 * MarketDataApi - object-oriented interface
 * @class MarketDataApi
 */
export class MarketDataApi implements MarketDataApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = MarketDataApiAxiosParamCreator(configuration);
    }

    /**
     * Query the symbol-level ADL risk rating.
     * The ADL risk rating measures the likelihood of ADL during liquidation, and the rating takes into account the insurance fund balance, position concentration on the symbol, order book depth, price volatility, average leverage, unrealized PnL, and margin utilization at the symbol level.
     * The rating can be high, medium and low, and is updated every 30 minutes.
     *
     * Weight: 1
     *
     * @summary ADL Risk
     * @param {AdlRiskRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AdlRiskResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/ADL-Risk Binance API Documentation}
     */
    public async adlRisk(
        requestParameters: AdlRiskRequest = {}
    ): Promise<RestApiResponse<AdlRiskResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.adlRisk(
            requestParameters?.symbol
        );
        return sendRequest<AdlRiskResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query future basis
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 0
     *
     * @summary Basis
     * @param {BasisRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<BasisResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Basis Binance API Documentation}
     */
    public async basis(requestParameters: BasisRequest): Promise<RestApiResponse<BasisResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.basis(
            requestParameters?.pair,
            requestParameters?.contractType,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<BasisResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     *
     * Weight: 1
     *
     * @summary Check Server Time
     * @returns {Promise<RestApiResponse<CheckServerTimeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Check-Server-Time Binance API Documentation}
     */
    public async checkServerTime(): Promise<RestApiResponse<CheckServerTimeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.checkServerTime();
        return sendRequest<CheckServerTimeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query composite index symbol information
     *
     * Only for composite index symbols
     *
     * Weight: 1
     *
     * @summary Composite Index Symbol Information
     * @param {CompositeIndexSymbolInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CompositeIndexSymbolInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Composite-Index-Symbol-Information Binance API Documentation}
     */
    public async compositeIndexSymbolInformation(
        requestParameters: CompositeIndexSymbolInformationRequest = {}
    ): Promise<RestApiResponse<CompositeIndexSymbolInformationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.compositeIndexSymbolInformation(
                requestParameters?.symbol
            );
        return sendRequest<CompositeIndexSymbolInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     *
     *
     * Retail Price Improvement(RPI) orders are aggregated and without special tags to be distinguished.
     * support querying futures trade histories that are not older than one year
     * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
     * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
     * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
     * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
     *
     * Weight: 20
     *
     * @summary Compressed/Aggregate Trades List
     * @param {CompressedAggregateTradesListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CompressedAggregateTradesListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List Binance API Documentation}
     */
    public async compressedAggregateTradesList(
        requestParameters: CompressedAggregateTradesListRequest
    ): Promise<RestApiResponse<CompressedAggregateTradesListResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.compressedAggregateTradesList(
                requestParameters?.symbol,
                requestParameters?.fromId,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<CompressedAggregateTradesListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a specific contract type.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     * Contract type:
     * PERPETUAL
     * CURRENT_QUARTER
     * NEXT_QUARTER
     * TRADIFI_PERPETUAL
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {ContinuousContractKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Continuous-Contract-Kline-Candlestick-Data Binance API Documentation}
     */
    public async continuousContractKlineCandlestickData(
        requestParameters: ContinuousContractKlineCandlestickDataRequest
    ): Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.continuousContractKlineCandlestickData(
                requestParameters?.pair,
                requestParameters?.contractType,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<ContinuousContractKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Current exchange trading rules and symbol information
     *
     * Weight: 1
     *
     * @summary Exchange Information
     * @returns {Promise<RestApiResponse<ExchangeInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information Binance API Documentation}
     */
    public async exchangeInformation(): Promise<RestApiResponse<ExchangeInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.exchangeInformation();
        return sendRequest<ExchangeInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get Funding Rate History
     *
     *
     * If `startTime` and `endTime` are not sent, the most recent 200 records are returned.
     * If the number of data between `startTime` and `endTime` is larger than `limit`, return as `startTime` + `limit`.
     * In ascending order.
     *
     * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate History
     * @param {GetFundingRateHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetFundingRateHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-History Binance API Documentation}
     */
    public async getFundingRateHistory(
        requestParameters: GetFundingRateHistoryRequest = {}
    ): Promise<RestApiResponse<GetFundingRateHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getFundingRateHistory(
            requestParameters?.symbol,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<GetFundingRateHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     *
     * Weight: 0
     * share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate Info
     * @returns {Promise<RestApiResponse<GetFundingRateInfoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-Info Binance API Documentation}
     */
    public async getFundingRateInfo(): Promise<RestApiResponse<GetFundingRateInfoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getFundingRateInfo();
        return sendRequest<GetFundingRateInfoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for the index price of a pair.
     * Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Index Price Kline/Candlestick Data
     * @param {IndexPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data Binance API Documentation}
     */
    public async indexPriceKlineCandlestickData(
        requestParameters: IndexPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.indexPriceKlineCandlestickData(
                requestParameters?.pair,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<IndexPriceKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Kline/Candlestick Data
     * @param {KlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<KlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data Binance API Documentation}
     */
    public async klineCandlestickData(
        requestParameters: KlineCandlestickDataRequest
    ): Promise<RestApiResponse<KlineCandlestickDataResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.klineCandlestickData(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<KlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query symbol Long/Short Ratio
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Long/Short Ratio
     * @param {LongShortRatioRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<LongShortRatioResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Long-Short-Ratio Binance API Documentation}
     */
    public async longShortRatio(
        requestParameters: LongShortRatioRequest
    ): Promise<RestApiResponse<LongShortRatioResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.longShortRatio(
            requestParameters?.symbol,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<LongShortRatioResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Mark Price and Funding Rate
     *
     * Weight: 1 with symbol, 10Â without symbol
     *
     * @summary Mark Price
     * @param {MarkPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarkPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price Binance API Documentation}
     */
    public async markPrice(
        requestParameters: MarkPriceRequest = {}
    ): Promise<RestApiResponse<MarkPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.markPrice(
            requestParameters?.symbol
        );
        return sendRequest<MarkPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarkPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data Binance API Documentation}
     */
    public async markPriceKlineCandlestickData(
        requestParameters: MarkPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.markPriceKlineCandlestickData(
                requestParameters?.symbol,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<MarkPriceKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * asset index for Multi-Assets mode
     *
     * Weight: 1 for a single symbol; 10 when the symbol parameter is omitted
     *
     * @summary Multi-Assets Mode Asset Index
     * @param {MultiAssetsModeAssetIndexRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MultiAssetsModeAssetIndexResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Multi-Assets-Mode-Asset-Index Binance API Documentation}
     */
    public async multiAssetsModeAssetIndex(
        requestParameters: MultiAssetsModeAssetIndexRequest = {}
    ): Promise<RestApiResponse<MultiAssetsModeAssetIndexResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.multiAssetsModeAssetIndex(
            requestParameters?.symbol
        );
        return sendRequest<MultiAssetsModeAssetIndexResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get older market historical trades.
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     * Only supports data from within the last three months
     *
     * Weight: 20
     *
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {OldTradesLookupRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OldTradesLookupResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup Binance API Documentation}
     */
    public async oldTradesLookup(
        requestParameters: OldTradesLookupRequest
    ): Promise<RestApiResponse<OldTradesLookupResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.oldTradesLookup(
            requestParameters?.symbol,
            requestParameters?.limit,
            requestParameters?.fromId
        );
        return sendRequest<OldTradesLookupResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get present open interest of a specific symbol.
     *
     * Weight: 1
     *
     * @summary Open Interest
     * @param {OpenInterestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenInterestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest Binance API Documentation}
     */
    public async openInterest(
        requestParameters: OpenInterestRequest
    ): Promise<RestApiResponse<OpenInterestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openInterest(
            requestParameters?.symbol
        );
        return sendRequest<OpenInterestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Open Interest Statistics
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 1 month is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Open Interest Statistics
     * @param {OpenInterestStatisticsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenInterestStatisticsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest-Statistics Binance API Documentation}
     */
    public async openInterestStatistics(
        requestParameters: OpenInterestStatisticsRequest
    ): Promise<RestApiResponse<OpenInterestStatisticsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openInterestStatistics(
            requestParameters?.symbol,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<OpenInterestStatisticsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query symbol orderbook
     *
     * Retail Price Improvement(RPI) orders are not visible and excluded in the response message.
     *
     * Weight: Adjusted based on the limit:
     * | Limit         | Weight |
     * | ------------- | ------ |
     * | 5, 10, 20, 50 | 2      |
     * | 100           | 5      |
     * | 500           | 10     |
     * | 1000          | 20     |
     *
     * @summary Order Book
     * @param {OrderBookRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderBookResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book Binance API Documentation}
     */
    public async orderBook(
        requestParameters: OrderBookRequest
    ): Promise<RestApiResponse<OrderBookResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderBook(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<OrderBookResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Premium index Kline Data
     * @param {PremiumIndexKlineDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PremiumIndexKlineDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Premium-index-Kline-Data Binance API Documentation}
     */
    public async premiumIndexKlineData(
        requestParameters: PremiumIndexKlineDataRequest
    ): Promise<RestApiResponse<PremiumIndexKlineDataResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.premiumIndexKlineData(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<PremiumIndexKlineDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * Weight: 0
     *
     * @summary Quarterly Contract Settlement Price
     * @param {QuarterlyContractSettlementPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QuarterlyContractSettlementPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Delivery-Price Binance API Documentation}
     */
    public async quarterlyContractSettlementPrice(
        requestParameters: QuarterlyContractSettlementPriceRequest
    ): Promise<RestApiResponse<QuarterlyContractSettlementPriceResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.quarterlyContractSettlementPrice(
                requestParameters?.pair
            );
        return sendRequest<QuarterlyContractSettlementPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query index price constituents
     *
     *
     **Note**:
     *
     * Prices from constituents of TradFi perps will be hiden and displayed as -1.
     *
     * Weight: 2
     *
     * @summary Query Index Price Constituents
     * @param {QueryIndexPriceConstituentsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Constituents Binance API Documentation}
     */
    public async queryIndexPriceConstituents(
        requestParameters: QueryIndexPriceConstituentsRequest
    ): Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryIndexPriceConstituents(
            requestParameters?.symbol
        );
        return sendRequest<QueryIndexPriceConstituentsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query Insurance Fund Balance Snapshot
     *
     * Weight: 1
     *
     * @summary Query Insurance Fund Balance Snapshot
     * @param {QueryInsuranceFundBalanceSnapshotRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryInsuranceFundBalanceSnapshotResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Query-Insurance-Fund-Balance-Snapshot Binance API Documentation}
     */
    public async queryInsuranceFundBalanceSnapshot(
        requestParameters: QueryInsuranceFundBalanceSnapshotRequest = {}
    ): Promise<RestApiResponse<QueryInsuranceFundBalanceSnapshotResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryInsuranceFundBalanceSnapshot(
                requestParameters?.symbol
            );
        return sendRequest<QueryInsuranceFundBalanceSnapshotResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get recent market trades
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 5
     *
     * @summary Recent Trades List
     * @param {RecentTradesListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<RecentTradesListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List Binance API Documentation}
     */
    public async recentTradesList(
        requestParameters: RecentTradesListRequest
    ): Promise<RestApiResponse<RecentTradesListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.recentTradesList(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<RecentTradesListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query symbol orderbook with RPI orders
     *
     * RPI(Retail Price Improvement) orders are included and aggreated in the response message. Crossed price levels are hidden and invisible.
     *
     * Weight: Adjusted based on the limit:
     * | Limit         | Weight |
     * | ------------- | ------ |
     * | 1000          | 20     |
     *
     * @summary RPI Order Book
     * @param {RpiOrderBookRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<RpiOrderBookResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book-RPI Binance API Documentation}
     */
    public async rpiOrderBook(
        requestParameters: RpiOrderBookRequest
    ): Promise<RestApiResponse<RpiOrderBookResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.rpiOrderBook(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<RpiOrderBookResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     *
     * Retail Price Improvement(RPI) orders are not visible and excluded in the response message.
     * If the symbol is not sent, bookTickers for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 2 for a single symbol;
     * 5 when the symbol parameter is omitted
     *
     * @summary Symbol Order Book Ticker
     * @param {SymbolOrderBookTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolOrderBookTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker Binance API Documentation}
     */
    public async symbolOrderBookTicker(
        requestParameters: SymbolOrderBookTickerRequest = {}
    ): Promise<RestApiResponse<SymbolOrderBookTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolOrderBookTicker(
            requestParameters?.symbol
        );
        return sendRequest<SymbolOrderBookTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker
     * @param {SymbolPriceTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolPriceTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker Binance API Documentation}
     */
    public async symbolPriceTicker(
        requestParameters: SymbolPriceTickerRequest = {}
    ): Promise<RestApiResponse<SymbolPriceTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolPriceTicker(
            requestParameters?.symbol
        );
        return sendRequest<SymbolPriceTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker V2
     * @param {SymbolPriceTickerV2Request} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolPriceTickerV2Response>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker-V2 Binance API Documentation}
     */
    public async symbolPriceTickerV2(
        requestParameters: SymbolPriceTickerV2Request = {}
    ): Promise<RestApiResponse<SymbolPriceTickerV2Response>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolPriceTickerV2(
            requestParameters?.symbol
        );
        return sendRequest<SymbolPriceTickerV2Response>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Taker Buy/Sell Volume
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Taker Buy/Sell Volume
     * @param {TakerBuySellVolumeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TakerBuySellVolumeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Taker-BuySell-Volume Binance API Documentation}
     */
    public async takerBuySellVolume(
        requestParameters: TakerBuySellVolumeRequest
    ): Promise<RestApiResponse<TakerBuySellVolumeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.takerBuySellVolume(
            requestParameters?.symbol,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<TakerBuySellVolumeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Test connectivity to the Rest API.
     *
     * Weight: 1
     *
     * @summary Test Connectivity
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Test-Connectivity Binance API Documentation}
     */
    public async testConnectivity(): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.testConnectivity();
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * 24 hour rolling window price change statistics.
     **Careful** when accessing this with no symbol.
     *
     * If the symbol is not sent, tickers for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 40 when the symbol parameter is omitted
     *
     * @summary 24hr Ticker Price Change Statistics
     * @param {Ticker24hrPriceChangeStatisticsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics Binance API Documentation}
     */
    public async ticker24hrPriceChangeStatistics(
        requestParameters: Ticker24hrPriceChangeStatisticsRequest = {}
    ): Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.ticker24hrPriceChangeStatistics(
                requestParameters?.symbol
            );
        return sendRequest<Ticker24hrPriceChangeStatisticsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
     * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
     * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
     * Long/Short Ratio (Accounts) = Long Account % / Short Account %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {TopTraderLongShortRatioAccountsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Long-Short-Account-Ratio Binance API Documentation}
     */
    public async topTraderLongShortRatioAccounts(
        requestParameters: TopTraderLongShortRatioAccountsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.topTraderLongShortRatioAccounts(
                requestParameters?.symbol,
                requestParameters?.period,
                requestParameters?.limit,
                requestParameters?.startTime,
                requestParameters?.endTime
            );
        return sendRequest<TopTraderLongShortRatioAccountsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
     * Long Position % = Long positions of top traders / Total open positions of top traders
     * Short Position % = Short positions of top traders / Total open positions of top traders
     * Long/Short Ratio (Positions) = Long Position % / Short Position %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {TopTraderLongShortRatioPositionsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Trader-Long-Short-Ratio Binance API Documentation}
     */
    public async topTraderLongShortRatioPositions(
        requestParameters: TopTraderLongShortRatioPositionsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.topTraderLongShortRatioPositions(
                requestParameters?.symbol,
                requestParameters?.period,
                requestParameters?.limit,
                requestParameters?.startTime,
                requestParameters?.endTime
            );
        return sendRequest<TopTraderLongShortRatioPositionsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Trading session schedules for the underlying assets of TradFi Perps are provided for a one-week period starting from the day prior to the query time, covering both the U.S. equity and commodity markets. Equity market session types include "PRE_MARKET", "REGULAR", "AFTER_MARKET", "OVERNIGHT", and "NO_TRADING", while commodity market session types include "REGULAR" and "NO_TRADING".
     *
     * Weight: 5
     *
     * @summary Trading Schedule
     * @returns {Promise<RestApiResponse<TradingScheduleResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Trading-Schedule Binance API Documentation}
     */
    public async tradingSchedule(): Promise<RestApiResponse<TradingScheduleResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tradingSchedule();
        return sendRequest<TradingScheduleResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }
}

export enum BasisContractTypeEnum {
    PERPETUAL = 'PERPETUAL',
    CURRENT_MONTH = 'CURRENT_MONTH',
    NEXT_MONTH = 'NEXT_MONTH',
    CURRENT_QUARTER = 'CURRENT_QUARTER',
    NEXT_QUARTER = 'NEXT_QUARTER',
    PERPETUAL_DELIVERING = 'PERPETUAL_DELIVERING',
}

export enum BasisPeriodEnum {
    PERIOD_5m = '5m',
    PERIOD_15m = '15m',
    PERIOD_30m = '30m',
    PERIOD_1h = '1h',
    PERIOD_2h = '2h',
    PERIOD_4h = '4h',
    PERIOD_6h = '6h',
    PERIOD_12h = '12h',
    PERIOD_1d = '1d',
}

export enum ContinuousContractKlineCandlestickDataContractTypeEnum {
    PERPETUAL = 'PERPETUAL',
    CURRENT_MONTH = 'CURRENT_MONTH',
    NEXT_MONTH = 'NEXT_MONTH',
    CURRENT_QUARTER = 'CURRENT_QUARTER',
    NEXT_QUARTER = 'NEXT_QUARTER',
    PERPETUAL_DELIVERING = 'PERPETUAL_DELIVERING',
}

export enum ContinuousContractKlineCandlestickDataIntervalEnum {
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}

export enum IndexPriceKlineCandlestickDataIntervalEnum {
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}

export enum KlineCandlestickDataIntervalEnum {
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}

export enum LongShortRatioPeriodEnum {
    PERIOD_5m = '5m',
    PERIOD_15m = '15m',
    PERIOD_30m = '30m',
    PERIOD_1h = '1h',
    PERIOD_2h = '2h',
    PERIOD_4h = '4h',
    PERIOD_6h = '6h',
    PERIOD_12h = '12h',
    PERIOD_1d = '1d',
}

export enum MarkPriceKlineCandlestickDataIntervalEnum {
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}

export enum OpenInterestStatisticsPeriodEnum {
    PERIOD_5m = '5m',
    PERIOD_15m = '15m',
    PERIOD_30m = '30m',
    PERIOD_1h = '1h',
    PERIOD_2h = '2h',
    PERIOD_4h = '4h',
    PERIOD_6h = '6h',
    PERIOD_12h = '12h',
    PERIOD_1d = '1d',
}

export enum PremiumIndexKlineDataIntervalEnum {
    INTERVAL_1m = '1m',
    INTERVAL_3m = '3m',
    INTERVAL_5m = '5m',
    INTERVAL_15m = '15m',
    INTERVAL_30m = '30m',
    INTERVAL_1h = '1h',
    INTERVAL_2h = '2h',
    INTERVAL_4h = '4h',
    INTERVAL_6h = '6h',
    INTERVAL_8h = '8h',
    INTERVAL_12h = '12h',
    INTERVAL_1d = '1d',
    INTERVAL_3d = '3d',
    INTERVAL_1w = '1w',
    INTERVAL_1M = '1M',
}

export enum TakerBuySellVolumePeriodEnum {
    PERIOD_5m = '5m',
    PERIOD_15m = '15m',
    PERIOD_30m = '30m',
    PERIOD_1h = '1h',
    PERIOD_2h = '2h',
    PERIOD_4h = '4h',
    PERIOD_6h = '6h',
    PERIOD_12h = '12h',
    PERIOD_1d = '1d',
}

export enum TopTraderLongShortRatioAccountsPeriodEnum {
    PERIOD_5m = '5m',
    PERIOD_15m = '15m',
    PERIOD_30m = '30m',
    PERIOD_1h = '1h',
    PERIOD_2h = '2h',
    PERIOD_4h = '4h',
    PERIOD_6h = '6h',
    PERIOD_12h = '12h',
    PERIOD_1d = '1d',
}

export enum TopTraderLongShortRatioPositionsPeriodEnum {
    PERIOD_5m = '5m',
    PERIOD_15m = '15m',
    PERIOD_30m = '30m',
    PERIOD_1h = '1h',
    PERIOD_2h = '2h',
    PERIOD_4h = '4h',
    PERIOD_6h = '6h',
    PERIOD_12h = '12h',
    PERIOD_1d = '1d',
}
