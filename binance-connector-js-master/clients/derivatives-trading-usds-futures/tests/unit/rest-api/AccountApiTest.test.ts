/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountInformationV2Request,
    AccountInformationV3Request,
    FuturesAccountBalanceV2Request,
    FuturesAccountBalanceV3Request,
    FuturesAccountConfigurationRequest,
    FuturesTradingQuantitativeRulesIndicatorsRequest,
    GetBnbBurnStatusRequest,
    GetCurrentMultiAssetsModeRequest,
    GetCurrentPositionModeRequest,
    GetDownloadIdForFuturesOrderHistoryRequest,
    GetDownloadIdForFuturesTradeHistoryRequest,
    GetDownloadIdForFuturesTransactionHistoryRequest,
    GetFuturesOrderHistoryDownloadLinkByIdRequest,
    GetFuturesTradeDownloadLinkByIdRequest,
    GetFuturesTransactionHistoryDownloadLinkByIdRequest,
    GetIncomeHistoryRequest,
    NotionalAndLeverageBracketsRequest,
    QueryUserRateLimitRequest,
    SymbolConfigurationRequest,
    ToggleBnbBurnOnFuturesTradeRequest,
    UserCommissionRateRequest,
} from '../../../src/rest-api';
import type {
    AccountInformationV2Response,
    AccountInformationV3Response,
    FuturesAccountBalanceV2Response,
    FuturesAccountBalanceV3Response,
    FuturesAccountConfigurationResponse,
    FuturesTradingQuantitativeRulesIndicatorsResponse,
    GetBnbBurnStatusResponse,
    GetCurrentMultiAssetsModeResponse,
    GetCurrentPositionModeResponse,
    GetDownloadIdForFuturesOrderHistoryResponse,
    GetDownloadIdForFuturesTradeHistoryResponse,
    GetDownloadIdForFuturesTransactionHistoryResponse,
    GetFuturesOrderHistoryDownloadLinkByIdResponse,
    GetFuturesTradeDownloadLinkByIdResponse,
    GetFuturesTransactionHistoryDownloadLinkByIdResponse,
    GetIncomeHistoryResponse,
    NotionalAndLeverageBracketsResponse,
    QueryUserRateLimitResponse,
    SymbolConfigurationResponse,
    ToggleBnbBurnOnFuturesTradeResponse,
    UserCommissionRateResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountInformationV2()', () => {
        it('should execute accountInformationV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    feeTier: 0,
                    feeBurn: true,
                    canDeposit: true,
                    canWithdraw: true,
                    updateTime: 0,
                    multiAssetsMargin: true,
                    tradeGroupId: -1,
                    totalInitialMargin: '0.00000000',
                    totalMaintMargin: '0.00000000',
                    totalWalletBalance: '126.72469206',
                    totalUnrealizedProfit: '0.00000000',
                    totalMarginBalance: '126.72469206',
                    totalPositionInitialMargin: '0.00000000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalCrossWalletBalance: '126.72469206',
                    totalCrossUnPnl: '0.00000000',
                    availableBalance: '126.72469206',
                    maxWithdrawAmount: '126.72469206',
                    assets: [
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '23.72469206',
                            maxWithdrawAmount: '23.72469206',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'BUSD',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '103.12345678',
                            maxWithdrawAmount: '103.12345678',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '23.72469206',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'BUSD',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '103.12345678',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '100',
                            isolated: true,
                            entryPrice: '0.00000',
                            maxNotional: '250000',
                            bidNotional: '0',
                            askNotional: '0',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '100',
                            isolated: true,
                            entryPrice: '0.00000',
                            maxNotional: '250000',
                            bidNotional: '0',
                            askNotional: '0',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                        },
                    ],
                    canTrade: true,
                })
            );

            const spy = jest.spyOn(client, 'accountInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV2Response>)
            );
            const response = await client.accountInformationV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInformationV2() successfully with optional parameters', async () => {
            const params: AccountInformationV2Request = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    feeTier: 0,
                    feeBurn: true,
                    canDeposit: true,
                    canWithdraw: true,
                    updateTime: 0,
                    multiAssetsMargin: true,
                    tradeGroupId: -1,
                    totalInitialMargin: '0.00000000',
                    totalMaintMargin: '0.00000000',
                    totalWalletBalance: '126.72469206',
                    totalUnrealizedProfit: '0.00000000',
                    totalMarginBalance: '126.72469206',
                    totalPositionInitialMargin: '0.00000000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalCrossWalletBalance: '126.72469206',
                    totalCrossUnPnl: '0.00000000',
                    availableBalance: '126.72469206',
                    maxWithdrawAmount: '126.72469206',
                    assets: [
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '23.72469206',
                            maxWithdrawAmount: '23.72469206',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'BUSD',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '103.12345678',
                            maxWithdrawAmount: '103.12345678',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '23.72469206',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'BUSD',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '103.12345678',
                            marginAvailable: true,
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '100',
                            isolated: true,
                            entryPrice: '0.00000',
                            maxNotional: '250000',
                            bidNotional: '0',
                            askNotional: '0',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '100',
                            isolated: true,
                            entryPrice: '0.00000',
                            maxNotional: '250000',
                            bidNotional: '0',
                            askNotional: '0',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                        },
                    ],
                    canTrade: true,
                })
            );

            const spy = jest.spyOn(client, 'accountInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV2Response>)
            );
            const response = await client.accountInformationV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInformationV2').mockRejectedValueOnce(mockError);
            await expect(client.accountInformationV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountInformationV3()', () => {
        it('should execute accountInformationV3() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    totalInitialMargin: '0.00000000',
                    totalMaintMargin: '0.00000000',
                    totalWalletBalance: '126.72469206',
                    totalUnrealizedProfit: '0.00000000',
                    totalMarginBalance: '126.72469206',
                    totalPositionInitialMargin: '0.00000000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalCrossWalletBalance: '126.72469206',
                    totalCrossUnPnl: '0.00000000',
                    availableBalance: '126.72469206',
                    maxWithdrawAmount: '126.72469206',
                    assets: [
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '23.72469206',
                            maxWithdrawAmount: '23.72469206',
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'USDC',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '103.12345678',
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '23.72469206',
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'BUSD',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '103.12345678',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'BOTH',
                            positionAmt: '1.000',
                            unrealizedProfit: '0.00000000',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'BOTH',
                            positionAmt: '1.000',
                            unrealizedProfit: '0.00000000',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            updateTime: 0,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'accountInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV3Response>)
            );
            const response = await client.accountInformationV3();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInformationV3() successfully with optional parameters', async () => {
            const params: AccountInformationV3Request = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalInitialMargin: '0.00000000',
                    totalMaintMargin: '0.00000000',
                    totalWalletBalance: '126.72469206',
                    totalUnrealizedProfit: '0.00000000',
                    totalMarginBalance: '126.72469206',
                    totalPositionInitialMargin: '0.00000000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalCrossWalletBalance: '126.72469206',
                    totalCrossUnPnl: '0.00000000',
                    availableBalance: '126.72469206',
                    maxWithdrawAmount: '126.72469206',
                    assets: [
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '23.72469206',
                            maxWithdrawAmount: '23.72469206',
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'USDC',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '103.12345678',
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'USDT',
                            walletBalance: '23.72469206',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '23.72469206',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '23.72469206',
                            updateTime: 1625474304765,
                        },
                        {
                            asset: 'BUSD',
                            walletBalance: '103.12345678',
                            unrealizedProfit: '0.00000000',
                            marginBalance: '103.12345678',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            crossWalletBalance: '103.12345678',
                            crossUnPnl: '0.00000000',
                            availableBalance: '126.72469206',
                            maxWithdrawAmount: '103.12345678',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'BOTH',
                            positionAmt: '1.000',
                            unrealizedProfit: '0.00000000',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'BOTH',
                            positionAmt: '1.000',
                            unrealizedProfit: '0.00000000',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            updateTime: 0,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'accountInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV3Response>)
            );
            const response = await client.accountInformationV3(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInformationV3').mockRejectedValueOnce(mockError);
            await expect(client.accountInformationV3()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountBalanceV2()', () => {
        it('should execute futuresAccountBalanceV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        accountAlias: 'SgsR',
                        asset: 'USDT',
                        balance: '122607.35137903',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        marginAvailable: true,
                        updateTime: 1617939110373,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'futuresAccountBalanceV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV2Response>)
            );
            const response = await client.futuresAccountBalanceV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountBalanceV2() successfully with optional parameters', async () => {
            const params: FuturesAccountBalanceV2Request = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        accountAlias: 'SgsR',
                        asset: 'USDT',
                        balance: '122607.35137903',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        marginAvailable: true,
                        updateTime: 1617939110373,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'futuresAccountBalanceV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV2Response>)
            );
            const response = await client.futuresAccountBalanceV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountBalanceV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountBalanceV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountBalanceV3()', () => {
        it('should execute futuresAccountBalanceV3() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        accountAlias: 'SgsR',
                        asset: 'USDT',
                        balance: '122607.35137903',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        marginAvailable: true,
                        updateTime: 1617939110373,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'futuresAccountBalanceV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV3Response>)
            );
            const response = await client.futuresAccountBalanceV3();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountBalanceV3() successfully with optional parameters', async () => {
            const params: FuturesAccountBalanceV3Request = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        accountAlias: 'SgsR',
                        asset: 'USDT',
                        balance: '122607.35137903',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        marginAvailable: true,
                        updateTime: 1617939110373,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'futuresAccountBalanceV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV3Response>)
            );
            const response = await client.futuresAccountBalanceV3(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountBalanceV3')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountBalanceV3()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountConfiguration()', () => {
        it('should execute futuresAccountConfiguration() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    feeTier: 0,
                    canTrade: true,
                    canDeposit: true,
                    canWithdraw: true,
                    dualSidePosition: true,
                    updateTime: 0,
                    multiAssetsMargin: false,
                    tradeGroupId: -1,
                })
            );

            const spy = jest.spyOn(client, 'futuresAccountConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountConfigurationResponse>)
            );
            const response = await client.futuresAccountConfiguration();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountConfiguration() successfully with optional parameters', async () => {
            const params: FuturesAccountConfigurationRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    feeTier: 0,
                    canTrade: true,
                    canDeposit: true,
                    canWithdraw: true,
                    dualSidePosition: true,
                    updateTime: 0,
                    multiAssetsMargin: false,
                    tradeGroupId: -1,
                })
            );

            const spy = jest.spyOn(client, 'futuresAccountConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountConfigurationResponse>)
            );
            const response = await client.futuresAccountConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountConfiguration')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountConfiguration()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresTradingQuantitativeRulesIndicators()', () => {
        it('should execute futuresTradingQuantitativeRulesIndicators() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    indicators: {
                        BTCUSDT: [
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'UFR',
                                value: 0.05,
                                triggerValue: 0.995,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'IFER',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'GCR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'DR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                        ],
                        ETHUSDT: [
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'UFR',
                                value: 0.05,
                                triggerValue: 0.995,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'IFER',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'GCR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'DR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                        ],
                        ACCOUNT: [
                            {
                                indicator: 'TMV',
                                value: 10,
                                triggerValue: 1,
                                plannedRecoverTime: 1644919865000,
                                isLocked: true,
                            },
                        ],
                    },
                    updateTime: 1644913304748,
                })
            );

            const spy = jest
                .spyOn(client, 'futuresTradingQuantitativeRulesIndicators')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<FuturesTradingQuantitativeRulesIndicatorsResponse>)
                );
            const response = await client.futuresTradingQuantitativeRulesIndicators();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresTradingQuantitativeRulesIndicators() successfully with optional parameters', async () => {
            const params: FuturesTradingQuantitativeRulesIndicatorsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    indicators: {
                        BTCUSDT: [
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'UFR',
                                value: 0.05,
                                triggerValue: 0.995,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'IFER',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'GCR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'DR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                        ],
                        ETHUSDT: [
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'UFR',
                                value: 0.05,
                                triggerValue: 0.995,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'IFER',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'GCR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'DR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                        ],
                        ACCOUNT: [
                            {
                                indicator: 'TMV',
                                value: 10,
                                triggerValue: 1,
                                plannedRecoverTime: 1644919865000,
                                isLocked: true,
                            },
                        ],
                    },
                    updateTime: 1644913304748,
                })
            );

            const spy = jest
                .spyOn(client, 'futuresTradingQuantitativeRulesIndicators')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<FuturesTradingQuantitativeRulesIndicatorsResponse>)
                );
            const response = await client.futuresTradingQuantitativeRulesIndicators(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresTradingQuantitativeRulesIndicators')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresTradingQuantitativeRulesIndicators()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getBnbBurnStatus()', () => {
        it('should execute getBnbBurnStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ feeBurn: true }));

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBnbBurnStatus() successfully with optional parameters', async () => {
            const params: GetBnbBurnStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ feeBurn: true }));

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockRejectedValueOnce(mockError);
            await expect(client.getBnbBurnStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCurrentMultiAssetsMode()', () => {
        it('should execute getCurrentMultiAssetsMode() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ multiAssetsMargin: true }));

            const spy = jest.spyOn(client, 'getCurrentMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentMultiAssetsModeResponse>)
            );
            const response = await client.getCurrentMultiAssetsMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCurrentMultiAssetsMode() successfully with optional parameters', async () => {
            const params: GetCurrentMultiAssetsModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ multiAssetsMargin: true }));

            const spy = jest.spyOn(client, 'getCurrentMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentMultiAssetsModeResponse>)
            );
            const response = await client.getCurrentMultiAssetsMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCurrentMultiAssetsMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCurrentMultiAssetsMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCurrentPositionMode()', () => {
        it('should execute getCurrentPositionMode() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ dualSidePosition: true }));

            const spy = jest.spyOn(client, 'getCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentPositionModeResponse>)
            );
            const response = await client.getCurrentPositionMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCurrentPositionMode() successfully with optional parameters', async () => {
            const params: GetCurrentPositionModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ dualSidePosition: true }));

            const spy = jest.spyOn(client, 'getCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentPositionModeResponse>)
            );
            const response = await client.getCurrentPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCurrentPositionMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCurrentPositionMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesOrderHistory()', () => {
        it('should execute getDownloadIdForFuturesOrderHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesOrderHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesOrderHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesTradeHistory()', () => {
        it('should execute getDownloadIdForFuturesTradeHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesTradeHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesTradeHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesTradeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTradeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesTransactionHistory()', () => {
        it('should execute getDownloadIdForFuturesTransactionHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesTransactionHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesTransactionHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesTransactionHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesOrderHistoryDownloadLinkById()', () => {
        it('should execute getFuturesOrderHistoryDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesOrderHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesOrderHistoryDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesOrderHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getFuturesOrderHistoryDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesOrderHistoryDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesOrderHistoryDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesTradeDownloadLinkById()', () => {
        it('should execute getFuturesTradeDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest.spyOn(client, 'getFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesTradeDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest.spyOn(client, 'getFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesTradeDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesTradeDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesTransactionHistoryDownloadLinkById()', () => {
        it('should execute getFuturesTransactionHistoryDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesTransactionHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesTransactionHistoryDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesTransactionHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(
                client.getFuturesTransactionHistoryDownloadLinkById(params)
            ).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesTransactionHistoryDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.getFuturesTransactionHistoryDownloadLinkById(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getIncomeHistory()', () => {
        it('should execute getIncomeHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: '',
                        incomeType: 'TRANSFER',
                        income: '-0.37500000',
                        asset: 'USDT',
                        info: 'TRANSFER',
                        time: 1570608000000,
                        tranId: 9689322392,
                        tradeId: '',
                    },
                    {
                        symbol: 'BTCUSDT',
                        incomeType: 'COMMISSION',
                        income: '-0.01000000',
                        asset: 'USDT',
                        info: 'COMMISSION',
                        time: 1570636800000,
                        tranId: 9689322392,
                        tradeId: '2059192',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetIncomeHistoryResponse>)
            );
            const response = await client.getIncomeHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getIncomeHistory() successfully with optional parameters', async () => {
            const params: GetIncomeHistoryRequest = {
                symbol: 'symbol_example',
                incomeType: 'incomeType_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: '',
                        incomeType: 'TRANSFER',
                        income: '-0.37500000',
                        asset: 'USDT',
                        info: 'TRANSFER',
                        time: 1570608000000,
                        tranId: 9689322392,
                        tradeId: '',
                    },
                    {
                        symbol: 'BTCUSDT',
                        incomeType: 'COMMISSION',
                        income: '-0.01000000',
                        asset: 'USDT',
                        info: 'COMMISSION',
                        time: 1570636800000,
                        tranId: 9689322392,
                        tradeId: '2059192',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetIncomeHistoryResponse>)
            );
            const response = await client.getIncomeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getIncomeHistory').mockRejectedValueOnce(mockError);
            await expect(client.getIncomeHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('notionalAndLeverageBrackets()', () => {
        it('should execute notionalAndLeverageBrackets() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ETHUSDT',
                        notionalCoef: 1.5,
                        brackets: [
                            {
                                bracket: 1,
                                initialLeverage: 75,
                                notionalCap: 10000,
                                notionalFloor: 0,
                                maintMarginRatio: 0.0065,
                                cum: 0,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'notionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalAndLeverageBracketsResponse>)
            );
            const response = await client.notionalAndLeverageBrackets();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute notionalAndLeverageBrackets() successfully with optional parameters', async () => {
            const params: NotionalAndLeverageBracketsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ETHUSDT',
                        notionalCoef: 1.5,
                        brackets: [
                            {
                                bracket: 1,
                                initialLeverage: 75,
                                notionalCap: 10000,
                                notionalFloor: 0,
                                maintMarginRatio: 0.0065,
                                cum: 0,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'notionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalAndLeverageBracketsResponse>)
            );
            const response = await client.notionalAndLeverageBrackets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'notionalAndLeverageBrackets')
                .mockRejectedValueOnce(mockError);
            await expect(client.notionalAndLeverageBrackets()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUserRateLimit()', () => {
        it('should execute queryUserRateLimit() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { rateLimitType: 'ORDERS', interval: 'SECOND', intervalNum: 10, limit: 10000 },
                    { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 20000 },
                ])
            );

            const spy = jest.spyOn(client, 'queryUserRateLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserRateLimitResponse>)
            );
            const response = await client.queryUserRateLimit();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserRateLimit() successfully with optional parameters', async () => {
            const params: QueryUserRateLimitRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { rateLimitType: 'ORDERS', interval: 'SECOND', intervalNum: 10, limit: 10000 },
                    { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 20000 },
                ])
            );

            const spy = jest.spyOn(client, 'queryUserRateLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserRateLimitResponse>)
            );
            const response = await client.queryUserRateLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryUserRateLimit').mockRejectedValueOnce(mockError);
            await expect(client.queryUserRateLimit()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolConfiguration()', () => {
        it('should execute symbolConfiguration() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        marginType: 'CROSSED',
                        isAutoAddMargin: false,
                        leverage: 21,
                        maxNotionalValue: '1000000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'symbolConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolConfigurationResponse>)
            );
            const response = await client.symbolConfiguration();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolConfiguration() successfully with optional parameters', async () => {
            const params: SymbolConfigurationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        marginType: 'CROSSED',
                        isAutoAddMargin: false,
                        leverage: 21,
                        maxNotionalValue: '1000000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'symbolConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolConfigurationResponse>)
            );
            const response = await client.symbolConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolConfiguration').mockRejectedValueOnce(mockError);
            await expect(client.symbolConfiguration()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('toggleBnbBurnOnFuturesTrade()', () => {
        it('should execute toggleBnbBurnOnFuturesTrade() successfully with required parameters only', async () => {
            const params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'toggleBnbBurnOnFuturesTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ToggleBnbBurnOnFuturesTradeResponse>)
            );
            const response = await client.toggleBnbBurnOnFuturesTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute toggleBnbBurnOnFuturesTrade() successfully with optional parameters', async () => {
            const params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'toggleBnbBurnOnFuturesTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ToggleBnbBurnOnFuturesTradeResponse>)
            );
            const response = await client.toggleBnbBurnOnFuturesTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when feeBurn is missing', async () => {
            const _params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.feeBurn;

            await expect(client.toggleBnbBurnOnFuturesTrade(params)).rejects.toThrow(
                'Required parameter feeBurn was null or undefined when calling toggleBnbBurnOnFuturesTrade.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnFuturesTrade')
                .mockRejectedValueOnce(mockError);
            await expect(client.toggleBnbBurnOnFuturesTrade(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('userCommissionRate()', () => {
        it('should execute userCommissionRate() successfully with required parameters only', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    makerCommissionRate: '0.0002',
                    takerCommissionRate: '0.0004',
                    rpiCommissionRate: '0.00005',
                })
            );

            const spy = jest.spyOn(client, 'userCommissionRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionRateResponse>)
            );
            const response = await client.userCommissionRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userCommissionRate() successfully with optional parameters', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    makerCommissionRate: '0.0002',
                    takerCommissionRate: '0.0004',
                    rpiCommissionRate: '0.00005',
                })
            );

            const spy = jest.spyOn(client, 'userCommissionRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionRateResponse>)
            );
            const response = await client.userCommissionRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.userCommissionRate(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling userCommissionRate.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userCommissionRate').mockRejectedValueOnce(mockError);
            await expect(client.userCommissionRate(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
