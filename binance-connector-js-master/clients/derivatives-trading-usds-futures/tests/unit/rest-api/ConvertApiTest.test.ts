/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { ConvertApi } from '../../../src/rest-api';
import {
    AcceptTheOfferedQuoteRequest,
    ListAllConvertPairsRequest,
    OrderStatusRequest,
    SendQuoteRequestRequest,
} from '../../../src/rest-api';
import type {
    AcceptTheOfferedQuoteResponse,
    ListAllConvertPairsResponse,
    OrderStatusResponse,
    SendQuoteRequestResponse,
} from '../../../src/rest-api/types';

describe('ConvertApi', () => {
    let client: ConvertApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new ConvertApi(config);
    });

    describe('acceptTheOfferedQuote()', () => {
        it('should execute acceptTheOfferedQuote() successfully with required parameters only', async () => {
            const params: AcceptTheOfferedQuoteRequest = {
                quoteId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: '933256278426274426',
                    createTime: 1623381330472,
                    orderStatus: 'PROCESS',
                })
            );

            const spy = jest.spyOn(client, 'acceptTheOfferedQuote').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AcceptTheOfferedQuoteResponse>)
            );
            const response = await client.acceptTheOfferedQuote(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute acceptTheOfferedQuote() successfully with optional parameters', async () => {
            const params: AcceptTheOfferedQuoteRequest = {
                quoteId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: '933256278426274426',
                    createTime: 1623381330472,
                    orderStatus: 'PROCESS',
                })
            );

            const spy = jest.spyOn(client, 'acceptTheOfferedQuote').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AcceptTheOfferedQuoteResponse>)
            );
            const response = await client.acceptTheOfferedQuote(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when quoteId is missing', async () => {
            const _params: AcceptTheOfferedQuoteRequest = {
                quoteId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.quoteId;

            await expect(client.acceptTheOfferedQuote(params)).rejects.toThrow(
                'Required parameter quoteId was null or undefined when calling acceptTheOfferedQuote.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AcceptTheOfferedQuoteRequest = {
                quoteId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'acceptTheOfferedQuote')
                .mockRejectedValueOnce(mockError);
            await expect(client.acceptTheOfferedQuote(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('listAllConvertPairs()', () => {
        it('should execute listAllConvertPairs() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        fromAsset: 'BTC',
                        toAsset: 'USDT',
                        fromAssetMinAmount: '0.0004',
                        fromAssetMaxAmount: '50',
                        toAssetMinAmount: '20',
                        toAssetMaxAmount: '2500000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'listAllConvertPairs').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ListAllConvertPairsResponse>)
            );
            const response = await client.listAllConvertPairs();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute listAllConvertPairs() successfully with optional parameters', async () => {
            const params: ListAllConvertPairsRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        fromAsset: 'BTC',
                        toAsset: 'USDT',
                        fromAssetMinAmount: '0.0004',
                        fromAssetMaxAmount: '50',
                        toAssetMinAmount: '20',
                        toAssetMaxAmount: '2500000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'listAllConvertPairs').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ListAllConvertPairsResponse>)
            );
            const response = await client.listAllConvertPairs(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'listAllConvertPairs').mockRejectedValueOnce(mockError);
            await expect(client.listAllConvertPairs()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderStatus()', () => {
        it('should execute orderStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 933256278426274400,
                    orderStatus: 'SUCCESS',
                    fromAsset: 'BTC',
                    fromAmount: '0.00054414',
                    toAsset: 'USDT',
                    toAmount: '20',
                    ratio: '36755',
                    inverseRatio: '0.00002721',
                    createTime: 1623381330472,
                })
            );

            const spy = jest.spyOn(client, 'orderStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderStatusResponse>)
            );
            const response = await client.orderStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderStatus() successfully with optional parameters', async () => {
            const params: OrderStatusRequest = {
                orderId: '1',
                quoteId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 933256278426274400,
                    orderStatus: 'SUCCESS',
                    fromAsset: 'BTC',
                    fromAmount: '0.00054414',
                    toAsset: 'USDT',
                    toAmount: '20',
                    ratio: '36755',
                    inverseRatio: '0.00002721',
                    createTime: 1623381330472,
                })
            );

            const spy = jest.spyOn(client, 'orderStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderStatusResponse>)
            );
            const response = await client.orderStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderStatus').mockRejectedValueOnce(mockError);
            await expect(client.orderStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sendQuoteRequest()', () => {
        it('should execute sendQuoteRequest() successfully with required parameters only', async () => {
            const params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    quoteId: '12415572564',
                    ratio: '38163.7',
                    inverseRatio: '0.0000262',
                    validTimestamp: 1623319461670,
                    toAmount: '3816.37',
                    fromAmount: '0.1',
                })
            );

            const spy = jest.spyOn(client, 'sendQuoteRequest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SendQuoteRequestResponse>)
            );
            const response = await client.sendQuoteRequest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sendQuoteRequest() successfully with optional parameters', async () => {
            const params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
                fromAmount: 1.0,
                toAmount: 1.0,
                validTime: '10s',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    quoteId: '12415572564',
                    ratio: '38163.7',
                    inverseRatio: '0.0000262',
                    validTimestamp: 1623319461670,
                    toAmount: '3816.37',
                    fromAmount: '0.1',
                })
            );

            const spy = jest.spyOn(client, 'sendQuoteRequest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SendQuoteRequestResponse>)
            );
            const response = await client.sendQuoteRequest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromAsset is missing', async () => {
            const _params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.fromAsset;

            await expect(client.sendQuoteRequest(params)).rejects.toThrow(
                'Required parameter fromAsset was null or undefined when calling sendQuoteRequest.'
            );
        });

        it('should throw RequiredError when toAsset is missing', async () => {
            const _params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.toAsset;

            await expect(client.sendQuoteRequest(params)).rejects.toThrow(
                'Required parameter toAsset was null or undefined when calling sendQuoteRequest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sendQuoteRequest').mockRejectedValueOnce(mockError);
            await expect(client.sendQuoteRequest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
