/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    ChangeMarginTypeMarginTypeEnum,
    ModifyIsolatedPositionMarginPositionSideEnum,
    ModifyOrderSideEnum,
    ModifyOrderPriceMatchEnum,
    NewAlgoOrderSideEnum,
    NewAlgoOrderPositionSideEnum,
    NewAlgoOrderTimeInForceEnum,
    NewAlgoOrderWorkingTypeEnum,
    NewAlgoOrderPriceMatchEnum,
    NewAlgoOrderSelfTradePreventionModeEnum,
    NewOrderSideEnum,
    NewOrderPositionSideEnum,
    NewOrderTimeInForceEnum,
    NewOrderNewOrderRespTypeEnum,
    NewOrderPriceMatchEnum,
    NewOrderSelfTradePreventionModeEnum,
    TestOrderSideEnum,
    TestOrderPositionSideEnum,
    TestOrderTimeInForceEnum,
    TestOrderWorkingTypeEnum,
    TestOrderNewOrderRespTypeEnum,
    TestOrderPriceMatchEnum,
    TestOrderSelfTradePreventionModeEnum,
    UsersForceOrdersAutoCloseTypeEnum,
} from '../../../src/rest-api';
import {
    AccountTradeListRequest,
    AllOrdersRequest,
    AutoCancelAllOpenOrdersRequest,
    CancelAlgoOrderRequest,
    CancelAllAlgoOpenOrdersRequest,
    CancelAllOpenOrdersRequest,
    CancelMultipleOrdersRequest,
    CancelOrderRequest,
    ChangeInitialLeverageRequest,
    ChangeMarginTypeRequest,
    ChangeMultiAssetsModeRequest,
    ChangePositionModeRequest,
    CurrentAllAlgoOpenOrdersRequest,
    CurrentAllOpenOrdersRequest,
    FuturesTradfiPerpsContractRequest,
    GetOrderModifyHistoryRequest,
    GetPositionMarginChangeHistoryRequest,
    ModifyIsolatedPositionMarginRequest,
    ModifyMultipleOrdersRequest,
    ModifyOrderRequest,
    NewAlgoOrderRequest,
    NewOrderRequest,
    PlaceMultipleOrdersRequest,
    PositionAdlQuantileEstimationRequest,
    PositionInformationV2Request,
    PositionInformationV3Request,
    QueryAlgoOrderRequest,
    QueryAllAlgoOrdersRequest,
    QueryCurrentOpenOrderRequest,
    QueryOrderRequest,
    TestOrderRequest,
    UsersForceOrdersRequest,
} from '../../../src/rest-api';
import type {
    AccountTradeListResponse,
    AllOrdersResponse,
    AutoCancelAllOpenOrdersResponse,
    CancelAlgoOrderResponse,
    CancelAllAlgoOpenOrdersResponse,
    CancelAllOpenOrdersResponse,
    CancelMultipleOrdersResponse,
    CancelOrderResponse,
    ChangeInitialLeverageResponse,
    ChangeMarginTypeResponse,
    ChangeMultiAssetsModeResponse,
    ChangePositionModeResponse,
    CurrentAllAlgoOpenOrdersResponse,
    CurrentAllOpenOrdersResponse,
    FuturesTradfiPerpsContractResponse,
    GetOrderModifyHistoryResponse,
    GetPositionMarginChangeHistoryResponse,
    ModifyIsolatedPositionMarginResponse,
    ModifyMultipleOrdersResponse,
    ModifyOrderResponse,
    NewAlgoOrderResponse,
    NewOrderResponse,
    PlaceMultipleOrdersResponse,
    PositionAdlQuantileEstimationResponse,
    PositionInformationV2Response,
    PositionInformationV3Response,
    QueryAlgoOrderResponse,
    QueryAllAlgoOrdersResponse,
    QueryCurrentOpenOrderResponse,
    QueryOrderResponse,
    TestOrderResponse,
    UsersForceOrdersResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('accountTradeList()', () => {
        it('should execute accountTradeList() successfully with required parameters only', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        buyer: false,
                        commission: '-0.07819010',
                        commissionAsset: 'USDT',
                        id: 698759,
                        maker: false,
                        orderId: 25851813,
                        price: '7819.01',
                        qty: '0.002',
                        quoteQty: '15.63802',
                        realizedPnl: '-0.91539999',
                        side: 'SELL',
                        positionSide: 'SHORT',
                        symbol: 'BTCUSDT',
                        time: 1569514978020,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountTradeList() successfully with optional parameters', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        buyer: false,
                        commission: '-0.07819010',
                        commissionAsset: 'USDT',
                        id: 698759,
                        maker: false,
                        orderId: 25851813,
                        price: '7819.01',
                        qty: '0.002',
                        quoteQty: '15.63802',
                        realizedPnl: '-0.91539999',
                        side: 'SELL',
                        positionSide: 'SHORT',
                        symbol: 'BTCUSDT',
                        time: 1569514978020,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AccountTradeListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.accountTradeList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling accountTradeList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountTradeList').mockRejectedValueOnce(mockError);
            await expect(client.accountTradeList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrders()', () => {
        it('should execute allOrders() successfully with required parameters only', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.00000',
                        clientOrderId: 'abc',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrders() successfully with optional parameters', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.00000',
                        clientOrderId: 'abc',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AllOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.allOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling allOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrders').mockRejectedValueOnce(mockError);
            await expect(client.allOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('autoCancelAllOpenOrders()', () => {
        it('should execute autoCancelAllOpenOrders() successfully with required parameters only', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };

            mockResponse = JSONParse(JSONStringify({ symbol: 'BTCUSDT', countdownTime: '100000' }));

            const spy = jest.spyOn(client, 'autoCancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AutoCancelAllOpenOrdersResponse>)
            );
            const response = await client.autoCancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute autoCancelAllOpenOrders() successfully with optional parameters', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ symbol: 'BTCUSDT', countdownTime: '100000' }));

            const spy = jest.spyOn(client, 'autoCancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AutoCancelAllOpenOrdersResponse>)
            );
            const response = await client.autoCancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling autoCancelAllOpenOrders.'
            );
        });

        it('should throw RequiredError when countdownTime is missing', async () => {
            const _params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.countdownTime;

            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter countdownTime was null or undefined when calling autoCancelAllOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'autoCancelAllOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAlgoOrder()', () => {
        it('should execute cancelAlgoOrder() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    algoId: 2146760,
                    clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                    code: '200',
                    msg: 'success',
                })
            );

            const spy = jest.spyOn(client, 'cancelAlgoOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAlgoOrderResponse>)
            );
            const response = await client.cancelAlgoOrder();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAlgoOrder() successfully with optional parameters', async () => {
            const params: CancelAlgoOrderRequest = {
                algoId: 1,
                clientAlgoId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    algoId: 2146760,
                    clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                    code: '200',
                    msg: 'success',
                })
            );

            const spy = jest.spyOn(client, 'cancelAlgoOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAlgoOrderResponse>)
            );
            const response = await client.cancelAlgoOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelAlgoOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelAlgoOrder()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAllAlgoOpenOrders()', () => {
        it('should execute cancelAllAlgoOpenOrders() successfully with required parameters only', async () => {
            const params: CancelAllAlgoOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ code: 200, msg: 'The operation of cancel all open order is done.' })
            );

            const spy = jest.spyOn(client, 'cancelAllAlgoOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllAlgoOpenOrdersResponse>)
            );
            const response = await client.cancelAllAlgoOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllAlgoOpenOrders() successfully with optional parameters', async () => {
            const params: CancelAllAlgoOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ code: 200, msg: 'The operation of cancel all open order is done.' })
            );

            const spy = jest.spyOn(client, 'cancelAllAlgoOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllAlgoOpenOrdersResponse>)
            );
            const response = await client.cancelAllAlgoOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllAlgoOpenOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllAlgoOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllAlgoOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllAlgoOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllAlgoOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllAlgoOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAllOpenOrders()', () => {
        it('should execute cancelAllOpenOrders() successfully with required parameters only', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ code: 200, msg: 'The operation of cancel all open order is done.' })
            );

            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOpenOrdersResponse>)
            );
            const response = await client.cancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllOpenOrders() successfully with optional parameters', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ code: 200, msg: 'The operation of cancel all open order is done.' })
            );

            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOpenOrdersResponse>)
            );
            const response = await client.cancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.cancelAllOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelMultipleOrders()', () => {
        it('should execute cancelMultipleOrders() successfully with required parameters only', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        clientOrderId: 'myOrder1',
                        cumQty: '0',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 283194212,
                        origQty: '11',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'CANCELED',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1571110484038,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 1693207680000,
                    },
                    { code: -2011, msg: 'Unknown order sent.' },
                ])
            );

            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOrdersResponse>)
            );
            const response = await client.cancelMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMultipleOrders() successfully with optional parameters', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
                orderIdList: [1234567],
                origClientOrderIdList: ['my_id_1'],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        clientOrderId: 'myOrder1',
                        cumQty: '0',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 283194212,
                        origQty: '11',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'CANCELED',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1571110484038,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 1693207680000,
                    },
                    { code: -2011, msg: 'Unknown order sent.' },
                ])
            );

            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOrdersResponse>)
            );
            const response = await client.cancelMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMultipleOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.cancelMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelOrder()', () => {
        it('should execute cancelOrder() successfully with required parameters only', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'myOrder1',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 283194212,
                    origQty: '11',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'CANCELED',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1571110484038,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                })
            );

            const spy = jest.spyOn(client, 'cancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOrderResponse>)
            );
            const response = await client.cancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelOrder() successfully with optional parameters', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'myOrder1',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 283194212,
                    origQty: '11',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'CANCELED',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1571110484038,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                })
            );

            const spy = jest.spyOn(client, 'cancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOrderResponse>)
            );
            const response = await client.cancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeInitialLeverage()', () => {
        it('should execute changeInitialLeverage() successfully with required parameters only', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxNotionalValue: '1000000', symbol: 'BTCUSDT' })
            );

            const spy = jest.spyOn(client, 'changeInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeInitialLeverageResponse>)
            );
            const response = await client.changeInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeInitialLeverage() successfully with optional parameters', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxNotionalValue: '1000000', symbol: 'BTCUSDT' })
            );

            const spy = jest.spyOn(client, 'changeInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeInitialLeverageResponse>)
            );
            const response = await client.changeInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeInitialLeverage(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeInitialLeverage.'
            );
        });

        it('should throw RequiredError when leverage is missing', async () => {
            const _params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.leverage;

            await expect(client.changeInitialLeverage(params)).rejects.toThrow(
                'Required parameter leverage was null or undefined when calling changeInitialLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeInitialLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeInitialLeverage(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeMarginType()', () => {
        it('should execute changeMarginType() successfully with required parameters only', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeMarginType').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMarginTypeResponse>)
            );
            const response = await client.changeMarginType(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeMarginType() successfully with optional parameters', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeMarginType').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMarginTypeResponse>)
            );
            const response = await client.changeMarginType(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeMarginType(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeMarginType.'
            );
        });

        it('should throw RequiredError when marginType is missing', async () => {
            const _params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };
            const params = Object.assign({ ..._params });
            delete params?.marginType;

            await expect(client.changeMarginType(params)).rejects.toThrow(
                'Required parameter marginType was null or undefined when calling changeMarginType.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changeMarginType').mockRejectedValueOnce(mockError);
            await expect(client.changeMarginType(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeMultiAssetsMode()', () => {
        it('should execute changeMultiAssetsMode() successfully with required parameters only', async () => {
            const params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMultiAssetsModeResponse>)
            );
            const response = await client.changeMultiAssetsMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeMultiAssetsMode() successfully with optional parameters', async () => {
            const params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMultiAssetsModeResponse>)
            );
            const response = await client.changeMultiAssetsMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when multiAssetsMargin is missing', async () => {
            const _params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.multiAssetsMargin;

            await expect(client.changeMultiAssetsMode(params)).rejects.toThrow(
                'Required parameter multiAssetsMargin was null or undefined when calling changeMultiAssetsMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeMultiAssetsMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeMultiAssetsMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changePositionMode()', () => {
        it('should execute changePositionMode() successfully with required parameters only', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changePositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePositionModeResponse>)
            );
            const response = await client.changePositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changePositionMode() successfully with optional parameters', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changePositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePositionModeResponse>)
            );
            const response = await client.changePositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when dualSidePosition is missing', async () => {
            const _params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.dualSidePosition;

            await expect(client.changePositionMode(params)).rejects.toThrow(
                'Required parameter dualSidePosition was null or undefined when calling changePositionMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changePositionMode').mockRejectedValueOnce(mockError);
            await expect(client.changePositionMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('currentAllAlgoOpenOrders()', () => {
        it('should execute currentAllAlgoOpenOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        algoId: 2148627,
                        clientAlgoId: 'MRumok0dkhrP4kCm12AHaB',
                        algoType: 'CONDITIONAL',
                        orderType: 'TAKE_PROFIT',
                        symbol: 'BNBUSDT',
                        side: 'SELL',
                        positionSide: 'BOTH',
                        timeInForce: 'GTC',
                        quantity: '0.01',
                        algoStatus: 'NEW',
                        actualOrderId: '',
                        actualPrice: '0.00000',
                        triggerPrice: '750.000',
                        price: '750.000',
                        icebergQuantity: null,
                        tpTriggerPrice: '0.000',
                        tpPrice: '0.000',
                        slTriggerPrice: '0.000',
                        slPrice: '0.000',
                        tpOrderType: '',
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        workingType: 'CONTRACT_PRICE',
                        priceMatch: 'NONE',
                        closePosition: false,
                        priceProtect: false,
                        reduceOnly: false,
                        createTime: 1750514941540,
                        updateTime: 1750514941540,
                        triggerTime: 0,
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'currentAllAlgoOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllAlgoOpenOrdersResponse>)
            );
            const response = await client.currentAllAlgoOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute currentAllAlgoOpenOrders() successfully with optional parameters', async () => {
            const params: CurrentAllAlgoOpenOrdersRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                algoId: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        algoId: 2148627,
                        clientAlgoId: 'MRumok0dkhrP4kCm12AHaB',
                        algoType: 'CONDITIONAL',
                        orderType: 'TAKE_PROFIT',
                        symbol: 'BNBUSDT',
                        side: 'SELL',
                        positionSide: 'BOTH',
                        timeInForce: 'GTC',
                        quantity: '0.01',
                        algoStatus: 'NEW',
                        actualOrderId: '',
                        actualPrice: '0.00000',
                        triggerPrice: '750.000',
                        price: '750.000',
                        icebergQuantity: null,
                        tpTriggerPrice: '0.000',
                        tpPrice: '0.000',
                        slTriggerPrice: '0.000',
                        slPrice: '0.000',
                        tpOrderType: '',
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        workingType: 'CONTRACT_PRICE',
                        priceMatch: 'NONE',
                        closePosition: false,
                        priceProtect: false,
                        reduceOnly: false,
                        createTime: 1750514941540,
                        updateTime: 1750514941540,
                        triggerTime: 0,
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'currentAllAlgoOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllAlgoOpenOrdersResponse>)
            );
            const response = await client.currentAllAlgoOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'currentAllAlgoOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.currentAllAlgoOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('currentAllOpenOrders()', () => {
        it('should execute currentAllOpenOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.00000',
                        clientOrderId: 'abc',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllOpenOrdersResponse>)
            );
            const response = await client.currentAllOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute currentAllOpenOrders() successfully with optional parameters', async () => {
            const params: CurrentAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        avgPrice: '0.00000',
                        clientOrderId: 'abc',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllOpenOrdersResponse>)
            );
            const response = await client.currentAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.currentAllOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresTradfiPerpsContract()', () => {
        it('should execute futuresTradfiPerpsContract() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'futuresTradfiPerpsContract').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesTradfiPerpsContractResponse>)
            );
            const response = await client.futuresTradfiPerpsContract();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresTradfiPerpsContract() successfully with optional parameters', async () => {
            const params: FuturesTradfiPerpsContractRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'futuresTradfiPerpsContract').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesTradfiPerpsContractResponse>)
            );
            const response = await client.futuresTradfiPerpsContract(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresTradfiPerpsContract')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresTradfiPerpsContract()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderModifyHistory()', () => {
        it('should execute getOrderModifyHistory() successfully with required parameters only', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        amendmentId: 5363,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184560899,
                        amendment: {
                            price: { before: '30004', after: '30003.2' },
                            origQty: { before: '1', after: '1' },
                            count: 3,
                        },
                    },
                    {
                        amendmentId: 5361,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184533946,
                        amendment: {
                            price: { before: '30005', after: '30004' },
                            origQty: { before: '1', after: '1' },
                            count: 2,
                        },
                    },
                    {
                        amendmentId: 5325,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629182711787,
                        amendment: {
                            price: { before: '30002', after: '30005' },
                            origQty: { before: '1', after: '1' },
                            count: 1,
                        },
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getOrderModifyHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderModifyHistoryResponse>)
            );
            const response = await client.getOrderModifyHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderModifyHistory() successfully with optional parameters', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        amendmentId: 5363,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184560899,
                        amendment: {
                            price: { before: '30004', after: '30003.2' },
                            origQty: { before: '1', after: '1' },
                            count: 3,
                        },
                    },
                    {
                        amendmentId: 5361,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629184533946,
                        amendment: {
                            price: { before: '30005', after: '30004' },
                            origQty: { before: '1', after: '1' },
                            count: 2,
                        },
                    },
                    {
                        amendmentId: 5325,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        orderId: 20072994037,
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        time: 1629182711787,
                        amendment: {
                            price: { before: '30002', after: '30005' },
                            origQty: { before: '1', after: '1' },
                            count: 1,
                        },
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getOrderModifyHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderModifyHistoryResponse>)
            );
            const response = await client.getOrderModifyHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getOrderModifyHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getOrderModifyHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOrderModifyHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOrderModifyHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getPositionMarginChangeHistory()', () => {
        it('should execute getPositionMarginChangeHistory() successfully with required parameters only', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        type: 1,
                        deltaType: 'USER_ADJUST',
                        amount: '23.36332311',
                        asset: 'USDT',
                        time: 1578047897183,
                        positionSide: 'BOTH',
                    },
                    {
                        symbol: 'BTCUSDT',
                        type: 1,
                        deltaType: 'USER_ADJUST',
                        amount: '100',
                        asset: 'USDT',
                        time: 1578047900425,
                        positionSide: 'LONG',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getPositionMarginChangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPositionMarginChangeHistoryResponse>)
            );
            const response = await client.getPositionMarginChangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPositionMarginChangeHistory() successfully with optional parameters', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
                type: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        type: 1,
                        deltaType: 'USER_ADJUST',
                        amount: '23.36332311',
                        asset: 'USDT',
                        time: 1578047897183,
                        positionSide: 'BOTH',
                    },
                    {
                        symbol: 'BTCUSDT',
                        type: 1,
                        deltaType: 'USER_ADJUST',
                        amount: '100',
                        asset: 'USDT',
                        time: 1578047900425,
                        positionSide: 'LONG',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getPositionMarginChangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPositionMarginChangeHistoryResponse>)
            );
            const response = await client.getPositionMarginChangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getPositionMarginChangeHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getPositionMarginChangeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPositionMarginChangeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPositionMarginChangeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('modifyIsolatedPositionMargin()', () => {
        it('should execute modifyIsolatedPositionMargin() successfully with required parameters only', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    amount: 100,
                    code: 200,
                    msg: 'Successfully modify position margin.',
                    type: 1,
                })
            );

            const spy = jest.spyOn(client, 'modifyIsolatedPositionMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyIsolatedPositionMarginResponse>)
            );
            const response = await client.modifyIsolatedPositionMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyIsolatedPositionMargin() successfully with optional parameters', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: 'type_example',
                positionSide: ModifyIsolatedPositionMarginPositionSideEnum.BOTH,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    amount: 100,
                    code: 200,
                    msg: 'Successfully modify position margin.',
                    type: 1,
                })
            );

            const spy = jest.spyOn(client, 'modifyIsolatedPositionMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyIsolatedPositionMarginResponse>)
            );
            const response = await client.modifyIsolatedPositionMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1.0,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'modifyIsolatedPositionMargin')
                .mockRejectedValueOnce(mockError);
            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('modifyMultipleOrders()', () => {
        it('should execute modifyMultipleOrders() successfully with required parameters only', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 20072994037,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        status: 'NEW',
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        price: '30005',
                        avgPrice: '0.0',
                        origQty: '1',
                        executedQty: '0',
                        cumQty: '0',
                        cumBase: '0',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'LONG',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                        updateTime: 1629182711600,
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyMultipleOrdersResponse>)
            );
            const response = await client.modifyMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyMultipleOrders() successfully with optional parameters', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 20072994037,
                        symbol: 'BTCUSDT',
                        pair: 'BTCUSDT',
                        status: 'NEW',
                        clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                        price: '30005',
                        avgPrice: '0.0',
                        origQty: '1',
                        executedQty: '0',
                        cumQty: '0',
                        cumBase: '0',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'LONG',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                        updateTime: 1629182711600,
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyMultipleOrdersResponse>)
            );
            const response = await client.modifyMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when batchOrders is missing', async () => {
            const _params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.batchOrders;

            await expect(client.modifyMultipleOrders(params)).rejects.toThrow(
                'Required parameter batchOrders was null or undefined when calling modifyMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.modifyMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('modifyOrder()', () => {
        it('should execute modifyOrder() successfully with required parameters only', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 20072994037,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    status: 'NEW',
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    price: '30005',
                    avgPrice: '0.0',
                    origQty: '1',
                    executedQty: '0',
                    cumQty: '0',
                    cumBase: '0',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'LONG',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    origType: 'LIMIT',
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    updateTime: 1629182711600,
                })
            );

            const spy = jest.spyOn(client, 'modifyOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyOrderResponse>)
            );
            const response = await client.modifyOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyOrder() successfully with optional parameters', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                orderId: 1,
                origClientOrderId: '1',
                priceMatch: ModifyOrderPriceMatchEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 20072994037,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    status: 'NEW',
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    price: '30005',
                    avgPrice: '0.0',
                    origQty: '1',
                    executedQty: '0',
                    cumQty: '0',
                    cumBase: '0',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'LONG',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    origType: 'LIMIT',
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    updateTime: 1629182711600,
                })
            );

            const spy = jest.spyOn(client, 'modifyOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyOrderResponse>)
            );
            const response = await client.modifyOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyOrder').mockRejectedValueOnce(mockError);
            await expect(client.modifyOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newAlgoOrder()', () => {
        it('should execute newAlgoOrder() successfully with required parameters only', async () => {
            const params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    algoId: 2146760,
                    clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                    algoType: 'CONDITIONAL',
                    orderType: 'TAKE_PROFIT',
                    symbol: 'BNBUSDT',
                    side: 'SELL',
                    positionSide: 'BOTH',
                    timeInForce: 'GTC',
                    quantity: '0.01',
                    algoStatus: 'NEW',
                    triggerPrice: '750.000',
                    price: '750.000',
                    icebergQuantity: null,
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    workingType: 'CONTRACT_PRICE',
                    priceMatch: 'NONE',
                    closePosition: false,
                    priceProtect: false,
                    reduceOnly: false,
                    activatePrice: '',
                    callbackRate: '',
                    createTime: 1750485492076,
                    updateTime: 1750485492076,
                    triggerTime: 0,
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'newAlgoOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewAlgoOrderResponse>)
            );
            const response = await client.newAlgoOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newAlgoOrder() successfully with optional parameters', async () => {
            const params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
                positionSide: NewAlgoOrderPositionSideEnum.BOTH,
                timeInForce: NewAlgoOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                price: 1.0,
                triggerPrice: 1.0,
                workingType: NewAlgoOrderWorkingTypeEnum.MARK_PRICE,
                priceMatch: NewAlgoOrderPriceMatchEnum.NONE,
                closePosition: 'closePosition_example',
                priceProtect: 'false',
                reduceOnly: 'false',
                activatePrice: 1.0,
                callbackRate: 1.0,
                clientAlgoId: '1',
                selfTradePreventionMode: NewAlgoOrderSelfTradePreventionModeEnum.EXPIRE_TAKER,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    algoId: 2146760,
                    clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                    algoType: 'CONDITIONAL',
                    orderType: 'TAKE_PROFIT',
                    symbol: 'BNBUSDT',
                    side: 'SELL',
                    positionSide: 'BOTH',
                    timeInForce: 'GTC',
                    quantity: '0.01',
                    algoStatus: 'NEW',
                    triggerPrice: '750.000',
                    price: '750.000',
                    icebergQuantity: null,
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    workingType: 'CONTRACT_PRICE',
                    priceMatch: 'NONE',
                    closePosition: false,
                    priceProtect: false,
                    reduceOnly: false,
                    activatePrice: '',
                    callbackRate: '',
                    createTime: 1750485492076,
                    updateTime: 1750485492076,
                    triggerTime: 0,
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'newAlgoOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewAlgoOrderResponse>)
            );
            const response = await client.newAlgoOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algoType is missing', async () => {
            const _params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algoType;

            await expect(client.newAlgoOrder(params)).rejects.toThrow(
                'Required parameter algoType was null or undefined when calling newAlgoOrder.'
            );
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newAlgoOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newAlgoOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newAlgoOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newAlgoOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newAlgoOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newAlgoOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newAlgoOrder').mockRejectedValueOnce(mockError);
            await expect(client.newAlgoOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.00000',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTD',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
                positionSide: NewOrderPositionSideEnum.BOTH,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                reduceOnly: 'false',
                price: 1.0,
                newClientOrderId: '1',
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                priceMatch: NewOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: NewOrderSelfTradePreventionModeEnum.EXPIRE_TAKER,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.00000',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTD',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('placeMultipleOrders()', () => {
        it('should execute placeMultipleOrders() successfully with required parameters only', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        clientOrderId: 'testOrder',
                        cumQty: '0',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 22542179,
                        avgPrice: '0.00000',
                        origQty: '10',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '0',
                        symbol: 'BTCUSDT',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        origType: 'TRAILING_STOP_MARKET',
                        updateTime: 1566818724722,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 1693207680000,
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute placeMultipleOrders() successfully with optional parameters', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        clientOrderId: 'testOrder',
                        cumQty: '0',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 22542179,
                        avgPrice: '0.00000',
                        origQty: '10',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '0',
                        symbol: 'BTCUSDT',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        origType: 'TRAILING_STOP_MARKET',
                        updateTime: 1566818724722,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 1693207680000,
                    },
                    { code: -2022, msg: 'ReduceOnly Order is rejected.' },
                ])
            );

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when batchOrders is missing', async () => {
            const _params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.batchOrders;

            await expect(client.placeMultipleOrders(params)).rejects.toThrow(
                'Required parameter batchOrders was null or undefined when calling placeMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'placeMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.placeMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionAdlQuantileEstimation()', () => {
        it('should execute positionAdlQuantileEstimation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'ETHUSDT', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                    { symbol: 'BTCUSDT', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
                ])
            );

            const spy = jest.spyOn(client, 'positionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionAdlQuantileEstimationResponse>)
            );
            const response = await client.positionAdlQuantileEstimation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionAdlQuantileEstimation() successfully with optional parameters', async () => {
            const params: PositionAdlQuantileEstimationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'ETHUSDT', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                    { symbol: 'BTCUSDT', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
                ])
            );

            const spy = jest.spyOn(client, 'positionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionAdlQuantileEstimationResponse>)
            );
            const response = await client.positionAdlQuantileEstimation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionAdlQuantileEstimation')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionAdlQuantileEstimation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionInformationV2()', () => {
        it('should execute positionInformationV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '0.00000',
                        breakEvenPrice: '0.0',
                        marginType: 'isolated',
                        isAutoAddMargin: 'false',
                        isolatedMargin: '0.00000000',
                        leverage: '10',
                        liquidationPrice: '0',
                        markPrice: '6679.50671178',
                        maxNotionalValue: '20000000',
                        positionAmt: '0.000',
                        notional: '0',
                        isolatedWallet: '0',
                        symbol: 'BTCUSDT',
                        unRealizedProfit: '0.00000000',
                        positionSide: 'BOTH',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.001',
                        entryPrice: '22185.2',
                        breakEvenPrice: '0.0',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '-1.06214947',
                        liquidationPrice: '19731.45529116',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'LONG',
                        notional: '21.12305052',
                        isolatedWallet: '0',
                        updateTime: 1655217461579,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.000',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '0',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'SHORT',
                        notional: '0',
                        isolatedWallet: '0',
                        updateTime: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'positionInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV2Response>)
            );
            const response = await client.positionInformationV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionInformationV2() successfully with optional parameters', async () => {
            const params: PositionInformationV2Request = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '0.00000',
                        breakEvenPrice: '0.0',
                        marginType: 'isolated',
                        isAutoAddMargin: 'false',
                        isolatedMargin: '0.00000000',
                        leverage: '10',
                        liquidationPrice: '0',
                        markPrice: '6679.50671178',
                        maxNotionalValue: '20000000',
                        positionAmt: '0.000',
                        notional: '0',
                        isolatedWallet: '0',
                        symbol: 'BTCUSDT',
                        unRealizedProfit: '0.00000000',
                        positionSide: 'BOTH',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.001',
                        entryPrice: '22185.2',
                        breakEvenPrice: '0.0',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '-1.06214947',
                        liquidationPrice: '19731.45529116',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'LONG',
                        notional: '21.12305052',
                        isolatedWallet: '0',
                        updateTime: 1655217461579,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.000',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '0',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        marginType: 'cross',
                        isolatedMargin: '0.00000000',
                        isAutoAddMargin: 'false',
                        positionSide: 'SHORT',
                        notional: '0',
                        isolatedWallet: '0',
                        updateTime: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'positionInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV2Response>)
            );
            const response = await client.positionInformationV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionInformationV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionInformationV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionInformationV3()', () => {
        it('should execute positionInformationV3() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ADAUSDT',
                        positionSide: 'BOTH',
                        positionAmt: '30',
                        entryPrice: '0.385',
                        breakEvenPrice: '0.385077',
                        markPrice: '0.41047590',
                        unRealizedProfit: '0.76427700',
                        liquidationPrice: '0',
                        isolatedMargin: '0',
                        notional: '12.31427700',
                        marginAsset: 'USDT',
                        isolatedWallet: '0',
                        initialMargin: '0.61571385',
                        maintMargin: '0.08004280',
                        positionInitialMargin: '0.61571385',
                        openOrderInitialMargin: '0',
                        adl: 2,
                        bidNotional: '0',
                        askNotional: '0',
                        updateTime: 1720736417660,
                    },
                    {
                        symbol: 'ADAUSDT',
                        positionSide: 'LONG',
                        positionAmt: '30',
                        entryPrice: '0.385',
                        breakEvenPrice: '0.385077',
                        markPrice: '0.41047590',
                        unRealizedProfit: '0.76427700',
                        liquidationPrice: '0',
                        isolatedMargin: '0',
                        notional: '12.31427700',
                        marginAsset: 'USDT',
                        isolatedWallet: '0',
                        initialMargin: '0.61571385',
                        maintMargin: '0.08004280',
                        positionInitialMargin: '0.61571385',
                        openOrderInitialMargin: '0',
                        adl: 2,
                        bidNotional: '0',
                        askNotional: '0',
                        updateTime: 1720736417660,
                    },
                    {
                        symbol: 'COMPUSDT',
                        positionSide: 'SHORT',
                        positionAmt: '-1.000',
                        entryPrice: '70.92841',
                        breakEvenPrice: '70.900038636',
                        markPrice: '49.72023376',
                        unRealizedProfit: '21.20817624',
                        liquidationPrice: '2260.56757210',
                        isolatedMargin: '0',
                        notional: '-49.72023376',
                        marginAsset: 'USDT',
                        isolatedWallet: '0',
                        initialMargin: '2.48601168',
                        maintMargin: '0.49720233',
                        positionInitialMargin: '2.48601168',
                        openOrderInitialMargin: '0',
                        adl: 2,
                        bidNotional: '0',
                        askNotional: '0',
                        updateTime: 1708943511656,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'positionInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV3Response>)
            );
            const response = await client.positionInformationV3();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionInformationV3() successfully with optional parameters', async () => {
            const params: PositionInformationV3Request = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ADAUSDT',
                        positionSide: 'BOTH',
                        positionAmt: '30',
                        entryPrice: '0.385',
                        breakEvenPrice: '0.385077',
                        markPrice: '0.41047590',
                        unRealizedProfit: '0.76427700',
                        liquidationPrice: '0',
                        isolatedMargin: '0',
                        notional: '12.31427700',
                        marginAsset: 'USDT',
                        isolatedWallet: '0',
                        initialMargin: '0.61571385',
                        maintMargin: '0.08004280',
                        positionInitialMargin: '0.61571385',
                        openOrderInitialMargin: '0',
                        adl: 2,
                        bidNotional: '0',
                        askNotional: '0',
                        updateTime: 1720736417660,
                    },
                    {
                        symbol: 'ADAUSDT',
                        positionSide: 'LONG',
                        positionAmt: '30',
                        entryPrice: '0.385',
                        breakEvenPrice: '0.385077',
                        markPrice: '0.41047590',
                        unRealizedProfit: '0.76427700',
                        liquidationPrice: '0',
                        isolatedMargin: '0',
                        notional: '12.31427700',
                        marginAsset: 'USDT',
                        isolatedWallet: '0',
                        initialMargin: '0.61571385',
                        maintMargin: '0.08004280',
                        positionInitialMargin: '0.61571385',
                        openOrderInitialMargin: '0',
                        adl: 2,
                        bidNotional: '0',
                        askNotional: '0',
                        updateTime: 1720736417660,
                    },
                    {
                        symbol: 'COMPUSDT',
                        positionSide: 'SHORT',
                        positionAmt: '-1.000',
                        entryPrice: '70.92841',
                        breakEvenPrice: '70.900038636',
                        markPrice: '49.72023376',
                        unRealizedProfit: '21.20817624',
                        liquidationPrice: '2260.56757210',
                        isolatedMargin: '0',
                        notional: '-49.72023376',
                        marginAsset: 'USDT',
                        isolatedWallet: '0',
                        initialMargin: '2.48601168',
                        maintMargin: '0.49720233',
                        positionInitialMargin: '2.48601168',
                        openOrderInitialMargin: '0',
                        adl: 2,
                        bidNotional: '0',
                        askNotional: '0',
                        updateTime: 1708943511656,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'positionInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV3Response>)
            );
            const response = await client.positionInformationV3(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionInformationV3')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionInformationV3()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAlgoOrder()', () => {
        it('should execute queryAlgoOrder() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    algoId: 2146760,
                    clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                    algoType: 'CONDITIONAL',
                    orderType: 'TAKE_PROFIT',
                    symbol: 'BNBUSDT',
                    side: 'SELL',
                    positionSide: 'BOTH',
                    timeInForce: 'GTC',
                    quantity: '0.01',
                    algoStatus: 'CANCELED',
                    actualOrderId: '',
                    actualPrice: '0.00000',
                    triggerPrice: '750.000',
                    price: '750.000',
                    icebergQuantity: null,
                    tpTriggerPrice: '0.000',
                    tpPrice: '0.000',
                    slTriggerPrice: '0.000',
                    slPrice: '0.000',
                    tpOrderType: '',
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    workingType: 'CONTRACT_PRICE',
                    priceMatch: 'NONE',
                    closePosition: false,
                    priceProtect: false,
                    reduceOnly: false,
                    createTime: 1750485492076,
                    updateTime: 1750514545091,
                    triggerTime: 0,
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'queryAlgoOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAlgoOrderResponse>)
            );
            const response = await client.queryAlgoOrder();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAlgoOrder() successfully with optional parameters', async () => {
            const params: QueryAlgoOrderRequest = {
                algoId: 1,
                clientAlgoId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    algoId: 2146760,
                    clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                    algoType: 'CONDITIONAL',
                    orderType: 'TAKE_PROFIT',
                    symbol: 'BNBUSDT',
                    side: 'SELL',
                    positionSide: 'BOTH',
                    timeInForce: 'GTC',
                    quantity: '0.01',
                    algoStatus: 'CANCELED',
                    actualOrderId: '',
                    actualPrice: '0.00000',
                    triggerPrice: '750.000',
                    price: '750.000',
                    icebergQuantity: null,
                    tpTriggerPrice: '0.000',
                    tpPrice: '0.000',
                    slTriggerPrice: '0.000',
                    slPrice: '0.000',
                    tpOrderType: '',
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    workingType: 'CONTRACT_PRICE',
                    priceMatch: 'NONE',
                    closePosition: false,
                    priceProtect: false,
                    reduceOnly: false,
                    createTime: 1750485492076,
                    updateTime: 1750514545091,
                    triggerTime: 0,
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'queryAlgoOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAlgoOrderResponse>)
            );
            const response = await client.queryAlgoOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryAlgoOrder').mockRejectedValueOnce(mockError);
            await expect(client.queryAlgoOrder()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllAlgoOrders()', () => {
        it('should execute queryAllAlgoOrders() successfully with required parameters only', async () => {
            const params: QueryAllAlgoOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        algoId: 2146760,
                        clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                        algoType: 'CONDITIONAL',
                        orderType: 'TAKE_PROFIT',
                        symbol: 'BNBUSDT',
                        side: 'SELL',
                        positionSide: 'BOTH',
                        timeInForce: 'GTC',
                        quantity: '0.01',
                        algoStatus: 'CANCELED',
                        actualOrderId: '',
                        actualPrice: '0.00000',
                        triggerPrice: '750.000',
                        price: '750.000',
                        icebergQuantity: null,
                        tpTriggerPrice: '0.000',
                        tpPrice: '0.000',
                        slTriggerPrice: '0.000',
                        slPrice: '0.000',
                        tpOrderType: '',
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        workingType: 'CONTRACT_PRICE',
                        priceMatch: 'NONE',
                        closePosition: false,
                        priceProtect: false,
                        reduceOnly: false,
                        createTime: 1750485492076,
                        updateTime: 1750514545091,
                        triggerTime: 0,
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryAllAlgoOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllAlgoOrdersResponse>)
            );
            const response = await client.queryAllAlgoOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllAlgoOrders() successfully with optional parameters', async () => {
            const params: QueryAllAlgoOrdersRequest = {
                symbol: 'symbol_example',
                algoId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        algoId: 2146760,
                        clientAlgoId: '6B2I9XVcJpCjqPAJ4YoFX7',
                        algoType: 'CONDITIONAL',
                        orderType: 'TAKE_PROFIT',
                        symbol: 'BNBUSDT',
                        side: 'SELL',
                        positionSide: 'BOTH',
                        timeInForce: 'GTC',
                        quantity: '0.01',
                        algoStatus: 'CANCELED',
                        actualOrderId: '',
                        actualPrice: '0.00000',
                        triggerPrice: '750.000',
                        price: '750.000',
                        icebergQuantity: null,
                        tpTriggerPrice: '0.000',
                        tpPrice: '0.000',
                        slTriggerPrice: '0.000',
                        slPrice: '0.000',
                        tpOrderType: '',
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        workingType: 'CONTRACT_PRICE',
                        priceMatch: 'NONE',
                        closePosition: false,
                        priceProtect: false,
                        reduceOnly: false,
                        createTime: 1750485492076,
                        updateTime: 1750514545091,
                        triggerTime: 0,
                        goodTillDate: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryAllAlgoOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllAlgoOrdersResponse>)
            );
            const response = await client.queryAllAlgoOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryAllAlgoOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryAllAlgoOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryAllAlgoOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryAllAlgoOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryAllAlgoOrders').mockRejectedValueOnce(mockError);
            await expect(client.queryAllAlgoOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentOpenOrder()', () => {
        it('should execute queryCurrentOpenOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'queryCurrentOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOrderResponse>)
            );
            const response = await client.queryCurrentOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentOpenOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'queryCurrentOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOrderResponse>)
            );
            const response = await client.queryCurrentOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentOpenOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentOpenOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentOpenOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentOpenOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryOrder()', () => {
        it('should execute queryOrder() successfully with required parameters only', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'queryOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOrderResponse>)
            );
            const response = await client.queryOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryOrder() successfully with optional parameters', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                })
            );

            const spy = jest.spyOn(client, 'queryOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOrderResponse>)
            );
            const response = await client.queryOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryOrder').mockRejectedValueOnce(mockError);
            await expect(client.queryOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testOrder()', () => {
        it('should execute testOrder() successfully with required parameters only', async () => {
            const params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.00000',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTD',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                })
            );

            const spy = jest.spyOn(client, 'testOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TestOrderResponse>)
            );
            const response = await client.testOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute testOrder() successfully with optional parameters', async () => {
            const params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
                positionSide: TestOrderPositionSideEnum.BOTH,
                timeInForce: TestOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                reduceOnly: 'false',
                price: 1.0,
                newClientOrderId: '1',
                stopPrice: 1.0,
                closePosition: 'closePosition_example',
                activationPrice: 1.0,
                callbackRate: 1.0,
                workingType: TestOrderWorkingTypeEnum.MARK_PRICE,
                priceProtect: 'false',
                newOrderRespType: TestOrderNewOrderRespTypeEnum.ACK,
                priceMatch: TestOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: TestOrderSelfTradePreventionModeEnum.EXPIRE_TAKER,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.00000',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTD',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                })
            );

            const spy = jest.spyOn(client, 'testOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TestOrderResponse>)
            );
            const response = await client.testOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.testOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling testOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.testOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling testOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.testOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling testOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testOrder').mockRejectedValueOnce(mockError);
            await expect(client.testOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('usersForceOrders()', () => {
        it('should execute usersForceOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 6071832819,
                        symbol: 'BTCUSDT',
                        status: 'FILLED',
                        clientOrderId: 'autoclose-1596107620040000020',
                        price: '10871.09',
                        avgPrice: '10913.21000',
                        origQty: '0.001',
                        executedQty: '0.001',
                        cumQuote: '10.91321',
                        timeInForce: 'IOC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'BOTH',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        origType: 'LIMIT',
                        time: 1596107620044,
                        updateTime: 1596107620087,
                    },
                    {
                        orderId: 6072734303,
                        symbol: 'BTCUSDT',
                        status: 'FILLED',
                        clientOrderId: 'adl_autoclose',
                        price: '11023.14',
                        avgPrice: '10979.82000',
                        origQty: '0.001',
                        executedQty: '0.001',
                        cumQuote: '10.97982',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        origType: 'LIMIT',
                        time: 1596110725059,
                        updateTime: 1596110725071,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'usersForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UsersForceOrdersResponse>)
            );
            const response = await client.usersForceOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute usersForceOrders() successfully with optional parameters', async () => {
            const params: UsersForceOrdersRequest = {
                symbol: 'symbol_example',
                autoCloseType: UsersForceOrdersAutoCloseTypeEnum.LIQUIDATION,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 6071832819,
                        symbol: 'BTCUSDT',
                        status: 'FILLED',
                        clientOrderId: 'autoclose-1596107620040000020',
                        price: '10871.09',
                        avgPrice: '10913.21000',
                        origQty: '0.001',
                        executedQty: '0.001',
                        cumQuote: '10.91321',
                        timeInForce: 'IOC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'BOTH',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        origType: 'LIMIT',
                        time: 1596107620044,
                        updateTime: 1596107620087,
                    },
                    {
                        orderId: 6072734303,
                        symbol: 'BTCUSDT',
                        status: 'FILLED',
                        clientOrderId: 'adl_autoclose',
                        price: '11023.14',
                        avgPrice: '10979.82000',
                        origQty: '0.001',
                        executedQty: '0.001',
                        cumQuote: '10.97982',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        stopPrice: '0',
                        workingType: 'CONTRACT_PRICE',
                        origType: 'LIMIT',
                        time: 1596110725059,
                        updateTime: 1596110725071,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'usersForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UsersForceOrdersResponse>)
            );
            const response = await client.usersForceOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'usersForceOrders').mockRejectedValueOnce(mockError);
            await expect(client.usersForceOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
