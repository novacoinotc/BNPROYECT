/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    MarketDataApi,
    BasisContractTypeEnum,
    BasisPeriodEnum,
    ContinuousContractKlineCandlestickDataContractTypeEnum,
    ContinuousContractKlineCandlestickDataIntervalEnum,
    IndexPriceKlineCandlestickDataIntervalEnum,
    KlineCandlestickDataIntervalEnum,
    LongShortRatioPeriodEnum,
    MarkPriceKlineCandlestickDataIntervalEnum,
    OpenInterestStatisticsPeriodEnum,
    PremiumIndexKlineDataIntervalEnum,
    TakerBuySellVolumePeriodEnum,
    TopTraderLongShortRatioAccountsPeriodEnum,
    TopTraderLongShortRatioPositionsPeriodEnum,
} from '../../../src/rest-api';
import {
    AdlRiskRequest,
    BasisRequest,
    CompositeIndexSymbolInformationRequest,
    CompressedAggregateTradesListRequest,
    ContinuousContractKlineCandlestickDataRequest,
    GetFundingRateHistoryRequest,
    IndexPriceKlineCandlestickDataRequest,
    KlineCandlestickDataRequest,
    LongShortRatioRequest,
    MarkPriceRequest,
    MarkPriceKlineCandlestickDataRequest,
    MultiAssetsModeAssetIndexRequest,
    OldTradesLookupRequest,
    OpenInterestRequest,
    OpenInterestStatisticsRequest,
    OrderBookRequest,
    PremiumIndexKlineDataRequest,
    QuarterlyContractSettlementPriceRequest,
    QueryIndexPriceConstituentsRequest,
    QueryInsuranceFundBalanceSnapshotRequest,
    RecentTradesListRequest,
    RpiOrderBookRequest,
    SymbolOrderBookTickerRequest,
    SymbolPriceTickerRequest,
    SymbolPriceTickerV2Request,
    TakerBuySellVolumeRequest,
    Ticker24hrPriceChangeStatisticsRequest,
    TopTraderLongShortRatioAccountsRequest,
    TopTraderLongShortRatioPositionsRequest,
} from '../../../src/rest-api';
import type {
    AdlRiskResponse,
    BasisResponse,
    CheckServerTimeResponse,
    CompositeIndexSymbolInformationResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryResponse,
    GetFundingRateInfoResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    MarkPriceResponse,
    MultiAssetsModeAssetIndexResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QuarterlyContractSettlementPriceResponse,
    QueryIndexPriceConstituentsResponse,
    QueryInsuranceFundBalanceSnapshotResponse,
    RecentTradesListResponse,
    RpiOrderBookResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    SymbolPriceTickerV2Response,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
    TradingScheduleResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('adlRisk()', () => {
        it('should execute adlRisk() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSDT', adlRisk: 'low', updateTime: 1597370495002 })
            );

            const spy = jest.spyOn(client, 'adlRisk').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AdlRiskResponse>)
            );
            const response = await client.adlRisk();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute adlRisk() successfully with optional parameters', async () => {
            const params: AdlRiskRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSDT', adlRisk: 'low', updateTime: 1597370495002 })
            );

            const spy = jest.spyOn(client, 'adlRisk').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AdlRiskResponse>)
            );
            const response = await client.adlRisk(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'adlRisk').mockRejectedValueOnce(mockError);
            await expect(client.adlRisk()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('basis()', () => {
        it('should execute basis() successfully with required parameters only', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        indexPrice: '34400.15945055',
                        contractType: 'PERPETUAL',
                        basisRate: '0.0004',
                        futuresPrice: '34414.10',
                        annualizedBasisRate: '',
                        basis: '13.94054945',
                        pair: 'BTCUSDT',
                        timestamp: 1698742800000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute basis() successfully with optional parameters', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        indexPrice: '34400.15945055',
                        contractType: 'PERPETUAL',
                        basisRate: '0.0004',
                        futuresPrice: '34414.10',
                        annualizedBasisRate: '',
                        basis: '13.94054945',
                        pair: 'BTCUSDT',
                        timestamp: 1698742800000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter limit was null or undefined when calling basis.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'basis').mockRejectedValueOnce(mockError);
            await expect(client.basis(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('checkServerTime()', () => {
        it('should execute checkServerTime() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ serverTime: 1499827319559 }));

            const spy = jest.spyOn(client, 'checkServerTime').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckServerTimeResponse>)
            );
            const response = await client.checkServerTime();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'checkServerTime').mockRejectedValueOnce(mockError);
            await expect(client.checkServerTime()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('compositeIndexSymbolInformation()', () => {
        it('should execute compositeIndexSymbolInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'DEFIUSDT',
                        time: 1589437530011,
                        component: 'baseAsset',
                        baseAssetList: [
                            {
                                baseAsset: 'BAL',
                                quoteAsset: 'USDT',
                                weightInQuantity: '1.04406228',
                                weightInPercentage: '0.02783900',
                            },
                            {
                                baseAsset: 'BAND',
                                quoteAsset: 'USDT',
                                weightInQuantity: '3.53782729',
                                weightInPercentage: '0.03935200',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'compositeIndexSymbolInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompositeIndexSymbolInformationResponse>)
            );
            const response = await client.compositeIndexSymbolInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute compositeIndexSymbolInformation() successfully with optional parameters', async () => {
            const params: CompositeIndexSymbolInformationRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'DEFIUSDT',
                        time: 1589437530011,
                        component: 'baseAsset',
                        baseAssetList: [
                            {
                                baseAsset: 'BAL',
                                quoteAsset: 'USDT',
                                weightInQuantity: '1.04406228',
                                weightInPercentage: '0.02783900',
                            },
                            {
                                baseAsset: 'BAND',
                                quoteAsset: 'USDT',
                                weightInQuantity: '3.53782729',
                                weightInPercentage: '0.03935200',
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'compositeIndexSymbolInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompositeIndexSymbolInformationResponse>)
            );
            const response = await client.compositeIndexSymbolInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'compositeIndexSymbolInformation')
                .mockRejectedValueOnce(mockError);
            await expect(client.compositeIndexSymbolInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('compressedAggregateTradesList()', () => {
        it('should execute compressedAggregateTradesList() successfully with required parameters only', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        a: 26129,
                        p: '0.01633102',
                        q: '4.70443515',
                        f: 27781,
                        l: 27781,
                        T: 1498793709153,
                        m: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute compressedAggregateTradesList() successfully with optional parameters', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        a: 26129,
                        p: '0.01633102',
                        q: '4.70443515',
                        f: 27781,
                        l: 27781,
                        T: 1498793709153,
                        m: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling compressedAggregateTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'compressedAggregateTradesList')
                .mockRejectedValueOnce(mockError);
            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('continuousContractKlineCandlestickData()', () => {
        it('should execute continuousContractKlineCandlestickData() successfully with required parameters only', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1607444700000,
                        '18879.99',
                        '18900.00',
                        '18878.98',
                        '18896.13',
                        '492.363',
                        1607444759999,
                        '9302145.66080',
                        1874,
                        '385.983',
                        '7292402.33267',
                        '0',
                    ],
                ])
            );

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute continuousContractKlineCandlestickData() successfully with optional parameters', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1607444700000,
                        '18879.99',
                        '18900.00',
                        '18878.98',
                        '18896.13',
                        '492.363',
                        1607444759999,
                        '9302145.66080',
                        1874,
                        '385.983',
                        '7292402.33267',
                        '0',
                    ],
                ])
            );

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('exchangeInformation()', () => {
        it('should execute exchangeInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    exchangeFilters: [],
                    rateLimits: [
                        {
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            rateLimitType: 'REQUEST_WEIGHT',
                        },
                        {
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 1200,
                            rateLimitType: 'ORDERS',
                        },
                    ],
                    serverTime: 1565613908500,
                    assets: [
                        { asset: 'BTC', marginAvailable: true, autoAssetExchange: '-0.10' },
                        { asset: 'USDT', marginAvailable: true, autoAssetExchange: '0' },
                        { asset: 'BNB', marginAvailable: false, autoAssetExchange: null },
                    ],
                    symbols: [
                        {
                            symbol: 'BLZUSDT',
                            pair: 'BLZUSDT',
                            contractType: 'PERPETUAL',
                            deliveryDate: 4133404800000,
                            onboardDate: 1598252400000,
                            status: 'TRADING',
                            maintMarginPercent: '2.5000',
                            requiredMarginPercent: '5.0000',
                            baseAsset: 'BLZ',
                            quoteAsset: 'USDT',
                            marginAsset: 'USDT',
                            pricePrecision: 5,
                            quantityPrecision: 0,
                            baseAssetPrecision: 8,
                            quotePrecision: 8,
                            underlyingType: 'COIN',
                            underlyingSubType: ['STORAGE'],
                            settlePlan: 0,
                            triggerProtect: '0.15',
                            filters: [
                                {
                                    filterType: 'PRICE_FILTER',
                                    maxPrice: '300',
                                    minPrice: '0.0001',
                                    tickSize: '0.0001',
                                },
                                {
                                    filterType: 'LOT_SIZE',
                                    maxQty: '10000000',
                                    minQty: '1',
                                    stepSize: '1',
                                },
                                {
                                    filterType: 'MARKET_LOT_SIZE',
                                    maxQty: '590119',
                                    minQty: '1',
                                    stepSize: '1',
                                },
                                { filterType: 'MAX_NUM_ORDERS', limit: 200 },
                                { filterType: 'MIN_NOTIONAL', notional: '5.0' },
                                {
                                    filterType: 'PERCENT_PRICE',
                                    multiplierUp: '1.1500',
                                    multiplierDown: '0.8500',
                                    multiplierDecimal: '4',
                                },
                            ],
                            OrderType: [
                                'LIMIT',
                                'MARKET',
                                'STOP',
                                'STOP_MARKET',
                                'TAKE_PROFIT',
                                'TAKE_PROFIT_MARKET',
                                'TRAILING_STOP_MARKET',
                            ],
                            timeInForce: ['GTC', 'IOC', 'FOK', 'GTX'],
                            liquidationFee: '0.010000',
                            marketTakeBound: '0.30',
                        },
                    ],
                    timezone: 'UTC',
                })
            );

            const spy = jest.spyOn(client, 'exchangeInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInformationResponse>)
            );
            const response = await client.exchangeInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInformation').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFundingRateHistory()', () => {
        it('should execute getFundingRateHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        fundingRate: '-0.03750000',
                        fundingTime: 1570608000000,
                        markPrice: '34287.54619963',
                    },
                    {
                        symbol: 'BTCUSDT',
                        fundingRate: '0.00010000',
                        fundingTime: 1570636800000,
                        markPrice: '34287.54619963',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getFundingRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateHistoryResponse>)
            );
            const response = await client.getFundingRateHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFundingRateHistory() successfully with optional parameters', async () => {
            const params: GetFundingRateHistoryRequest = {
                symbol: 'symbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        fundingRate: '-0.03750000',
                        fundingTime: 1570608000000,
                        markPrice: '34287.54619963',
                    },
                    {
                        symbol: 'BTCUSDT',
                        fundingRate: '0.00010000',
                        fundingTime: 1570636800000,
                        markPrice: '34287.54619963',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getFundingRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateHistoryResponse>)
            );
            const response = await client.getFundingRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFundingRateHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFundingRateInfo()', () => {
        it('should execute getFundingRateInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BLZUSDT',
                        adjustedFundingRateCap: '0.02500000',
                        adjustedFundingRateFloor: '-0.02500000',
                        fundingIntervalHours: 8,
                        disclaimer: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getFundingRateInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateInfoResponse>)
            );
            const response = await client.getFundingRateInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getFundingRateInfo').mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexPriceKlineCandlestickData()', () => {
        it('should execute indexPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256400000,
                        '9653.69440000',
                        '9653.69640000',
                        '9651.38600000',
                        '9651.55200000',
                        '0',
                        1591256459999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256400000,
                        '9653.69440000',
                        '9653.69640000',
                        '9651.38600000',
                        '9651.55200000',
                        '0',
                        1591256459999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('klineCandlestickData()', () => {
        it('should execute klineCandlestickData() successfully with required parameters only', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1499040000000,
                        '0.01634790',
                        '0.80000000',
                        '0.01575800',
                        '0.01577100',
                        '148976.11427815',
                        1499644799999,
                        '2434.19055334',
                        308,
                        '1756.87402397',
                        '28.46694368',
                        '17928899.62484339',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klineCandlestickData() successfully with optional parameters', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1499040000000,
                        '0.01634790',
                        '0.80000000',
                        '0.01575800',
                        '0.01577100',
                        '148976.11427815',
                        1499644799999,
                        '2434.19055334',
                        308,
                        '1756.87402397',
                        '28.46694368',
                        '17928899.62484339',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klineCandlestickData').mockRejectedValueOnce(mockError);
            await expect(client.klineCandlestickData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('longShortRatio()', () => {
        it('should execute longShortRatio() successfully with required parameters only', async () => {
            const params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '0.1960',
                        longAccount: '0.6622',
                        shortAccount: '0.3378',
                        timestamp: '1583139600000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.9559',
                        longAccount: '0.6617',
                        shortAccount: '0.3382',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute longShortRatio() successfully with optional parameters', async () => {
            const params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '0.1960',
                        longAccount: '0.6622',
                        shortAccount: '0.3378',
                        timestamp: '1583139600000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.9559',
                        longAccount: '0.6617',
                        shortAccount: '0.3382',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'longShortRatio').mockRejectedValueOnce(mockError);
            await expect(client.longShortRatio(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('markPrice()', () => {
        it('should execute markPrice() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    markPrice: '11793.63104562',
                    indexPrice: '11781.80495970',
                    estimatedSettlePrice: '11781.16138815',
                    lastFundingRate: '0.00038246',
                    interestRate: '0.00010000',
                    nextFundingTime: 1597392000000,
                    time: 1597370495002,
                })
            );

            const spy = jest.spyOn(client, 'markPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceResponse>)
            );
            const response = await client.markPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute markPrice() successfully with optional parameters', async () => {
            const params: MarkPriceRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    markPrice: '11793.63104562',
                    indexPrice: '11781.80495970',
                    estimatedSettlePrice: '11781.16138815',
                    lastFundingRate: '0.00038246',
                    interestRate: '0.00010000',
                    nextFundingTime: 1597392000000,
                    time: 1597370495002,
                })
            );

            const spy = jest.spyOn(client, 'markPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceResponse>)
            );
            const response = await client.markPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'markPrice').mockRejectedValueOnce(mockError);
            await expect(client.markPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('markPriceKlineCandlestickData()', () => {
        it('should execute markPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256460000,
                        '9653.29201333',
                        '9654.56401333',
                        '9653.07367333',
                        '9653.07367333',
                        '0',
                        1591256519999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute markPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1591256460000,
                        '9653.29201333',
                        '9654.56401333',
                        '9653.07367333',
                        '9653.07367333',
                        '0',
                        1591256519999,
                        '0',
                        60,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'markPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('multiAssetsModeAssetIndex()', () => {
        it('should execute multiAssetsModeAssetIndex() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'ADAUSD',
                    time: 1635740268004,
                    index: '1.92957370',
                    bidBuffer: '0.10000000',
                    askBuffer: '0.10000000',
                    bidRate: '1.73661633',
                    askRate: '2.12253107',
                    autoExchangeBidBuffer: '0.05000000',
                    autoExchangeAskBuffer: '0.05000000',
                    autoExchangeBidRate: '1.83309501',
                    autoExchangeAskRate: '2.02605238',
                })
            );

            const spy = jest.spyOn(client, 'multiAssetsModeAssetIndex').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MultiAssetsModeAssetIndexResponse>)
            );
            const response = await client.multiAssetsModeAssetIndex();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute multiAssetsModeAssetIndex() successfully with optional parameters', async () => {
            const params: MultiAssetsModeAssetIndexRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'ADAUSD',
                    time: 1635740268004,
                    index: '1.92957370',
                    bidBuffer: '0.10000000',
                    askBuffer: '0.10000000',
                    bidRate: '1.73661633',
                    askRate: '2.12253107',
                    autoExchangeBidBuffer: '0.05000000',
                    autoExchangeAskBuffer: '0.05000000',
                    autoExchangeBidRate: '1.83309501',
                    autoExchangeAskRate: '2.02605238',
                })
            );

            const spy = jest.spyOn(client, 'multiAssetsModeAssetIndex').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MultiAssetsModeAssetIndexResponse>)
            );
            const response = await client.multiAssetsModeAssetIndex(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'multiAssetsModeAssetIndex')
                .mockRejectedValueOnce(mockError);
            await expect(client.multiAssetsModeAssetIndex()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('oldTradesLookup()', () => {
        it('should execute oldTradesLookup() successfully with required parameters only', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '8000.00',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isRPITrade: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oldTradesLookup() successfully with optional parameters', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
                limit: 100,
                fromId: 1,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '8000.00',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isRPITrade: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.oldTradesLookup(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling oldTradesLookup.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'oldTradesLookup').mockRejectedValueOnce(mockError);
            await expect(client.oldTradesLookup(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterest()', () => {
        it('should execute openInterest() successfully with required parameters only', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ openInterest: '10659.509', symbol: 'BTCUSDT', time: 1589437530011 })
            );

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterest() successfully with optional parameters', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ openInterest: '10659.509', symbol: 'BTCUSDT', time: 1589437530011 })
            );

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling openInterest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openInterest').mockRejectedValueOnce(mockError);
            await expect(client.openInterest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterestStatistics()', () => {
        it('should execute openInterestStatistics() successfully with required parameters only', async () => {
            const params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        sumOpenInterest: '20403.63700000',
                        sumOpenInterestValue: '150570784.07809979',
                        CMCCirculatingSupply: '165880.538',
                        timestamp: '1583127900000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        sumOpenInterest: '20401.36700000',
                        sumOpenInterestValue: '149940752.14464448',
                        CMCCirculatingSupply: '165900.14853',
                        timestamp: '1583128200000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterestStatistics() successfully with optional parameters', async () => {
            const params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        sumOpenInterest: '20403.63700000',
                        sumOpenInterestValue: '150570784.07809979',
                        CMCCirculatingSupply: '165880.538',
                        timestamp: '1583127900000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        sumOpenInterest: '20401.36700000',
                        sumOpenInterestValue: '149940752.14464448',
                        CMCCirculatingSupply: '165900.14853',
                        timestamp: '1583128200000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'openInterestStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.openInterestStatistics(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderBook()', () => {
        it('should execute orderBook() successfully with required parameters only', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 1027024,
                    E: 1589436922972,
                    T: 1589436922959,
                    bids: [['4.00000000', '431.00000000']],
                    asks: [['4.00000200', '12.00000000']],
                })
            );

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderBook() successfully with optional parameters', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 1027024,
                    E: 1589436922972,
                    T: 1589436922959,
                    bids: [['4.00000000', '431.00000000']],
                    asks: [['4.00000200', '12.00000000']],
                })
            );

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderBook').mockRejectedValueOnce(mockError);
            await expect(client.orderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('premiumIndexKlineData()', () => {
        it('should execute premiumIndexKlineData() successfully with required parameters only', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1691603820000,
                        '-0.00042931',
                        '-0.00023641',
                        '-0.00059406',
                        '-0.00043659',
                        '0',
                        1691603879999,
                        '0',
                        12,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute premiumIndexKlineData() successfully with optional parameters', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1691603820000,
                        '-0.00042931',
                        '-0.00023641',
                        '-0.00059406',
                        '-0.00043659',
                        '0',
                        1691603879999,
                        '0',
                        12,
                        '0',
                        '0',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'premiumIndexKlineData')
                .mockRejectedValueOnce(mockError);
            await expect(client.premiumIndexKlineData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('quarterlyContractSettlementPrice()', () => {
        it('should execute quarterlyContractSettlementPrice() successfully with required parameters only', async () => {
            const params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { deliveryTime: 1695945600000, deliveryPrice: 27103 },
                    { deliveryTime: 1688083200000, deliveryPrice: 30733.6 },
                    { deliveryTime: 1680220800000, deliveryPrice: 27814.2 },
                    { deliveryTime: 1648166400000, deliveryPrice: 44066.3 },
                ])
            );

            const spy = jest.spyOn(client, 'quarterlyContractSettlementPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuarterlyContractSettlementPriceResponse>)
            );
            const response = await client.quarterlyContractSettlementPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute quarterlyContractSettlementPrice() successfully with optional parameters', async () => {
            const params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { deliveryTime: 1695945600000, deliveryPrice: 27103 },
                    { deliveryTime: 1688083200000, deliveryPrice: 30733.6 },
                    { deliveryTime: 1680220800000, deliveryPrice: 27814.2 },
                    { deliveryTime: 1648166400000, deliveryPrice: 44066.3 },
                ])
            );

            const spy = jest.spyOn(client, 'quarterlyContractSettlementPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuarterlyContractSettlementPriceResponse>)
            );
            const response = await client.quarterlyContractSettlementPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.quarterlyContractSettlementPrice(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling quarterlyContractSettlementPrice.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'quarterlyContractSettlementPrice')
                .mockRejectedValueOnce(mockError);
            await expect(client.quarterlyContractSettlementPrice(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryIndexPriceConstituents()', () => {
        it('should execute queryIndexPriceConstituents() successfully with required parameters only', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    time: 1745401553408,
                    constituents: [
                        {
                            exchange: 'binance',
                            symbol: 'BTCUSDT',
                            price: '94057.03000000',
                            weight: '0.51282051',
                        },
                        {
                            exchange: 'coinbase',
                            symbol: 'BTC-USDT',
                            price: '94140.58000000',
                            weight: '0.15384615',
                        },
                        {
                            exchange: 'gateio',
                            symbol: 'BTC_USDT',
                            price: '94060.10000000',
                            weight: '0.02564103',
                        },
                        {
                            exchange: 'kucoin',
                            symbol: 'BTC-USDT',
                            price: '94096.70000000',
                            weight: '0.07692308',
                        },
                        {
                            exchange: 'mxc',
                            symbol: 'BTCUSDT',
                            price: '94057.02000000',
                            weight: '0.07692308',
                        },
                        {
                            exchange: 'bitget',
                            symbol: 'BTCUSDT',
                            price: '94064.03000000',
                            weight: '0.07692308',
                        },
                        {
                            exchange: 'bybit',
                            symbol: 'BTCUSDT',
                            price: '94067.90000000',
                            weight: '0.07692308',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIndexPriceConstituents() successfully with optional parameters', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    time: 1745401553408,
                    constituents: [
                        {
                            exchange: 'binance',
                            symbol: 'BTCUSDT',
                            price: '94057.03000000',
                            weight: '0.51282051',
                        },
                        {
                            exchange: 'coinbase',
                            symbol: 'BTC-USDT',
                            price: '94140.58000000',
                            weight: '0.15384615',
                        },
                        {
                            exchange: 'gateio',
                            symbol: 'BTC_USDT',
                            price: '94060.10000000',
                            weight: '0.02564103',
                        },
                        {
                            exchange: 'kucoin',
                            symbol: 'BTC-USDT',
                            price: '94096.70000000',
                            weight: '0.07692308',
                        },
                        {
                            exchange: 'mxc',
                            symbol: 'BTCUSDT',
                            price: '94057.02000000',
                            weight: '0.07692308',
                        },
                        {
                            exchange: 'bitget',
                            symbol: 'BTCUSDT',
                            price: '94064.03000000',
                            weight: '0.07692308',
                        },
                        {
                            exchange: 'bybit',
                            symbol: 'BTCUSDT',
                            price: '94067.90000000',
                            weight: '0.07692308',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryIndexPriceConstituents.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIndexPriceConstituents')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryInsuranceFundBalanceSnapshot()', () => {
        it('should execute queryInsuranceFundBalanceSnapshot() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbols: [
                        'BNBUSDT',
                        'BTCUSDT',
                        'BTCUSDT_250627',
                        'BTCUSDT_250926',
                        'ETHBTC',
                        'ETHUSDT',
                        'ETHUSDT_250627',
                        'ETHUSDT_250926',
                    ],
                    assets: [
                        {
                            asset: 'USDC',
                            marginBalance: '299999998.6497832',
                            updateTime: 1745366402000,
                        },
                        {
                            asset: 'USDT',
                            marginBalance: '793930579.315848',
                            updateTime: 1745366402000,
                        },
                        { asset: 'BTC', marginBalance: '61.73143554', updateTime: 1745366402000 },
                        {
                            asset: 'BNFCR',
                            marginBalance: '633223.99396922',
                            updateTime: 1745366402000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryInsuranceFundBalanceSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryInsuranceFundBalanceSnapshotResponse>)
            );
            const response = await client.queryInsuranceFundBalanceSnapshot();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryInsuranceFundBalanceSnapshot() successfully with optional parameters', async () => {
            const params: QueryInsuranceFundBalanceSnapshotRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbols: [
                        'BNBUSDT',
                        'BTCUSDT',
                        'BTCUSDT_250627',
                        'BTCUSDT_250926',
                        'ETHBTC',
                        'ETHUSDT',
                        'ETHUSDT_250627',
                        'ETHUSDT_250926',
                    ],
                    assets: [
                        {
                            asset: 'USDC',
                            marginBalance: '299999998.6497832',
                            updateTime: 1745366402000,
                        },
                        {
                            asset: 'USDT',
                            marginBalance: '793930579.315848',
                            updateTime: 1745366402000,
                        },
                        { asset: 'BTC', marginBalance: '61.73143554', updateTime: 1745366402000 },
                        {
                            asset: 'BNFCR',
                            marginBalance: '633223.99396922',
                            updateTime: 1745366402000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryInsuranceFundBalanceSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryInsuranceFundBalanceSnapshotResponse>)
            );
            const response = await client.queryInsuranceFundBalanceSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryInsuranceFundBalanceSnapshot')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryInsuranceFundBalanceSnapshot()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('recentTradesList()', () => {
        it('should execute recentTradesList() successfully with required parameters only', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.00',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isRPITrade: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentTradesList() successfully with optional parameters', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 28457,
                        price: '4.00000100',
                        qty: '12.00000000',
                        quoteQty: '48.00',
                        time: 1499865549590,
                        isBuyerMaker: true,
                        isRPITrade: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.recentTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling recentTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'recentTradesList').mockRejectedValueOnce(mockError);
            await expect(client.recentTradesList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('rpiOrderBook()', () => {
        it('should execute rpiOrderBook() successfully with required parameters only', async () => {
            const params: RpiOrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 1027024,
                    E: 1589436922972,
                    T: 1589436922959,
                    bids: [['4.00000000', '431.00000000']],
                    asks: [['4.00000200', '12.00000000']],
                })
            );

            const spy = jest.spyOn(client, 'rpiOrderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RpiOrderBookResponse>)
            );
            const response = await client.rpiOrderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute rpiOrderBook() successfully with optional parameters', async () => {
            const params: RpiOrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    lastUpdateId: 1027024,
                    E: 1589436922972,
                    T: 1589436922959,
                    bids: [['4.00000000', '431.00000000']],
                    asks: [['4.00000200', '12.00000000']],
                })
            );

            const spy = jest.spyOn(client, 'rpiOrderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RpiOrderBookResponse>)
            );
            const response = await client.rpiOrderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RpiOrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.rpiOrderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling rpiOrderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RpiOrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'rpiOrderBook').mockRejectedValueOnce(mockError);
            await expect(client.rpiOrderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolOrderBookTicker()', () => {
        it('should execute symbolOrderBookTicker() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    bidPrice: '4.00000000',
                    bidQty: '431.00000000',
                    askPrice: '4.00000200',
                    askQty: '9.00000000',
                    time: 1589437530011,
                })
            );

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolOrderBookTicker() successfully with optional parameters', async () => {
            const params: SymbolOrderBookTickerRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    bidPrice: '4.00000000',
                    bidQty: '431.00000000',
                    askPrice: '4.00000200',
                    askQty: '9.00000000',
                    time: 1589437530011,
                })
            );

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'symbolOrderBookTicker')
                .mockRejectedValueOnce(mockError);
            await expect(client.symbolOrderBookTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTicker()', () => {
        it('should execute symbolPriceTicker() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 })
            );

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTicker() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 })
            );

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTicker').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTickerV2()', () => {
        it('should execute symbolPriceTickerV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 })
            );

            const spy = jest.spyOn(client, 'symbolPriceTickerV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerV2Response>)
            );
            const response = await client.symbolPriceTickerV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTickerV2() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerV2Request = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 })
            );

            const spy = jest.spyOn(client, 'symbolPriceTickerV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerV2Response>)
            );
            const response = await client.symbolPriceTickerV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTickerV2').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTickerV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('takerBuySellVolume()', () => {
        it('should execute takerBuySellVolume() successfully with required parameters only', async () => {
            const params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        buySellRatio: '1.5586',
                        buyVol: '387.3300',
                        sellVol: '248.5030',
                        timestamp: '1585614900000',
                    },
                    {
                        buySellRatio: '1.3104',
                        buyVol: '343.9290',
                        sellVol: '248.5030',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute takerBuySellVolume() successfully with optional parameters', async () => {
            const params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        buySellRatio: '1.5586',
                        buyVol: '387.3300',
                        sellVol: '248.5030',
                        timestamp: '1585614900000',
                    },
                    {
                        buySellRatio: '1.3104',
                        buyVol: '343.9290',
                        sellVol: '248.5030',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'takerBuySellVolume').mockRejectedValueOnce(mockError);
            await expect(client.takerBuySellVolume(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testConnectivity()', () => {
        it('should execute testConnectivity() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'testConnectivity').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.testConnectivity();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testConnectivity').mockRejectedValueOnce(mockError);
            await expect(client.testConnectivity()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hrPriceChangeStatistics()', () => {
        it('should execute ticker24hrPriceChangeStatistics() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    priceChange: '-94.99999800',
                    priceChangePercent: '-95.960',
                    weightedAvgPrice: '0.29628482',
                    lastPrice: '4.00000200',
                    lastQty: '200.00000000',
                    openPrice: '99.00000000',
                    highPrice: '100.00000000',
                    lowPrice: '0.10000000',
                    volume: '8913.30000000',
                    quoteVolume: '15.30000000',
                    openTime: 1499783499040,
                    closeTime: 1499869899040,
                    firstId: 28385,
                    lastId: 28460,
                    count: 76,
                })
            );

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hrPriceChangeStatistics() successfully with optional parameters', async () => {
            const params: Ticker24hrPriceChangeStatisticsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    priceChange: '-94.99999800',
                    priceChangePercent: '-95.960',
                    weightedAvgPrice: '0.29628482',
                    lastPrice: '4.00000200',
                    lastQty: '200.00000000',
                    openPrice: '99.00000000',
                    highPrice: '100.00000000',
                    lowPrice: '0.10000000',
                    volume: '8913.30000000',
                    quoteVolume: '15.30000000',
                    openTime: 1499783499040,
                    closeTime: 1499869899040,
                    firstId: 28385,
                    lastId: 28460,
                    count: 76,
                })
            );

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'ticker24hrPriceChangeStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.ticker24hrPriceChangeStatistics()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioAccounts()', () => {
        it('should execute topTraderLongShortRatioAccounts() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.8105',
                        longAccount: '0.6442',
                        shortAccount: '0.3558',
                        timestamp: '1583139600000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '0.5576',
                        longAccount: '0.3580',
                        shortAccount: '0.6420',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioAccounts() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.8105',
                        longAccount: '0.6442',
                        shortAccount: '0.3558',
                        timestamp: '1583139600000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '0.5576',
                        longAccount: '0.3580',
                        shortAccount: '0.6420',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioAccounts')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioPositions()', () => {
        it('should execute topTraderLongShortRatioPositions() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.4342',
                        longAccount: '0.5891',
                        shortAccount: '0.4108',
                        timestamp: '1583139600000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.4337',
                        longAccount: '0.3583',
                        shortAccount: '0.6417',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioPositions() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.4342',
                        longAccount: '0.5891',
                        shortAccount: '0.4108',
                        timestamp: '1583139600000',
                    },
                    {
                        symbol: 'BTCUSDT',
                        longShortRatio: '1.4337',
                        longAccount: '0.3583',
                        shortAccount: '0.6417',
                        timestamp: '1583139900000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioPositions')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('tradingSchedule()', () => {
        it('should execute tradingSchedule() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    updateTime: 1761286643918,
                    marketSchedules: {
                        EQUITY: {
                            sessions: [
                                {
                                    startTime: 1761177600000,
                                    endTime: 1761206400000,
                                    type: 'OVERNIGHT',
                                },
                                {
                                    startTime: 1761206400000,
                                    endTime: 1761226200000,
                                    type: 'PRE_MARKET',
                                },
                            ],
                        },
                        COMMODITY: {
                            sessions: [
                                {
                                    startTime: 1761724800000,
                                    endTime: 1761744600000,
                                    type: 'NO_TRADING',
                                },
                                {
                                    startTime: 1761744600000,
                                    endTime: 1761768000000,
                                    type: 'REGULAR',
                                },
                            ],
                        },
                    },
                })
            );

            const spy = jest.spyOn(client, 'tradingSchedule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TradingScheduleResponse>)
            );
            const response = await client.tradingSchedule();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tradingSchedule').mockRejectedValueOnce(mockError);
            await expect(client.tradingSchedule()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
