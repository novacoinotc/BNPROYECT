/* eslint-disable @typescript-eslint/no-unused-vars */

/**
 * Binance Derivatives Trading USDS Futures WebSocket API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures WebSocket API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import WebSocketClient from 'ws';
import { EventEmitter } from 'events';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { jest, expect, beforeEach, afterEach, describe, it } from '@jest/globals';
import { ConfigurationWebsocketAPI, WebsocketAPIBase, randomString } from '@binance/common';

import { AccountApi } from '../../../src/websocket-api';

jest.mock('ws');

describe('AccountApi', () => {
    let websocketBase: WebsocketAPIBase;
    let websocketAPIClient: AccountApi;
    let mockWs: jest.Mocked<WebSocketClient> & EventEmitter;
    let mockResponse: {
        id?: string;
        status?: number;
        result?: object | null;
        response?: object | null;
        error?: {
            code?: number;
            msg?: string;
        };
        rateLimits?: object[];
    } = {
        result: {},
        response: {},
        rateLimits: [],
    };

    describe('accountInformation()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute accountInformation() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: {
                        feeTier: 0,
                        canTrade: true,
                        canDeposit: true,
                        canWithdraw: true,
                        updateTime: 0,
                        multiAssetsMargin: true,
                        tradeGroupId: -1,
                        totalInitialMargin: '0.00000000',
                        totalMaintMargin: '0.00000000',
                        totalWalletBalance: '126.72469206',
                        totalUnrealizedProfit: '0.00000000',
                        totalMarginBalance: '126.72469206',
                        totalPositionInitialMargin: '0.00000000',
                        totalOpenOrderInitialMargin: '0.00000000',
                        totalCrossWalletBalance: '126.72469206',
                        totalCrossUnPnl: '0.00000000',
                        availableBalance: '126.72469206',
                        maxWithdrawAmount: '126.72469206',
                        assets: [
                            {
                                asset: 'USDT',
                                walletBalance: '23.72469206',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '23.72469206',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '23.72469206',
                                crossUnPnl: '0.00000000',
                                availableBalance: '23.72469206',
                                maxWithdrawAmount: '23.72469206',
                                marginAvailable: true,
                                updateTime: 1625474304765,
                            },
                            {
                                asset: 'BUSD',
                                walletBalance: '103.12345678',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '103.12345678',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '103.12345678',
                                crossUnPnl: '0.00000000',
                                availableBalance: '103.12345678',
                                maxWithdrawAmount: '103.12345678',
                                marginAvailable: true,
                                updateTime: 1625474304765,
                            },
                            {
                                asset: 'USDT',
                                walletBalance: '23.72469206',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '23.72469206',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '23.72469206',
                                crossUnPnl: '0.00000000',
                                availableBalance: '126.72469206',
                                maxWithdrawAmount: '23.72469206',
                                marginAvailable: true,
                                updateTime: 1625474304765,
                            },
                            {
                                asset: 'BUSD',
                                walletBalance: '103.12345678',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '103.12345678',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '103.12345678',
                                crossUnPnl: '0.00000000',
                                availableBalance: '126.72469206',
                                maxWithdrawAmount: '103.12345678',
                                marginAvailable: true,
                                updateTime: 1625474304765,
                            },
                        ],
                        positions: [
                            {
                                symbol: 'BTCUSDT',
                                initialMargin: '0',
                                maintMargin: '0',
                                unrealizedProfit: '0.00000000',
                                positionInitialMargin: '0',
                                openOrderInitialMargin: '0',
                                leverage: '100',
                                isolated: true,
                                entryPrice: '0.00000',
                                maxNotional: '250000',
                                bidNotional: '0',
                                askNotional: '0',
                                positionSide: 'BOTH',
                                positionAmt: '0',
                                updateTime: 0,
                            },
                            {
                                symbol: 'BTCUSDT',
                                initialMargin: '0',
                                maintMargin: '0',
                                unrealizedProfit: '0.00000000',
                                positionInitialMargin: '0',
                                openOrderInitialMargin: '0',
                                leverage: '100',
                                isolated: true,
                                entryPrice: '0.00000',
                                breakEvenPrice: '0.0',
                                maxNotional: '250000',
                                bidNotional: '0',
                                askNotional: '0',
                                positionSide: 'BOTH',
                                positionAmt: '0',
                                updateTime: 0,
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 20,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.accountInformation({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/account.status'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const responsePromise = websocketAPIClient.accountInformation({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(websocketBase);
                    const responsePromise = websocketAPIClient.accountInformation();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('accountInformationV2()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute accountInformationV2() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: {
                        totalInitialMargin: '0.00000000',
                        totalMaintMargin: '0.00000000',
                        totalWalletBalance: '126.72469206',
                        totalUnrealizedProfit: '0.00000000',
                        totalMarginBalance: '126.72469206',
                        totalPositionInitialMargin: '0.00000000',
                        totalOpenOrderInitialMargin: '0.00000000',
                        totalCrossWalletBalance: '126.72469206',
                        totalCrossUnPnl: '0.00000000',
                        availableBalance: '126.72469206',
                        maxWithdrawAmount: '126.72469206',
                        assets: [
                            {
                                asset: 'USDT',
                                walletBalance: '23.72469206',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '23.72469206',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '23.72469206',
                                crossUnPnl: '0.00000000',
                                availableBalance: '23.72469206',
                                maxWithdrawAmount: '23.72469206',
                                updateTime: 1625474304765,
                            },
                            {
                                asset: 'USDC',
                                walletBalance: '103.12345678',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '103.12345678',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '103.12345678',
                                crossUnPnl: '0.00000000',
                                availableBalance: '126.72469206',
                                maxWithdrawAmount: '103.12345678',
                                updateTime: 1625474304765,
                            },
                            {
                                asset: 'USDT',
                                walletBalance: '23.72469206',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '23.72469206',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '23.72469206',
                                crossUnPnl: '0.00000000',
                                availableBalance: '126.72469206',
                                maxWithdrawAmount: '23.72469206',
                                marginAvailable: true,
                                updateTime: 1625474304765,
                            },
                            {
                                asset: 'BUSD',
                                walletBalance: '103.12345678',
                                unrealizedProfit: '0.00000000',
                                marginBalance: '103.12345678',
                                maintMargin: '0.00000000',
                                initialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                openOrderInitialMargin: '0.00000000',
                                crossWalletBalance: '103.12345678',
                                crossUnPnl: '0.00000000',
                                availableBalance: '126.72469206',
                                maxWithdrawAmount: '103.12345678',
                                marginAvailable: true,
                                updateTime: 1625474304765,
                            },
                        ],
                        positions: [
                            {
                                symbol: 'BTCUSDT',
                                positionSide: 'BOTH',
                                positionAmt: '1.000',
                                unrealizedProfit: '0.00000000',
                                isolatedMargin: '0.00000000',
                                notional: '0',
                                isolatedWallet: '0',
                                initialMargin: '0',
                                maintMargin: '0',
                                updateTime: 0,
                            },
                            {
                                symbol: 'BTCUSDT',
                                positionSide: 'BOTH',
                                positionAmt: '1.000',
                                unrealizedProfit: '0.00000000',
                                isolatedMargin: '0.00000000',
                                notional: '0',
                                isolatedWallet: '0',
                                initialMargin: '0',
                                maintMargin: '0',
                                updateTime: 0,
                            },
                        ],
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 20,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.accountInformationV2({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/v2/account.status'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const responsePromise = websocketAPIClient.accountInformationV2({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(websocketBase);
                    const responsePromise = websocketAPIClient.accountInformationV2();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('futuresAccountBalance()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute futuresAccountBalance() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: [
                        {
                            accountAlias: 'SgsR',
                            asset: 'USDT',
                            balance: '122607.35137903',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '23.72469206',
                            maxWithdrawAmount: '23.72469206',
                            marginAvailable: true,
                            updateTime: 1617939110373,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 20,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.futuresAccountBalance({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/account.balance'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const responsePromise = websocketAPIClient.futuresAccountBalance({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(websocketBase);
                    const responsePromise = websocketAPIClient.futuresAccountBalance();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('futuresAccountBalanceV2()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute futuresAccountBalanceV2() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: [
                        {
                            accountAlias: 'SgsR',
                            asset: 'USDT',
                            balance: '122607.35137903',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            availableBalance: '23.72469206',
                            maxWithdrawAmount: '23.72469206',
                            marginAvailable: true,
                            updateTime: 1617939110373,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 20,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.futuresAccountBalanceV2({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/v2/account.balance'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(conn);
                    const responsePromise = websocketAPIClient.futuresAccountBalanceV2({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new AccountApi(websocketBase);
                    const responsePromise = websocketAPIClient.futuresAccountBalanceV2();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });
});
