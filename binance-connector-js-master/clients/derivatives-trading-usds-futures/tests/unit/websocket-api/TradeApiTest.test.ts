/* eslint-disable @typescript-eslint/no-unused-vars */

/**
 * Binance Derivatives Trading USDS Futures WebSocket API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures WebSocket API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import WebSocketClient from 'ws';
import { EventEmitter } from 'events';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { jest, expect, beforeEach, afterEach, describe, it } from '@jest/globals';
import { ConfigurationWebsocketAPI, WebsocketAPIBase, randomString } from '@binance/common';

import {
    TradeApi,
    ModifyOrderSideEnum,
    NewAlgoOrderSideEnum,
    NewOrderSideEnum,
} from '../../../src/websocket-api';
import {
    CancelOrderRequest,
    ModifyOrderRequest,
    NewAlgoOrderRequest,
    NewOrderRequest,
    QueryOrderRequest,
} from '../../../src/websocket-api';

jest.mock('ws');

describe('TradeApi', () => {
    let websocketBase: WebsocketAPIBase;
    let websocketAPIClient: TradeApi;
    let mockWs: jest.Mocked<WebSocketClient> & EventEmitter;
    let mockResponse: {
        id?: string;
        status?: number;
        result?: object | null;
        response?: object | null;
        error?: {
            code?: number;
            msg?: string;
        };
        rateLimits?: object[];
    } = {
        result: {},
        response: {},
        rateLimits: [],
    };

    describe('cancelAlgoOrder()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute cancelAlgoOrder() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'unique-cancel-request-id-5678',
                    status: 200,
                    result: {
                        algoId: 2000000002162519,
                        clientAlgoId: 'rDMG8WSde6LkyMNtk6s825',
                        code: '200',
                        msg: 'success',
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 6,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.cancelAlgoOrder({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/algoOrder.cancel'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.cancelAlgoOrder({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.cancelAlgoOrder();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('cancelOrder()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute cancelOrder() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '5633b6a2-90a9-4192-83e7-925c90b6a2fd',
                    status: 200,
                    result: {
                        clientOrderId: 'myOrder1',
                        cumQty: '0',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 283194212,
                        origQty: '11',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'CANCELED',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1571110484038,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.cancelOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.cancel'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.cancelOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.cancelOrder(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('modifyOrder()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute modifyOrder() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: 'c8c271ba-de70-479e-870c-e64951c753d9',
                    status: 200,
                    result: {
                        orderId: 328971409,
                        symbol: 'BTCUSDT',
                        status: 'NEW',
                        clientOrderId: 'xGHfltUMExx0TbQstQQfRX',
                        price: '43769.10',
                        avgPrice: '0.00',
                        origQty: '0.110',
                        executedQty: '0.000',
                        cumQty: '0.000',
                        cumQuote: '0.00000',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'SELL',
                        positionSide: 'SHORT',
                        stopPrice: '0.00',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                        updateTime: 1703426756190,
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 300,
                            count: 1,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 1200,
                            count: 1,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.modifyOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.modify'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.modifyOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.modifyOrder(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('newAlgoOrder()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute newAlgoOrder() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '06c9dbd8-ccbf-4ecf-a29c-fe31495ac73f',
                    status: 200,
                    result: {
                        algoId: 3000000000003505,
                        clientAlgoId: '0Xkl1p621E4EryvufmYre1',
                        algoType: 'CONDITIONAL',
                        orderType: 'TAKE_PROFIT',
                        symbol: 'BTCUSDT',
                        side: 'SELL',
                        positionSide: 'SHORT',
                        timeInForce: 'GTC',
                        quantity: '1.000',
                        algoStatus: 'NEW',
                        triggerPrice: '120000.00',
                        price: '160000.00',
                        icebergQuantity: null,
                        selfTradePreventionMode: 'EXPIRE_MAKER',
                        workingType: 'CONTRACT_PRICE',
                        priceMatch: 'NONE',
                        closePosition: false,
                        priceProtect: false,
                        reduceOnly: false,
                        createTime: 1762507264142,
                        updateTime: 1762507264143,
                        triggerTime: 0,
                        goodTillDate: 0,
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.newAlgoOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/algoOrder.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.newAlgoOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: NewAlgoOrderRequest = {
                algoType: 'algoType_example',
                symbol: 'symbol_example',
                side: NewAlgoOrderSideEnum.BUY,
                type: 'type_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.newAlgoOrder(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('newOrder()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute newOrder() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '3f7df6e3-2df4-44b9-9919-d2f38f90a99a',
                    status: 200,
                    result: {
                        orderId: 325078477,
                        symbol: 'BTCUSDT',
                        status: 'NEW',
                        clientOrderId: 'iCXL1BywlBaf2sesNUrVl3',
                        price: '43187.00',
                        avgPrice: '0.00',
                        origQty: '0.100',
                        executedQty: '0.000',
                        cumQty: '0.000',
                        cumQuote: '0.00000',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        reduceOnly: false,
                        closePosition: false,
                        side: 'BUY',
                        positionSide: 'BOTH',
                        stopPrice: '0.00',
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                        origType: 'LIMIT',
                        priceMatch: 'NONE',
                        selfTradePreventionMode: 'NONE',
                        goodTillDate: 0,
                        updateTime: 1702555534435,
                    },
                    rateLimits: [
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 300,
                            count: 1,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 1200,
                            count: 1,
                        },
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 1,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.newOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.newOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.newOrder(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('positionInformation()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute positionInformation() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: [
                        {
                            entryPrice: '0.00000',
                            breakEvenPrice: '0.0',
                            marginType: 'isolated',
                            isAutoAddMargin: 'false',
                            isolatedMargin: '0.00000000',
                            leverage: '10',
                            liquidationPrice: '0',
                            markPrice: '6679.50671178',
                            maxNotionalValue: '20000000',
                            positionAmt: '0.000',
                            notional: '0',
                            isolatedWallet: '0',
                            symbol: 'BTCUSDT',
                            unRealizedProfit: '0.00000000',
                            positionSide: 'BOTH',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            positionAmt: '0.001',
                            entryPrice: '22185.2',
                            breakEvenPrice: '0.0',
                            markPrice: '21123.05052574',
                            unRealizedProfit: '-1.06214947',
                            liquidationPrice: '19731.45529116',
                            leverage: '4',
                            maxNotionalValue: '100000000',
                            marginType: 'cross',
                            isolatedMargin: '0.00000000',
                            isAutoAddMargin: 'false',
                            positionSide: 'LONG',
                            notional: '21.12305052',
                            isolatedWallet: '0',
                            updateTime: 1655217461579,
                        },
                        {
                            symbol: 'BTCUSDT',
                            positionAmt: '0.000',
                            entryPrice: '0.0',
                            breakEvenPrice: '0.0',
                            markPrice: '21123.05052574',
                            unRealizedProfit: '0.00000000',
                            liquidationPrice: '0',
                            leverage: '4',
                            maxNotionalValue: '100000000',
                            marginType: 'cross',
                            isolatedMargin: '0.00000000',
                            isAutoAddMargin: 'false',
                            positionSide: 'SHORT',
                            notional: '0',
                            isolatedWallet: '0',
                            updateTime: 0,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 20,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.positionInformation({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/account.position'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.positionInformation({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.positionInformation();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('positionInformationV2()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute positionInformationV2() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: [
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'BOTH',
                            positionAmt: '1.000',
                            entryPrice: '0.00000',
                            breakEvenPrice: '0.0',
                            markPrice: '6679.50671178',
                            unrealizedProfit: '0.00000000',
                            liquidationPrice: '0',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            marginAsset: 'USDT',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            adl: 0,
                            bidNotional: '0',
                            askNotional: '0',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'LONG',
                            positionAmt: '1.000',
                            entryPrice: '0.00000',
                            breakEvenPrice: '0.0',
                            markPrice: '6679.50671178',
                            unrealizedProfit: '0.00000000',
                            liquidationPrice: '0',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            marginAsset: 'USDT',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            adl: 0,
                            bidNotional: '0',
                            askNotional: '0',
                            updateTime: 0,
                        },
                        {
                            symbol: 'BTCUSDT',
                            positionSide: 'SHORT',
                            positionAmt: '1.000',
                            entryPrice: '0.00000',
                            breakEvenPrice: '0.0',
                            markPrice: '6679.50671178',
                            unrealizedProfit: '0.00000000',
                            liquidationPrice: '0',
                            isolatedMargin: '0.00000000',
                            notional: '0',
                            marginAsset: 'USDT',
                            isolatedWallet: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            adl: 0,
                            bidNotional: '0',
                            askNotional: '0',
                            updateTime: 0,
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                            count: 20,
                        },
                    ],
                })
            );
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.positionInformationV2({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/v2/account.position'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.positionInformationV2({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.positionInformationV2();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('queryOrder()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute queryOrder() successfully', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    id: '605a6d20-6588-4cb9-afa0-b0ab087507ba',
                    status: 200,
                    result: {
                        avgPrice: '0.00000',
                        clientOrderId: 'abc',
                        cumQuote: '0',
                        executedQty: '0',
                        orderId: 1917641,
                        origQty: '0.40',
                        origType: 'TRAILING_STOP_MARKET',
                        price: '0',
                        reduceOnly: false,
                        side: 'BUY',
                        positionSide: 'SHORT',
                        status: 'NEW',
                        stopPrice: '9300',
                        closePosition: false,
                        symbol: 'BTCUSDT',
                        time: 1579276756075,
                        timeInForce: 'GTC',
                        type: 'TRAILING_STOP_MARKET',
                        activatePrice: '9020',
                        priceRate: '0.3',
                        updateTime: 1579276756075,
                        workingType: 'CONTRACT_PRICE',
                        priceProtect: false,
                    },
                })
            );
            mockResponse.id = randomString();

            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.queryOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result ?? mockResponse.response);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.status'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.queryOrder({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSONStringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.queryOrder(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });
});
