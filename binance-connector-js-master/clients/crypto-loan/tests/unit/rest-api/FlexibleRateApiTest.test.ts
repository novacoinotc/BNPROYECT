/**
 * Binance Crypto Loan REST API
 *
 * OpenAPI Specification for the Binance Crypto Loan REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { FlexibleRateApi } from '../../../src/rest-api';
import {
    CheckCollateralRepayRateRequest,
    FlexibleLoanAdjustLtvRequest,
    FlexibleLoanBorrowRequest,
    FlexibleLoanRepayRequest,
    GetFlexibleLoanAssetsDataRequest,
    GetFlexibleLoanBorrowHistoryRequest,
    GetFlexibleLoanCollateralAssetsDataRequest,
    GetFlexibleLoanInterestRateHistoryRequest,
    GetFlexibleLoanLiquidationHistoryRequest,
    GetFlexibleLoanLtvAdjustmentHistoryRequest,
    GetFlexibleLoanOngoingOrdersRequest,
    GetFlexibleLoanRepaymentHistoryRequest,
} from '../../../src/rest-api';
import type {
    CheckCollateralRepayRateResponse,
    FlexibleLoanAdjustLtvResponse,
    FlexibleLoanBorrowResponse,
    FlexibleLoanRepayResponse,
    GetFlexibleLoanAssetsDataResponse,
    GetFlexibleLoanBorrowHistoryResponse,
    GetFlexibleLoanCollateralAssetsDataResponse,
    GetFlexibleLoanInterestRateHistoryResponse,
    GetFlexibleLoanLiquidationHistoryResponse,
    GetFlexibleLoanLtvAdjustmentHistoryResponse,
    GetFlexibleLoanOngoingOrdersResponse,
    GetFlexibleLoanRepaymentHistoryResponse,
} from '../../../src/rest-api/types';

describe('FlexibleRateApi', () => {
    let client: FlexibleRateApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new FlexibleRateApi(config);
    });

    describe('checkCollateralRepayRate()', () => {
        it('should execute checkCollateralRepayRate() successfully with required parameters only', async () => {
            const params: CheckCollateralRepayRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ loanCoin: 'BUSD', collateralCoin: 'BNB', rate: '300.36781234' })
            );

            const spy = jest.spyOn(client, 'checkCollateralRepayRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckCollateralRepayRateResponse>)
            );
            const response = await client.checkCollateralRepayRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute checkCollateralRepayRate() successfully with optional parameters', async () => {
            const params: CheckCollateralRepayRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ loanCoin: 'BUSD', collateralCoin: 'BNB', rate: '300.36781234' })
            );

            const spy = jest.spyOn(client, 'checkCollateralRepayRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckCollateralRepayRateResponse>)
            );
            const response = await client.checkCollateralRepayRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when loanCoin is missing', async () => {
            const _params: CheckCollateralRepayRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.loanCoin;

            await expect(client.checkCollateralRepayRate(params)).rejects.toThrow(
                'Required parameter loanCoin was null or undefined when calling checkCollateralRepayRate.'
            );
        });

        it('should throw RequiredError when collateralCoin is missing', async () => {
            const _params: CheckCollateralRepayRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.collateralCoin;

            await expect(client.checkCollateralRepayRate(params)).rejects.toThrow(
                'Required parameter collateralCoin was null or undefined when calling checkCollateralRepayRate.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CheckCollateralRepayRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'checkCollateralRepayRate')
                .mockRejectedValueOnce(mockError);
            await expect(client.checkCollateralRepayRate(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('flexibleLoanAdjustLtv()', () => {
        it('should execute flexibleLoanAdjustLtv() successfully with required parameters only', async () => {
            const params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    loanCoin: 'BUSD',
                    collateralCoin: 'BNB',
                    direction: 'ADDITIONAL',
                    adjustmentAmount: '5.235',
                    currentLTV: '0.52',
                    status: 'Succeeds',
                })
            );

            const spy = jest.spyOn(client, 'flexibleLoanAdjustLtv').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FlexibleLoanAdjustLtvResponse>)
            );
            const response = await client.flexibleLoanAdjustLtv(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute flexibleLoanAdjustLtv() successfully with optional parameters', async () => {
            const params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    loanCoin: 'BUSD',
                    collateralCoin: 'BNB',
                    direction: 'ADDITIONAL',
                    adjustmentAmount: '5.235',
                    currentLTV: '0.52',
                    status: 'Succeeds',
                })
            );

            const spy = jest.spyOn(client, 'flexibleLoanAdjustLtv').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FlexibleLoanAdjustLtvResponse>)
            );
            const response = await client.flexibleLoanAdjustLtv(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when loanCoin is missing', async () => {
            const _params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.loanCoin;

            await expect(client.flexibleLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter loanCoin was null or undefined when calling flexibleLoanAdjustLtv.'
            );
        });

        it('should throw RequiredError when collateralCoin is missing', async () => {
            const _params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.collateralCoin;

            await expect(client.flexibleLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter collateralCoin was null or undefined when calling flexibleLoanAdjustLtv.'
            );
        });

        it('should throw RequiredError when adjustmentAmount is missing', async () => {
            const _params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.adjustmentAmount;

            await expect(client.flexibleLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter adjustmentAmount was null or undefined when calling flexibleLoanAdjustLtv.'
            );
        });

        it('should throw RequiredError when direction is missing', async () => {
            const _params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.direction;

            await expect(client.flexibleLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter direction was null or undefined when calling flexibleLoanAdjustLtv.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FlexibleLoanAdjustLtvRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                adjustmentAmount: 1.0,
                direction: 'direction_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'flexibleLoanAdjustLtv')
                .mockRejectedValueOnce(mockError);
            await expect(client.flexibleLoanAdjustLtv(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('flexibleLoanBorrow()', () => {
        it('should execute flexibleLoanBorrow() successfully with required parameters only', async () => {
            const params: FlexibleLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    loanCoin: 'BUSD',
                    loanAmount: '100.5',
                    collateralCoin: 'BNB',
                    collateralAmount: '50.5',
                    status: 'Succeeds',
                })
            );

            const spy = jest.spyOn(client, 'flexibleLoanBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FlexibleLoanBorrowResponse>)
            );
            const response = await client.flexibleLoanBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute flexibleLoanBorrow() successfully with optional parameters', async () => {
            const params: FlexibleLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanAmount: 1.0,
                collateralAmount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    loanCoin: 'BUSD',
                    loanAmount: '100.5',
                    collateralCoin: 'BNB',
                    collateralAmount: '50.5',
                    status: 'Succeeds',
                })
            );

            const spy = jest.spyOn(client, 'flexibleLoanBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FlexibleLoanBorrowResponse>)
            );
            const response = await client.flexibleLoanBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when loanCoin is missing', async () => {
            const _params: FlexibleLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.loanCoin;

            await expect(client.flexibleLoanBorrow(params)).rejects.toThrow(
                'Required parameter loanCoin was null or undefined when calling flexibleLoanBorrow.'
            );
        });

        it('should throw RequiredError when collateralCoin is missing', async () => {
            const _params: FlexibleLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.collateralCoin;

            await expect(client.flexibleLoanBorrow(params)).rejects.toThrow(
                'Required parameter collateralCoin was null or undefined when calling flexibleLoanBorrow.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FlexibleLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'flexibleLoanBorrow').mockRejectedValueOnce(mockError);
            await expect(client.flexibleLoanBorrow(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('flexibleLoanRepay()', () => {
        it('should execute flexibleLoanRepay() successfully with required parameters only', async () => {
            const params: FlexibleLoanRepayRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    loanCoin: 'BUSD',
                    collateralCoin: 'BNB',
                    remainingDebt: '100.5',
                    remainingCollateral: '5.253',
                    fullRepayment: false,
                    currentLTV: '0.25',
                    repayStatus: 'REPAID',
                })
            );

            const spy = jest.spyOn(client, 'flexibleLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FlexibleLoanRepayResponse>)
            );
            const response = await client.flexibleLoanRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute flexibleLoanRepay() successfully with optional parameters', async () => {
            const params: FlexibleLoanRepayRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1.0,
                collateralReturn: true,
                fullRepayment: false,
                repaymentType: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    loanCoin: 'BUSD',
                    collateralCoin: 'BNB',
                    remainingDebt: '100.5',
                    remainingCollateral: '5.253',
                    fullRepayment: false,
                    currentLTV: '0.25',
                    repayStatus: 'REPAID',
                })
            );

            const spy = jest.spyOn(client, 'flexibleLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FlexibleLoanRepayResponse>)
            );
            const response = await client.flexibleLoanRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when loanCoin is missing', async () => {
            const _params: FlexibleLoanRepayRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.loanCoin;

            await expect(client.flexibleLoanRepay(params)).rejects.toThrow(
                'Required parameter loanCoin was null or undefined when calling flexibleLoanRepay.'
            );
        });

        it('should throw RequiredError when collateralCoin is missing', async () => {
            const _params: FlexibleLoanRepayRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.collateralCoin;

            await expect(client.flexibleLoanRepay(params)).rejects.toThrow(
                'Required parameter collateralCoin was null or undefined when calling flexibleLoanRepay.'
            );
        });

        it('should throw RequiredError when repayAmount is missing', async () => {
            const _params: FlexibleLoanRepayRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.repayAmount;

            await expect(client.flexibleLoanRepay(params)).rejects.toThrow(
                'Required parameter repayAmount was null or undefined when calling flexibleLoanRepay.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FlexibleLoanRepayRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'flexibleLoanRepay').mockRejectedValueOnce(mockError);
            await expect(client.flexibleLoanRepay(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanAssetsData()', () => {
        it('should execute getFlexibleLoanAssetsData() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            flexibleInterestRate: '0.00000491',
                            flexibleMinLimit: '100',
                            flexibleMaxLimit: '1000000',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanAssetsDataResponse>)
            );
            const response = await client.getFlexibleLoanAssetsData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanAssetsData() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanAssetsDataRequest = {
                loanCoin: 'loanCoin_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            flexibleInterestRate: '0.00000491',
                            flexibleMinLimit: '100',
                            flexibleMaxLimit: '1000000',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanAssetsDataResponse>)
            );
            const response = await client.getFlexibleLoanAssetsData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanAssetsData')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanAssetsData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanBorrowHistory()', () => {
        it('should execute getFlexibleLoanBorrowHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            initialLoanAmount: '10000',
                            collateralCoin: 'BNB',
                            initialCollateralAmount: '49.27565492',
                            borrowTime: 1575018510000,
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanBorrowHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanBorrowHistoryResponse>)
            );
            const response = await client.getFlexibleLoanBorrowHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanBorrowHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanBorrowHistoryRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            initialLoanAmount: '10000',
                            collateralCoin: 'BNB',
                            initialCollateralAmount: '49.27565492',
                            borrowTime: 1575018510000,
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanBorrowHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanBorrowHistoryResponse>)
            );
            const response = await client.getFlexibleLoanBorrowHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanBorrowHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanBorrowHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanCollateralAssetsData()', () => {
        it('should execute getFlexibleLoanCollateralAssetsData() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            collateralCoin: 'BNB',
                            initialLTV: '0.65',
                            marginCallLTV: '0.75',
                            liquidationLTV: '0.83',
                            maxLimit: '1000000',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanCollateralAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanCollateralAssetsDataResponse>)
            );
            const response = await client.getFlexibleLoanCollateralAssetsData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanCollateralAssetsData() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanCollateralAssetsDataRequest = {
                collateralCoin: 'collateralCoin_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            collateralCoin: 'BNB',
                            initialLTV: '0.65',
                            marginCallLTV: '0.75',
                            liquidationLTV: '0.83',
                            maxLimit: '1000000',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanCollateralAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanCollateralAssetsDataResponse>)
            );
            const response = await client.getFlexibleLoanCollateralAssetsData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanCollateralAssetsData')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanCollateralAssetsData()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanInterestRateHistory()', () => {
        it('should execute getFlexibleLoanInterestRateHistory() successfully with required parameters only', async () => {
            const params: GetFlexibleLoanInterestRateHistoryRequest = {
                coin: 'coin_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        { coin: 'USDT', annualizedInterestRate: '0.0647', time: 1575018510000 },
                        { coin: 'USDT', annualizedInterestRate: '0.0647', time: 1575018510000 },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanInterestRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanInterestRateHistoryResponse>)
            );
            const response = await client.getFlexibleLoanInterestRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanInterestRateHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanInterestRateHistoryRequest = {
                coin: 'coin_example',
                recvWindow: 5000,
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        { coin: 'USDT', annualizedInterestRate: '0.0647', time: 1575018510000 },
                        { coin: 'USDT', annualizedInterestRate: '0.0647', time: 1575018510000 },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanInterestRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanInterestRateHistoryResponse>)
            );
            const response = await client.getFlexibleLoanInterestRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: GetFlexibleLoanInterestRateHistoryRequest = {
                coin: 'coin_example',
                recvWindow: 5000,
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.getFlexibleLoanInterestRateHistory(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling getFlexibleLoanInterestRateHistory.'
            );
        });

        it('should throw RequiredError when recvWindow is missing', async () => {
            const _params: GetFlexibleLoanInterestRateHistoryRequest = {
                coin: 'coin_example',
                recvWindow: 5000,
            };
            const params = Object.assign({ ..._params });
            delete params?.recvWindow;

            await expect(client.getFlexibleLoanInterestRateHistory(params)).rejects.toThrow(
                'Required parameter recvWindow was null or undefined when calling getFlexibleLoanInterestRateHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFlexibleLoanInterestRateHistoryRequest = {
                coin: 'coin_example',
                recvWindow: 5000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanInterestRateHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanInterestRateHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanLiquidationHistory()', () => {
        it('should execute getFlexibleLoanLiquidationHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            liquidationDebt: '10000',
                            collateralCoin: 'BNB',
                            liquidationCollateralAmount: '123',
                            returnCollateralAmount: '0.2',
                            liquidationFee: '1.2',
                            liquidationStartingPrice: '49.27565492',
                            liquidationStartingTime: 1575018510000,
                            status: 'Liquidated',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanLiquidationHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanLiquidationHistoryResponse>)
            );
            const response = await client.getFlexibleLoanLiquidationHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanLiquidationHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanLiquidationHistoryRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            liquidationDebt: '10000',
                            collateralCoin: 'BNB',
                            liquidationCollateralAmount: '123',
                            returnCollateralAmount: '0.2',
                            liquidationFee: '1.2',
                            liquidationStartingPrice: '49.27565492',
                            liquidationStartingTime: 1575018510000,
                            status: 'Liquidated',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanLiquidationHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanLiquidationHistoryResponse>)
            );
            const response = await client.getFlexibleLoanLiquidationHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanLiquidationHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanLiquidationHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanLtvAdjustmentHistory()', () => {
        it('should execute getFlexibleLoanLtvAdjustmentHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            collateralCoin: 'BNB',
                            direction: 'ADDITIONAL',
                            collateralAmount: '5.235',
                            preLTV: '0.78',
                            afterLTV: '0.56',
                            adjustTime: 1575018510000,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanLtvAdjustmentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanLtvAdjustmentHistoryResponse>)
            );
            const response = await client.getFlexibleLoanLtvAdjustmentHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanLtvAdjustmentHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanLtvAdjustmentHistoryRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            collateralCoin: 'BNB',
                            direction: 'ADDITIONAL',
                            collateralAmount: '5.235',
                            preLTV: '0.78',
                            afterLTV: '0.56',
                            adjustTime: 1575018510000,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanLtvAdjustmentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanLtvAdjustmentHistoryResponse>)
            );
            const response = await client.getFlexibleLoanLtvAdjustmentHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanLtvAdjustmentHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanLtvAdjustmentHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanOngoingOrders()', () => {
        it('should execute getFlexibleLoanOngoingOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            totalDebt: '10000',
                            collateralCoin: 'BNB',
                            collateralAmount: '49.27565492',
                            currentLTV: '0.57',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanOngoingOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanOngoingOrdersResponse>)
            );
            const response = await client.getFlexibleLoanOngoingOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanOngoingOrders() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanOngoingOrdersRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            totalDebt: '10000',
                            collateralCoin: 'BNB',
                            collateralAmount: '49.27565492',
                            currentLTV: '0.57',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanOngoingOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanOngoingOrdersResponse>)
            );
            const response = await client.getFlexibleLoanOngoingOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanOngoingOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanOngoingOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleLoanRepaymentHistory()', () => {
        it('should execute getFlexibleLoanRepaymentHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            repayAmount: '10000',
                            collateralCoin: 'BNB',
                            collateralReturn: '49.27565492',
                            repayStatus: 'REPAID',
                            repayTime: 1575018510000,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanRepaymentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanRepaymentHistoryResponse>)
            );
            const response = await client.getFlexibleLoanRepaymentHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleLoanRepaymentHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleLoanRepaymentHistoryRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'BUSD',
                            repayAmount: '10000',
                            collateralCoin: 'BNB',
                            collateralReturn: '49.27565492',
                            repayStatus: 'REPAID',
                            repayTime: 1575018510000,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleLoanRepaymentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleLoanRepaymentHistoryResponse>)
            );
            const response = await client.getFlexibleLoanRepaymentHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleLoanRepaymentHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleLoanRepaymentHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
