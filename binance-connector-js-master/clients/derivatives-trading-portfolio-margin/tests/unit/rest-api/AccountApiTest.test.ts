/**
 * Binance Derivatives Trading Portfolio Margin REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountBalanceRequest,
    AccountInformationRequest,
    BnbTransferRequest,
    ChangeAutoRepayFuturesStatusRequest,
    ChangeCmInitialLeverageRequest,
    ChangeCmPositionModeRequest,
    ChangeUmInitialLeverageRequest,
    ChangeUmPositionModeRequest,
    CmNotionalAndLeverageBracketsRequest,
    FundAutoCollectionRequest,
    FundCollectionByAssetRequest,
    GetAutoRepayFuturesStatusRequest,
    GetCmAccountDetailRequest,
    GetCmCurrentPositionModeRequest,
    GetCmIncomeHistoryRequest,
    GetDownloadIdForUmFuturesOrderHistoryRequest,
    GetDownloadIdForUmFuturesTradeHistoryRequest,
    GetDownloadIdForUmFuturesTransactionHistoryRequest,
    GetMarginBorrowLoanInterestHistoryRequest,
    GetUmAccountDetailRequest,
    GetUmAccountDetailV2Request,
    GetUmCurrentPositionModeRequest,
    GetUmFuturesOrderDownloadLinkByIdRequest,
    GetUmFuturesTradeDownloadLinkByIdRequest,
    GetUmFuturesTransactionDownloadLinkByIdRequest,
    GetUmIncomeHistoryRequest,
    GetUserCommissionRateForCmRequest,
    GetUserCommissionRateForUmRequest,
    MarginMaxBorrowRequest,
    PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest,
    QueryCmPositionInformationRequest,
    QueryMarginLoanRecordRequest,
    QueryMarginMaxWithdrawRequest,
    QueryMarginRepayRecordRequest,
    QueryPortfolioMarginNegativeBalanceInterestHistoryRequest,
    QueryUmPositionInformationRequest,
    QueryUserNegativeBalanceAutoExchangeRecordRequest,
    QueryUserRateLimitRequest,
    RepayFuturesNegativeBalanceRequest,
    UmFuturesAccountConfigurationRequest,
    UmFuturesSymbolConfigurationRequest,
    UmNotionalAndLeverageBracketsRequest,
} from '../../../src/rest-api';
import type {
    AccountBalanceResponse,
    AccountInformationResponse,
    BnbTransferResponse,
    ChangeAutoRepayFuturesStatusResponse,
    ChangeCmInitialLeverageResponse,
    ChangeCmPositionModeResponse,
    ChangeUmInitialLeverageResponse,
    ChangeUmPositionModeResponse,
    CmNotionalAndLeverageBracketsResponse,
    FundAutoCollectionResponse,
    FundCollectionByAssetResponse,
    GetAutoRepayFuturesStatusResponse,
    GetCmAccountDetailResponse,
    GetCmCurrentPositionModeResponse,
    GetCmIncomeHistoryResponse,
    GetDownloadIdForUmFuturesOrderHistoryResponse,
    GetDownloadIdForUmFuturesTradeHistoryResponse,
    GetDownloadIdForUmFuturesTransactionHistoryResponse,
    GetMarginBorrowLoanInterestHistoryResponse,
    GetUmAccountDetailResponse,
    GetUmAccountDetailV2Response,
    GetUmCurrentPositionModeResponse,
    GetUmFuturesOrderDownloadLinkByIdResponse,
    GetUmFuturesTradeDownloadLinkByIdResponse,
    GetUmFuturesTransactionDownloadLinkByIdResponse,
    GetUmIncomeHistoryResponse,
    GetUserCommissionRateForCmResponse,
    GetUserCommissionRateForUmResponse,
    MarginMaxBorrowResponse,
    PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse,
    QueryCmPositionInformationResponse,
    QueryMarginLoanRecordResponse,
    QueryMarginMaxWithdrawResponse,
    QueryMarginRepayRecordResponse,
    QueryPortfolioMarginNegativeBalanceInterestHistoryResponse,
    QueryUmPositionInformationResponse,
    QueryUserNegativeBalanceAutoExchangeRecordResponse,
    QueryUserRateLimitResponse,
    RepayFuturesNegativeBalanceResponse,
    UmFuturesAccountConfigurationResponse,
    UmFuturesSymbolConfigurationResponse,
    UmNotionalAndLeverageBracketsResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountBalance()', () => {
        it('should execute accountBalance() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        totalWalletBalance: '122607.35137903',
                        crossMarginAsset: '92.27530794',
                        crossMarginBorrowed: '10.00000000',
                        crossMarginFree: '100.00000000',
                        crossMarginInterest: '0.72469206',
                        crossMarginLocked: '3.00000000',
                        umWalletBalance: '0.00000000',
                        umUnrealizedPNL: '23.72469206',
                        cmWalletBalance: '23.72469206',
                        cmUnrealizedPNL: '',
                        updateTime: 1617939110373,
                        negativeBalance: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountBalanceResponse>)
            );
            const response = await client.accountBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountBalance() successfully with optional parameters', async () => {
            const params: AccountBalanceRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        totalWalletBalance: '122607.35137903',
                        crossMarginAsset: '92.27530794',
                        crossMarginBorrowed: '10.00000000',
                        crossMarginFree: '100.00000000',
                        crossMarginInterest: '0.72469206',
                        crossMarginLocked: '3.00000000',
                        umWalletBalance: '0.00000000',
                        umUnrealizedPNL: '23.72469206',
                        cmWalletBalance: '23.72469206',
                        cmUnrealizedPNL: '',
                        updateTime: 1617939110373,
                        negativeBalance: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountBalanceResponse>)
            );
            const response = await client.accountBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountBalance').mockRejectedValueOnce(mockError);
            await expect(client.accountBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountInformation()', () => {
        it('should execute accountInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    uniMMR: '5167.92171923',
                    accountEquity: '122607.35137903',
                    actualEquity: '73.47428058',
                    accountInitialMargin: '23.72469206',
                    accountMaintMargin: '23.72469206',
                    accountStatus: 'NORMAL',
                    virtualMaxWithdrawAmount: '1627523.32459208',
                    totalAvailableBalance: '',
                    totalMarginOpenLoss: '',
                    updateTime: 1657707212154,
                })
            );

            const spy = jest.spyOn(client, 'accountInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationResponse>)
            );
            const response = await client.accountInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInformation() successfully with optional parameters', async () => {
            const params: AccountInformationRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    uniMMR: '5167.92171923',
                    accountEquity: '122607.35137903',
                    actualEquity: '73.47428058',
                    accountInitialMargin: '23.72469206',
                    accountMaintMargin: '23.72469206',
                    accountStatus: 'NORMAL',
                    virtualMaxWithdrawAmount: '1627523.32459208',
                    totalAvailableBalance: '',
                    totalMarginOpenLoss: '',
                    updateTime: 1657707212154,
                })
            );

            const spy = jest.spyOn(client, 'accountInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationResponse>)
            );
            const response = await client.accountInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInformation').mockRejectedValueOnce(mockError);
            await expect(client.accountInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('bnbTransfer()', () => {
        it('should execute bnbTransfer() successfully with required parameters only', async () => {
            const params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 100000001 }));

            const spy = jest.spyOn(client, 'bnbTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BnbTransferResponse>)
            );
            const response = await client.bnbTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute bnbTransfer() successfully with optional parameters', async () => {
            const params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 100000001 }));

            const spy = jest.spyOn(client, 'bnbTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BnbTransferResponse>)
            );
            const response = await client.bnbTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.bnbTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling bnbTransfer.'
            );
        });

        it('should throw RequiredError when transferSide is missing', async () => {
            const _params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.transferSide;

            await expect(client.bnbTransfer(params)).rejects.toThrow(
                'Required parameter transferSide was null or undefined when calling bnbTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'bnbTransfer').mockRejectedValueOnce(mockError);
            await expect(client.bnbTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeAutoRepayFuturesStatus()', () => {
        it('should execute changeAutoRepayFuturesStatus() successfully with required parameters only', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'changeAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeAutoRepayFuturesStatusResponse>)
            );
            const response = await client.changeAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeAutoRepayFuturesStatus() successfully with optional parameters', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'changeAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeAutoRepayFuturesStatusResponse>)
            );
            const response = await client.changeAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when autoRepay is missing', async () => {
            const _params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
            };
            const params = Object.assign({ ..._params });
            delete params?.autoRepay;

            await expect(client.changeAutoRepayFuturesStatus(params)).rejects.toThrow(
                'Required parameter autoRepay was null or undefined when calling changeAutoRepayFuturesStatus.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeAutoRepayFuturesStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeAutoRepayFuturesStatus(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('changeCmInitialLeverage()', () => {
        it('should execute changeCmInitialLeverage() successfully with required parameters only', async () => {
            const params: ChangeCmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxQty: '1000', symbol: 'BTCUSD_200925' })
            );

            const spy = jest.spyOn(client, 'changeCmInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeCmInitialLeverageResponse>)
            );
            const response = await client.changeCmInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeCmInitialLeverage() successfully with optional parameters', async () => {
            const params: ChangeCmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxQty: '1000', symbol: 'BTCUSD_200925' })
            );

            const spy = jest.spyOn(client, 'changeCmInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeCmInitialLeverageResponse>)
            );
            const response = await client.changeCmInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeCmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeCmInitialLeverage(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeCmInitialLeverage.'
            );
        });

        it('should throw RequiredError when leverage is missing', async () => {
            const _params: ChangeCmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.leverage;

            await expect(client.changeCmInitialLeverage(params)).rejects.toThrow(
                'Required parameter leverage was null or undefined when calling changeCmInitialLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeCmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeCmInitialLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeCmInitialLeverage(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeCmPositionMode()', () => {
        it('should execute changeCmPositionMode() successfully with required parameters only', async () => {
            const params: ChangeCmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeCmPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeCmPositionModeResponse>)
            );
            const response = await client.changeCmPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeCmPositionMode() successfully with optional parameters', async () => {
            const params: ChangeCmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeCmPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeCmPositionModeResponse>)
            );
            const response = await client.changeCmPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when dualSidePosition is missing', async () => {
            const _params: ChangeCmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.dualSidePosition;

            await expect(client.changeCmPositionMode(params)).rejects.toThrow(
                'Required parameter dualSidePosition was null or undefined when calling changeCmPositionMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeCmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changeCmPositionMode').mockRejectedValueOnce(mockError);
            await expect(client.changeCmPositionMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeUmInitialLeverage()', () => {
        it('should execute changeUmInitialLeverage() successfully with required parameters only', async () => {
            const params: ChangeUmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxNotionalValue: '1000000', symbol: 'BTCUSDT' })
            );

            const spy = jest.spyOn(client, 'changeUmInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeUmInitialLeverageResponse>)
            );
            const response = await client.changeUmInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeUmInitialLeverage() successfully with optional parameters', async () => {
            const params: ChangeUmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ leverage: 21, maxNotionalValue: '1000000', symbol: 'BTCUSDT' })
            );

            const spy = jest.spyOn(client, 'changeUmInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeUmInitialLeverageResponse>)
            );
            const response = await client.changeUmInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeUmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeUmInitialLeverage(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeUmInitialLeverage.'
            );
        });

        it('should throw RequiredError when leverage is missing', async () => {
            const _params: ChangeUmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.leverage;

            await expect(client.changeUmInitialLeverage(params)).rejects.toThrow(
                'Required parameter leverage was null or undefined when calling changeUmInitialLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeUmInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeUmInitialLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeUmInitialLeverage(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeUmPositionMode()', () => {
        it('should execute changeUmPositionMode() successfully with required parameters only', async () => {
            const params: ChangeUmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeUmPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeUmPositionModeResponse>)
            );
            const response = await client.changeUmPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeUmPositionMode() successfully with optional parameters', async () => {
            const params: ChangeUmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 200, msg: 'success' }));

            const spy = jest.spyOn(client, 'changeUmPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeUmPositionModeResponse>)
            );
            const response = await client.changeUmPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when dualSidePosition is missing', async () => {
            const _params: ChangeUmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.dualSidePosition;

            await expect(client.changeUmPositionMode(params)).rejects.toThrow(
                'Required parameter dualSidePosition was null or undefined when calling changeUmPositionMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeUmPositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changeUmPositionMode').mockRejectedValueOnce(mockError);
            await expect(client.changeUmPositionMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cmNotionalAndLeverageBrackets()', () => {
        it('should execute cmNotionalAndLeverageBrackets() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        brackets: [
                            {
                                bracket: 1,
                                initialLeverage: 125,
                                qtyCap: 50,
                                qtyFloor: 0,
                                maintMarginRatio: 0.004,
                                cum: 0,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'cmNotionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CmNotionalAndLeverageBracketsResponse>)
            );
            const response = await client.cmNotionalAndLeverageBrackets();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cmNotionalAndLeverageBrackets() successfully with optional parameters', async () => {
            const params: CmNotionalAndLeverageBracketsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_PERP',
                        brackets: [
                            {
                                bracket: 1,
                                initialLeverage: 125,
                                qtyCap: 50,
                                qtyFloor: 0,
                                maintMarginRatio: 0.004,
                                cum: 0,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'cmNotionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CmNotionalAndLeverageBracketsResponse>)
            );
            const response = await client.cmNotionalAndLeverageBrackets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cmNotionalAndLeverageBrackets')
                .mockRejectedValueOnce(mockError);
            await expect(client.cmNotionalAndLeverageBrackets()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fundAutoCollection()', () => {
        it('should execute fundAutoCollection() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundAutoCollection').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundAutoCollectionResponse>)
            );
            const response = await client.fundAutoCollection();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundAutoCollection() successfully with optional parameters', async () => {
            const params: FundAutoCollectionRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundAutoCollection').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundAutoCollectionResponse>)
            );
            const response = await client.fundAutoCollection(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fundAutoCollection').mockRejectedValueOnce(mockError);
            await expect(client.fundAutoCollection()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fundCollectionByAsset()', () => {
        it('should execute fundCollectionByAsset() successfully with required parameters only', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundCollectionByAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundCollectionByAssetResponse>)
            );
            const response = await client.fundCollectionByAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundCollectionByAsset() successfully with optional parameters', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundCollectionByAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundCollectionByAssetResponse>)
            );
            const response = await client.fundCollectionByAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.fundCollectionByAsset(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling fundCollectionByAsset.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fundCollectionByAsset')
                .mockRejectedValueOnce(mockError);
            await expect(client.fundCollectionByAsset(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAutoRepayFuturesStatus()', () => {
        it('should execute getAutoRepayFuturesStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ autoRepay: true }));

            const spy = jest.spyOn(client, 'getAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAutoRepayFuturesStatusResponse>)
            );
            const response = await client.getAutoRepayFuturesStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAutoRepayFuturesStatus() successfully with optional parameters', async () => {
            const params: GetAutoRepayFuturesStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ autoRepay: true }));

            const spy = jest.spyOn(client, 'getAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAutoRepayFuturesStatusResponse>)
            );
            const response = await client.getAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getAutoRepayFuturesStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.getAutoRepayFuturesStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCmAccountDetail()', () => {
        it('should execute getCmAccountDetail() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            asset: 'BTC',
                            crossWalletBalance: '0.00241969',
                            crossUnPnl: '0.00000000',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSD_201225',
                            positionAmt: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '125',
                            positionSide: 'BOTH',
                            entryPrice: '0.0',
                            maxQty: '50',
                            updateTime: 0,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getCmAccountDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCmAccountDetailResponse>)
            );
            const response = await client.getCmAccountDetail();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCmAccountDetail() successfully with optional parameters', async () => {
            const params: GetCmAccountDetailRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            asset: 'BTC',
                            crossWalletBalance: '0.00241969',
                            crossUnPnl: '0.00000000',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSD_201225',
                            positionAmt: '0',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '125',
                            positionSide: 'BOTH',
                            entryPrice: '0.0',
                            maxQty: '50',
                            updateTime: 0,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getCmAccountDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCmAccountDetailResponse>)
            );
            const response = await client.getCmAccountDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getCmAccountDetail').mockRejectedValueOnce(mockError);
            await expect(client.getCmAccountDetail()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCmCurrentPositionMode()', () => {
        it('should execute getCmCurrentPositionMode() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ dualSidePosition: true }));

            const spy = jest.spyOn(client, 'getCmCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCmCurrentPositionModeResponse>)
            );
            const response = await client.getCmCurrentPositionMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCmCurrentPositionMode() successfully with optional parameters', async () => {
            const params: GetCmCurrentPositionModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ dualSidePosition: true }));

            const spy = jest.spyOn(client, 'getCmCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCmCurrentPositionModeResponse>)
            );
            const response = await client.getCmCurrentPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCmCurrentPositionMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCmCurrentPositionMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCmIncomeHistory()', () => {
        it('should execute getCmIncomeHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: '',
                        incomeType: 'TRANSFER',
                        income: '-0.37500000',
                        asset: 'BTC',
                        info: 'WITHDRAW',
                        time: 1570608000000,
                        tranId: '9689322392',
                        tradeId: '',
                    },
                    {
                        symbol: 'BTCUSD_200925',
                        incomeType: 'COMMISSION',
                        income: '-0.01000000',
                        asset: 'BTC',
                        info: '',
                        time: 1570636800000,
                        tranId: '9689322392',
                        tradeId: '2059192',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getCmIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCmIncomeHistoryResponse>)
            );
            const response = await client.getCmIncomeHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCmIncomeHistory() successfully with optional parameters', async () => {
            const params: GetCmIncomeHistoryRequest = {
                symbol: 'symbol_example',
                incomeType: 'incomeType_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: '',
                        incomeType: 'TRANSFER',
                        income: '-0.37500000',
                        asset: 'BTC',
                        info: 'WITHDRAW',
                        time: 1570608000000,
                        tranId: '9689322392',
                        tradeId: '',
                    },
                    {
                        symbol: 'BTCUSD_200925',
                        incomeType: 'COMMISSION',
                        income: '-0.01000000',
                        asset: 'BTC',
                        info: '',
                        time: 1570636800000,
                        tranId: '9689322392',
                        tradeId: '2059192',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getCmIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCmIncomeHistoryResponse>)
            );
            const response = await client.getCmIncomeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getCmIncomeHistory').mockRejectedValueOnce(mockError);
            await expect(client.getCmIncomeHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForUmFuturesOrderHistory()', () => {
        it('should execute getDownloadIdForUmFuturesOrderHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForUmFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForUmFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForUmFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForUmFuturesOrderHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForUmFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForUmFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForUmFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForUmFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForUmFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForUmFuturesOrderHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForUmFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForUmFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForUmFuturesOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForUmFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForUmFuturesOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForUmFuturesOrderHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForUmFuturesTradeHistory()', () => {
        it('should execute getDownloadIdForUmFuturesTradeHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForUmFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForUmFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForUmFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForUmFuturesTradeHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForUmFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest.spyOn(client, 'getDownloadIdForUmFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForUmFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForUmFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForUmFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForUmFuturesTradeHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForUmFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForUmFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForUmFuturesTradeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForUmFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForUmFuturesTradeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForUmFuturesTradeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForUmFuturesTransactionHistory()', () => {
        it('should execute getDownloadIdForUmFuturesTransactionHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForUmFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest
                .spyOn(client, 'getDownloadIdForUmFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForUmFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForUmFuturesTransactionHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForUmFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    avgCostTimestampOfLast30d: 7241837,
                    downloadId: '546975389218332672',
                })
            );

            const spy = jest
                .spyOn(client, 'getDownloadIdForUmFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForUmFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForUmFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.getDownloadIdForUmFuturesTransactionHistory(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForUmFuturesTransactionHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForUmFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.getDownloadIdForUmFuturesTransactionHistory(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForUmFuturesTransactionHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForUmFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForUmFuturesTransactionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.getDownloadIdForUmFuturesTransactionHistory(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getMarginBorrowLoanInterestHistory()', () => {
        it('should execute getMarginBorrowLoanInterestHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            txId: 1352286576452864800,
                            interestAccuredTime: 1672160400000,
                            asset: 'USDT',
                            rawAsset: 'USDT',
                            principal: '45.3313',
                            interest: '0.00024995',
                            interestRate: '0.00013233',
                            type: 'ON_BORROW',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getMarginBorrowLoanInterestHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetMarginBorrowLoanInterestHistoryResponse>)
            );
            const response = await client.getMarginBorrowLoanInterestHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getMarginBorrowLoanInterestHistory() successfully with optional parameters', async () => {
            const params: GetMarginBorrowLoanInterestHistoryRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                archived: '',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            txId: 1352286576452864800,
                            interestAccuredTime: 1672160400000,
                            asset: 'USDT',
                            rawAsset: 'USDT',
                            principal: '45.3313',
                            interest: '0.00024995',
                            interestRate: '0.00013233',
                            type: 'ON_BORROW',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getMarginBorrowLoanInterestHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetMarginBorrowLoanInterestHistoryResponse>)
            );
            const response = await client.getMarginBorrowLoanInterestHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getMarginBorrowLoanInterestHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getMarginBorrowLoanInterestHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getUmAccountDetail()', () => {
        it('should execute getUmAccountDetail() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            asset: 'USDT',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '100',
                            entryPrice: '0.00000',
                            maxNotional: '250000',
                            bidNotional: '0',
                            askNotional: '0',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getUmAccountDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmAccountDetailResponse>)
            );
            const response = await client.getUmAccountDetail();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmAccountDetail() successfully with optional parameters', async () => {
            const params: GetUmAccountDetailRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            asset: 'USDT',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionInitialMargin: '0',
                            openOrderInitialMargin: '0',
                            leverage: '100',
                            entryPrice: '0.00000',
                            maxNotional: '250000',
                            bidNotional: '0',
                            askNotional: '0',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getUmAccountDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmAccountDetailResponse>)
            );
            const response = await client.getUmAccountDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getUmAccountDetail').mockRejectedValueOnce(mockError);
            await expect(client.getUmAccountDetail()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getUmAccountDetailV2()', () => {
        it('should execute getUmAccountDetailV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            asset: 'USDT',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                            notional: '86.98650000',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getUmAccountDetailV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmAccountDetailV2Response>)
            );
            const response = await client.getUmAccountDetailV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmAccountDetailV2() successfully with optional parameters', async () => {
            const params: GetUmAccountDetailV2Request = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            asset: 'USDT',
                            crossWalletBalance: '23.72469206',
                            crossUnPnl: '0.00000000',
                            maintMargin: '0.00000000',
                            initialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            openOrderInitialMargin: '0.00000000',
                            updateTime: 1625474304765,
                        },
                    ],
                    positions: [
                        {
                            symbol: 'BTCUSDT',
                            initialMargin: '0',
                            maintMargin: '0',
                            unrealizedProfit: '0.00000000',
                            positionSide: 'BOTH',
                            positionAmt: '0',
                            updateTime: 0,
                            notional: '86.98650000',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getUmAccountDetailV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmAccountDetailV2Response>)
            );
            const response = await client.getUmAccountDetailV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getUmAccountDetailV2').mockRejectedValueOnce(mockError);
            await expect(client.getUmAccountDetailV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getUmCurrentPositionMode()', () => {
        it('should execute getUmCurrentPositionMode() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ dualSidePosition: true }));

            const spy = jest.spyOn(client, 'getUmCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmCurrentPositionModeResponse>)
            );
            const response = await client.getUmCurrentPositionMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmCurrentPositionMode() successfully with optional parameters', async () => {
            const params: GetUmCurrentPositionModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ dualSidePosition: true }));

            const spy = jest.spyOn(client, 'getUmCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmCurrentPositionModeResponse>)
            );
            const response = await client.getUmCurrentPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUmCurrentPositionMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUmCurrentPositionMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getUmFuturesOrderDownloadLinkById()', () => {
        it('should execute getUmFuturesOrderDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetUmFuturesOrderDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    s3Link: null,
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest.spyOn(client, 'getUmFuturesOrderDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>)
            );
            const response = await client.getUmFuturesOrderDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmFuturesOrderDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetUmFuturesOrderDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    s3Link: null,
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest.spyOn(client, 'getUmFuturesOrderDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>)
            );
            const response = await client.getUmFuturesOrderDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetUmFuturesOrderDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getUmFuturesOrderDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getUmFuturesOrderDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetUmFuturesOrderDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUmFuturesOrderDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUmFuturesOrderDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getUmFuturesTradeDownloadLinkById()', () => {
        it('should execute getUmFuturesTradeDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetUmFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    s3Link: null,
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest.spyOn(client, 'getUmFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getUmFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmFuturesTradeDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetUmFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    s3Link: null,
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest.spyOn(client, 'getUmFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getUmFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetUmFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getUmFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getUmFuturesTradeDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetUmFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUmFuturesTradeDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUmFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getUmFuturesTransactionDownloadLinkById()', () => {
        it('should execute getUmFuturesTransactionDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetUmFuturesTransactionDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    s3Link: null,
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest
                .spyOn(client, 'getUmFuturesTransactionDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>)
                );
            const response = await client.getUmFuturesTransactionDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmFuturesTransactionDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetUmFuturesTransactionDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    downloadId: '545923594199212032',
                    status: 'processing',
                    url: '',
                    s3Link: null,
                    notified: false,
                    expirationTimestamp: -1,
                    isExpired: null,
                })
            );

            const spy = jest
                .spyOn(client, 'getUmFuturesTransactionDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>)
                );
            const response = await client.getUmFuturesTransactionDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetUmFuturesTransactionDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getUmFuturesTransactionDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getUmFuturesTransactionDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetUmFuturesTransactionDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUmFuturesTransactionDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUmFuturesTransactionDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getUmIncomeHistory()', () => {
        it('should execute getUmIncomeHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: '',
                        incomeType: 'TRANSFER',
                        income: '-0.37500000',
                        asset: 'USDT',
                        info: 'TRANSFER',
                        time: 1570608000000,
                        tranId: '9689322392',
                        tradeId: '',
                    },
                    {
                        symbol: 'BTCUSDT',
                        incomeType: 'COMMISSION',
                        income: '-0.01000000',
                        asset: 'USDT',
                        info: 'COMMISSION',
                        time: 1570636800000,
                        tranId: '9689322392',
                        tradeId: '2059192',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getUmIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmIncomeHistoryResponse>)
            );
            const response = await client.getUmIncomeHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmIncomeHistory() successfully with optional parameters', async () => {
            const params: GetUmIncomeHistoryRequest = {
                symbol: 'symbol_example',
                incomeType: 'incomeType_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: '',
                        incomeType: 'TRANSFER',
                        income: '-0.37500000',
                        asset: 'USDT',
                        info: 'TRANSFER',
                        time: 1570608000000,
                        tranId: '9689322392',
                        tradeId: '',
                    },
                    {
                        symbol: 'BTCUSDT',
                        incomeType: 'COMMISSION',
                        income: '-0.01000000',
                        asset: 'USDT',
                        info: 'COMMISSION',
                        time: 1570636800000,
                        tranId: '9689322392',
                        tradeId: '2059192',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getUmIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmIncomeHistoryResponse>)
            );
            const response = await client.getUmIncomeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getUmIncomeHistory').mockRejectedValueOnce(mockError);
            await expect(client.getUmIncomeHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getUserCommissionRateForCm()', () => {
        it('should execute getUserCommissionRateForCm() successfully with required parameters only', async () => {
            const params: GetUserCommissionRateForCmRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSD_PERP',
                    makerCommissionRate: '0.00015',
                    takerCommissionRate: '0.00040',
                })
            );

            const spy = jest.spyOn(client, 'getUserCommissionRateForCm').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUserCommissionRateForCmResponse>)
            );
            const response = await client.getUserCommissionRateForCm(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUserCommissionRateForCm() successfully with optional parameters', async () => {
            const params: GetUserCommissionRateForCmRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSD_PERP',
                    makerCommissionRate: '0.00015',
                    takerCommissionRate: '0.00040',
                })
            );

            const spy = jest.spyOn(client, 'getUserCommissionRateForCm').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUserCommissionRateForCmResponse>)
            );
            const response = await client.getUserCommissionRateForCm(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetUserCommissionRateForCmRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getUserCommissionRateForCm(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getUserCommissionRateForCm.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetUserCommissionRateForCmRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUserCommissionRateForCm')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUserCommissionRateForCm(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getUserCommissionRateForUm()', () => {
        it('should execute getUserCommissionRateForUm() successfully with required parameters only', async () => {
            const params: GetUserCommissionRateForUmRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    makerCommissionRate: '0.0002',
                    takerCommissionRate: '0.0004',
                })
            );

            const spy = jest.spyOn(client, 'getUserCommissionRateForUm').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUserCommissionRateForUmResponse>)
            );
            const response = await client.getUserCommissionRateForUm(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUserCommissionRateForUm() successfully with optional parameters', async () => {
            const params: GetUserCommissionRateForUmRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    symbol: 'BTCUSDT',
                    makerCommissionRate: '0.0002',
                    takerCommissionRate: '0.0004',
                })
            );

            const spy = jest.spyOn(client, 'getUserCommissionRateForUm').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUserCommissionRateForUmResponse>)
            );
            const response = await client.getUserCommissionRateForUm(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetUserCommissionRateForUmRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getUserCommissionRateForUm(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getUserCommissionRateForUm.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetUserCommissionRateForUmRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUserCommissionRateForUm')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUserCommissionRateForUm(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('marginMaxBorrow()', () => {
        it('should execute marginMaxBorrow() successfully with required parameters only', async () => {
            const params: MarginMaxBorrowRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(JSONStringify({ amount: '1.69248805', borrowLimit: '60' }));

            const spy = jest.spyOn(client, 'marginMaxBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginMaxBorrowResponse>)
            );
            const response = await client.marginMaxBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginMaxBorrow() successfully with optional parameters', async () => {
            const params: MarginMaxBorrowRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ amount: '1.69248805', borrowLimit: '60' }));

            const spy = jest.spyOn(client, 'marginMaxBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginMaxBorrowResponse>)
            );
            const response = await client.marginMaxBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginMaxBorrowRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginMaxBorrow(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginMaxBorrow.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginMaxBorrowRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'marginMaxBorrow').mockRejectedValueOnce(mockError);
            await expect(client.marginMaxBorrow(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('portfolioMarginUmTradingQuantitativeRulesIndicators()', () => {
        it('should execute portfolioMarginUmTradingQuantitativeRulesIndicators() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    indicators: {
                        BTCUSDT: [
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'UFR',
                                value: 0.05,
                                triggerValue: 0.995,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'IFER',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'GCR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'DR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                        ],
                        ACCOUNT: [
                            {
                                indicator: 'TMV',
                                value: 10,
                                triggerValue: 1,
                                plannedRecoverTime: 1644919865000,
                                isLocked: true,
                            },
                        ],
                    },
                    updateTime: 1644913304748,
                })
            );

            const spy = jest
                .spyOn(client, 'portfolioMarginUmTradingQuantitativeRulesIndicators')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>)
                );
            const response = await client.portfolioMarginUmTradingQuantitativeRulesIndicators();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute portfolioMarginUmTradingQuantitativeRulesIndicators() successfully with optional parameters', async () => {
            const params: PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    indicators: {
                        BTCUSDT: [
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'UFR',
                                value: 0.05,
                                triggerValue: 0.995,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'IFER',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'GCR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                            {
                                isLocked: true,
                                plannedRecoverTime: 1545741270000,
                                indicator: 'DR',
                                value: 0.99,
                                triggerValue: 0.99,
                            },
                        ],
                        ACCOUNT: [
                            {
                                indicator: 'TMV',
                                value: 10,
                                triggerValue: 1,
                                plannedRecoverTime: 1644919865000,
                                isLocked: true,
                            },
                        ],
                    },
                    updateTime: 1644913304748,
                })
            );

            const spy = jest
                .spyOn(client, 'portfolioMarginUmTradingQuantitativeRulesIndicators')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>)
                );
            const response =
                await client.portfolioMarginUmTradingQuantitativeRulesIndicators(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'portfolioMarginUmTradingQuantitativeRulesIndicators')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.portfolioMarginUmTradingQuantitativeRulesIndicators()
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCmPositionInformation()', () => {
        it('should execute queryCmPositionInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '6170.20509059',
                        leverage: '125',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                        maxQty: '50',
                        notionalValue: '0.00084827',
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '6170.20509059',
                        leverage: '125',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                        maxQty: '50',
                        notionalValue: '0.00084827',
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '6170.20509059',
                        leverage: '125',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                        maxQty: '50',
                        notionalValue: '0.00084827',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCmPositionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmPositionInformationResponse>)
            );
            const response = await client.queryCmPositionInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCmPositionInformation() successfully with optional parameters', async () => {
            const params: QueryCmPositionInformationRequest = {
                marginAsset: 'marginAsset_example',
                pair: 'pair_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '6170.20509059',
                        leverage: '125',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                        maxQty: '50',
                        notionalValue: '0.00084827',
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '6170.20509059',
                        leverage: '125',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                        maxQty: '50',
                        notionalValue: '0.00084827',
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '1',
                        entryPrice: '11707.70000003',
                        markPrice: '11788.66626667',
                        unRealizedProfit: '0.00005866',
                        liquidationPrice: '6170.20509059',
                        leverage: '125',
                        positionSide: 'LONG',
                        updateTime: 1627026881327,
                        maxQty: '50',
                        notionalValue: '0.00084827',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCmPositionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmPositionInformationResponse>)
            );
            const response = await client.queryCmPositionInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCmPositionInformation')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCmPositionInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginLoanRecord()', () => {
        it('should execute queryMarginLoanRecord() successfully with required parameters only', async () => {
            const params: QueryMarginLoanRecordRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            txId: 12807067523,
                            asset: 'BNB',
                            principal: '0.84624403',
                            timestamp: 1555056425000,
                            status: 'CONFIRMED',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryMarginLoanRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginLoanRecordResponse>)
            );
            const response = await client.queryMarginLoanRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginLoanRecord() successfully with optional parameters', async () => {
            const params: QueryMarginLoanRecordRequest = {
                asset: 'asset_example',
                txId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                archived: '',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            txId: 12807067523,
                            asset: 'BNB',
                            principal: '0.84624403',
                            timestamp: 1555056425000,
                            status: 'CONFIRMED',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryMarginLoanRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginLoanRecordResponse>)
            );
            const response = await client.queryMarginLoanRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: QueryMarginLoanRecordRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.queryMarginLoanRecord(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling queryMarginLoanRecord.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginLoanRecordRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginLoanRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginLoanRecord(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginMaxWithdraw()', () => {
        it('should execute queryMarginMaxWithdraw() successfully with required parameters only', async () => {
            const params: QueryMarginMaxWithdrawRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(JSONStringify({ amount: '60' }));

            const spy = jest.spyOn(client, 'queryMarginMaxWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginMaxWithdrawResponse>)
            );
            const response = await client.queryMarginMaxWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginMaxWithdraw() successfully with optional parameters', async () => {
            const params: QueryMarginMaxWithdrawRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ amount: '60' }));

            const spy = jest.spyOn(client, 'queryMarginMaxWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginMaxWithdrawResponse>)
            );
            const response = await client.queryMarginMaxWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: QueryMarginMaxWithdrawRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.queryMarginMaxWithdraw(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling queryMarginMaxWithdraw.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginMaxWithdrawRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginMaxWithdraw')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginMaxWithdraw(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginRepayRecord()', () => {
        it('should execute queryMarginRepayRecord() successfully with required parameters only', async () => {
            const params: QueryMarginRepayRecordRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '14.00000000',
                            asset: 'BNB',
                            interest: '0.01866667',
                            principal: '13.98133333',
                            status: 'CONFIRMED',
                            timestamp: 1563438204000,
                            txId: 2970933056,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryMarginRepayRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginRepayRecordResponse>)
            );
            const response = await client.queryMarginRepayRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginRepayRecord() successfully with optional parameters', async () => {
            const params: QueryMarginRepayRecordRequest = {
                asset: 'asset_example',
                txId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                archived: '',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '14.00000000',
                            asset: 'BNB',
                            interest: '0.01866667',
                            principal: '13.98133333',
                            status: 'CONFIRMED',
                            timestamp: 1563438204000,
                            txId: 2970933056,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryMarginRepayRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginRepayRecordResponse>)
            );
            const response = await client.queryMarginRepayRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: QueryMarginRepayRecordRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.queryMarginRepayRecord(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling queryMarginRepayRecord.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginRepayRecordRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginRepayRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginRepayRecord(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginNegativeBalanceInterestHistory()', () => {
        it('should execute queryPortfolioMarginNegativeBalanceInterestHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        interest: '24.4440',
                        interestAccuredTime: 1670227200000,
                        interestRate: '0.0001164',
                        principal: '210000',
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginNegativeBalanceInterestHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginNegativeBalanceInterestHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginNegativeBalanceInterestHistory() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginNegativeBalanceInterestHistoryRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        interest: '24.4440',
                        interestAccuredTime: 1670227200000,
                        interestRate: '0.0001164',
                        principal: '210000',
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginNegativeBalanceInterestHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>)
                );
            const response =
                await client.queryPortfolioMarginNegativeBalanceInterestHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginNegativeBalanceInterestHistory')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryPortfolioMarginNegativeBalanceInterestHistory()
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUmPositionInformation()', () => {
        it('should execute queryUmPositionInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '0.00000',
                        leverage: '10',
                        markPrice: '6679.50671178',
                        maxNotionalValue: '20000000',
                        positionAmt: '0.000',
                        notional: '0',
                        symbol: 'BTCUSDT',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '6170.20509059',
                        positionSide: 'BOTH',
                        updateTime: 1625474304765,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.001',
                        entryPrice: '22185.2',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '-1.06214947',
                        liquidationPrice: '6170.20509059',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        positionSide: 'LONG',
                        notional: '21.12305052',
                        updateTime: 1655217461579,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.000',
                        entryPrice: '0.0',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '6170.20509059',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        positionSide: 'SHORT',
                        notional: '0',
                        updateTime: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryUmPositionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmPositionInformationResponse>)
            );
            const response = await client.queryUmPositionInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUmPositionInformation() successfully with optional parameters', async () => {
            const params: QueryUmPositionInformationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '0.00000',
                        leverage: '10',
                        markPrice: '6679.50671178',
                        maxNotionalValue: '20000000',
                        positionAmt: '0.000',
                        notional: '0',
                        symbol: 'BTCUSDT',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '6170.20509059',
                        positionSide: 'BOTH',
                        updateTime: 1625474304765,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.001',
                        entryPrice: '22185.2',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '-1.06214947',
                        liquidationPrice: '6170.20509059',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        positionSide: 'LONG',
                        notional: '21.12305052',
                        updateTime: 1655217461579,
                    },
                    {
                        symbol: 'BTCUSDT',
                        positionAmt: '0.000',
                        entryPrice: '0.0',
                        markPrice: '21123.05052574',
                        unRealizedProfit: '0.00000000',
                        liquidationPrice: '6170.20509059',
                        leverage: '4',
                        maxNotionalValue: '100000000',
                        positionSide: 'SHORT',
                        notional: '0',
                        updateTime: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryUmPositionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmPositionInformationResponse>)
            );
            const response = await client.queryUmPositionInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUmPositionInformation')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUmPositionInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUserNegativeBalanceAutoExchangeRecord()', () => {
        it('should execute queryUserNegativeBalanceAutoExchangeRecord() successfully with required parameters only', async () => {
            const params: QueryUserNegativeBalanceAutoExchangeRecordRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    rows: [
                        {
                            startTime: 1736263046841,
                            endTime: 1736263248179,
                            details: [
                                { asset: 'ETH', negativeBalance: 18, negativeMaxThreshold: 5 },
                            ],
                        },
                        {
                            startTime: 1736184913252,
                            endTime: 1736184965474,
                            details: [
                                {
                                    asset: 'BNB',
                                    negativeBalance: 1.10264488,
                                    negativeMaxThreshold: 0,
                                },
                            ],
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryUserNegativeBalanceAutoExchangeRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>)
                );
            const response = await client.queryUserNegativeBalanceAutoExchangeRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserNegativeBalanceAutoExchangeRecord() successfully with optional parameters', async () => {
            const params: QueryUserNegativeBalanceAutoExchangeRecordRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    rows: [
                        {
                            startTime: 1736263046841,
                            endTime: 1736263248179,
                            details: [
                                { asset: 'ETH', negativeBalance: 18, negativeMaxThreshold: 5 },
                            ],
                        },
                        {
                            startTime: 1736184913252,
                            endTime: 1736184965474,
                            details: [
                                {
                                    asset: 'BNB',
                                    negativeBalance: 1.10264488,
                                    negativeMaxThreshold: 0,
                                },
                            ],
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryUserNegativeBalanceAutoExchangeRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>)
                );
            const response = await client.queryUserNegativeBalanceAutoExchangeRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryUserNegativeBalanceAutoExchangeRecordRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.queryUserNegativeBalanceAutoExchangeRecord(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryUserNegativeBalanceAutoExchangeRecord.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryUserNegativeBalanceAutoExchangeRecordRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.queryUserNegativeBalanceAutoExchangeRecord(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryUserNegativeBalanceAutoExchangeRecord.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUserNegativeBalanceAutoExchangeRecordRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserNegativeBalanceAutoExchangeRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserNegativeBalanceAutoExchangeRecord(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUserRateLimit()', () => {
        it('should execute queryUserRateLimit() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 1200 },
                ])
            );

            const spy = jest.spyOn(client, 'queryUserRateLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserRateLimitResponse>)
            );
            const response = await client.queryUserRateLimit();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserRateLimit() successfully with optional parameters', async () => {
            const params: QueryUserRateLimitRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 1200 },
                ])
            );

            const spy = jest.spyOn(client, 'queryUserRateLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserRateLimitResponse>)
            );
            const response = await client.queryUserRateLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryUserRateLimit').mockRejectedValueOnce(mockError);
            await expect(client.queryUserRateLimit()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('repayFuturesNegativeBalance()', () => {
        it('should execute repayFuturesNegativeBalance() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'repayFuturesNegativeBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RepayFuturesNegativeBalanceResponse>)
            );
            const response = await client.repayFuturesNegativeBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute repayFuturesNegativeBalance() successfully with optional parameters', async () => {
            const params: RepayFuturesNegativeBalanceRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'repayFuturesNegativeBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RepayFuturesNegativeBalanceResponse>)
            );
            const response = await client.repayFuturesNegativeBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'repayFuturesNegativeBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.repayFuturesNegativeBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('umFuturesAccountConfiguration()', () => {
        it('should execute umFuturesAccountConfiguration() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    feeTier: 0,
                    canTrade: true,
                    canDeposit: true,
                    canWithdraw: true,
                    dualSidePosition: true,
                    updateTime: 1724416653850,
                    multiAssetsMargin: false,
                    tradeGroupId: -1,
                })
            );

            const spy = jest.spyOn(client, 'umFuturesAccountConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmFuturesAccountConfigurationResponse>)
            );
            const response = await client.umFuturesAccountConfiguration();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute umFuturesAccountConfiguration() successfully with optional parameters', async () => {
            const params: UmFuturesAccountConfigurationRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    feeTier: 0,
                    canTrade: true,
                    canDeposit: true,
                    canWithdraw: true,
                    dualSidePosition: true,
                    updateTime: 1724416653850,
                    multiAssetsMargin: false,
                    tradeGroupId: -1,
                })
            );

            const spy = jest.spyOn(client, 'umFuturesAccountConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmFuturesAccountConfigurationResponse>)
            );
            const response = await client.umFuturesAccountConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'umFuturesAccountConfiguration')
                .mockRejectedValueOnce(mockError);
            await expect(client.umFuturesAccountConfiguration()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('umFuturesSymbolConfiguration()', () => {
        it('should execute umFuturesSymbolConfiguration() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        marginType: 'CROSSED',
                        isAutoAddMargin: 'false',
                        leverage: 21,
                        maxNotionalValue: '1000000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'umFuturesSymbolConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmFuturesSymbolConfigurationResponse>)
            );
            const response = await client.umFuturesSymbolConfiguration();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute umFuturesSymbolConfiguration() successfully with optional parameters', async () => {
            const params: UmFuturesSymbolConfigurationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTCUSDT',
                        marginType: 'CROSSED',
                        isAutoAddMargin: 'false',
                        leverage: 21,
                        maxNotionalValue: '1000000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'umFuturesSymbolConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmFuturesSymbolConfigurationResponse>)
            );
            const response = await client.umFuturesSymbolConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'umFuturesSymbolConfiguration')
                .mockRejectedValueOnce(mockError);
            await expect(client.umFuturesSymbolConfiguration()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('umNotionalAndLeverageBrackets()', () => {
        it('should execute umNotionalAndLeverageBrackets() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ETHUSDT',
                        notionalCoef: '4.0',
                        brackets: [
                            {
                                bracket: 1,
                                initialLeverage: 75,
                                notionalCap: 10000,
                                notionalFloor: 0,
                                maintMarginRatio: 0.0065,
                                cum: 0,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'umNotionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmNotionalAndLeverageBracketsResponse>)
            );
            const response = await client.umNotionalAndLeverageBrackets();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute umNotionalAndLeverageBrackets() successfully with optional parameters', async () => {
            const params: UmNotionalAndLeverageBracketsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ETHUSDT',
                        notionalCoef: '4.0',
                        brackets: [
                            {
                                bracket: 1,
                                initialLeverage: 75,
                                notionalCap: 10000,
                                notionalFloor: 0,
                                maintMarginRatio: 0.0065,
                                cum: 0,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'umNotionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmNotionalAndLeverageBracketsResponse>)
            );
            const response = await client.umNotionalAndLeverageBrackets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'umNotionalAndLeverageBrackets')
                .mockRejectedValueOnce(mockError);
            await expect(client.umNotionalAndLeverageBrackets()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
