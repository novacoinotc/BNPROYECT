/**
 * Binance Derivatives Trading Portfolio Margin REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AccountBalanceResponse,
    AccountInformationResponse,
    BnbTransferResponse,
    ChangeAutoRepayFuturesStatusResponse,
    ChangeCmInitialLeverageResponse,
    ChangeCmPositionModeResponse,
    ChangeUmInitialLeverageResponse,
    ChangeUmPositionModeResponse,
    CmNotionalAndLeverageBracketsResponse,
    FundAutoCollectionResponse,
    FundCollectionByAssetResponse,
    GetAutoRepayFuturesStatusResponse,
    GetCmAccountDetailResponse,
    GetCmCurrentPositionModeResponse,
    GetCmIncomeHistoryResponse,
    GetDownloadIdForUmFuturesOrderHistoryResponse,
    GetDownloadIdForUmFuturesTradeHistoryResponse,
    GetDownloadIdForUmFuturesTransactionHistoryResponse,
    GetMarginBorrowLoanInterestHistoryResponse,
    GetUmAccountDetailResponse,
    GetUmAccountDetailV2Response,
    GetUmCurrentPositionModeResponse,
    GetUmFuturesOrderDownloadLinkByIdResponse,
    GetUmFuturesTradeDownloadLinkByIdResponse,
    GetUmFuturesTransactionDownloadLinkByIdResponse,
    GetUmIncomeHistoryResponse,
    GetUserCommissionRateForCmResponse,
    GetUserCommissionRateForUmResponse,
    MarginMaxBorrowResponse,
    PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse,
    QueryCmPositionInformationResponse,
    QueryMarginLoanRecordResponse,
    QueryMarginMaxWithdrawResponse,
    QueryMarginRepayRecordResponse,
    QueryPortfolioMarginNegativeBalanceInterestHistoryResponse,
    QueryUmPositionInformationResponse,
    QueryUserNegativeBalanceAutoExchangeRecordResponse,
    QueryUserRateLimitResponse,
    RepayFuturesNegativeBalanceResponse,
    UmFuturesAccountConfigurationResponse,
    UmFuturesSymbolConfigurationResponse,
    UmNotionalAndLeverageBracketsResponse,
} from '../types';

/**
 * AccountApi - axios parameter creator
 */
const AccountApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Query account balance
         *
         * Weight: 20
         *
         * @summary Account Balance(USER_DATA)
         * @param {string} [asset]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        accountBalance: async (
            asset?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/balance',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query account information
         *
         * Weight: 20
         *
         * @summary Account Information(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        accountInformation: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/account',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Transfer BNB in and out of UM
         *
         * The endpoint can only be called 10 times per 10 minutes in a rolling manner
         *
         * Weight: 750
         *
         * @summary BNB transfer (TRADE)
         * @param {number} amount
         * @param {string} transferSide "TO_UM","FROM_UM"
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        bnbTransfer: async (
            amount: number,
            transferSide: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('bnbTransfer', 'amount', amount);
            // verify required parameter 'transferSide' is not null or undefined
            assertParamExists('bnbTransfer', 'transferSide', transferSide);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (amount !== undefined && amount !== null) {
                localVarQueryParameter['amount'] = amount;
            }
            if (transferSide !== undefined && transferSide !== null) {
                localVarQueryParameter['transferSide'] = transferSide;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/bnb-transfer',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change Auto-repay-futures Status
         *
         * Weight: 750
         *
         * @summary Change Auto-repay-futures Status(TRADE)
         * @param {string} autoRepay Default: `true`; `false` for turn off the auto-repay futures negative balance function
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeAutoRepayFuturesStatus: async (
            autoRepay: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'autoRepay' is not null or undefined
            assertParamExists('changeAutoRepayFuturesStatus', 'autoRepay', autoRepay);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (autoRepay !== undefined && autoRepay !== null) {
                localVarQueryParameter['autoRepay'] = autoRepay;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/repay-futures-switch',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's initial leverage of specific symbol in CM.
         *
         * Weight: 1
         *
         * @summary Change CM Initial Leverage (TRADE)
         * @param {string} symbol
         * @param {number | bigint} leverage target initial leverage: int from 1 to 125
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeCmInitialLeverage: async (
            symbol: string,
            leverage: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('changeCmInitialLeverage', 'symbol', symbol);
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('changeCmInitialLeverage', 'leverage', leverage);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (leverage !== undefined && leverage !== null) {
                localVarQueryParameter['leverage'] = leverage;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/leverage',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         *
         * Weight: 1
         *
         * @summary Change CM Position Mode(TRADE)
         * @param {string} dualSidePosition "true": Hedge Mode; "false": One-way Mode
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeCmPositionMode: async (
            dualSidePosition: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('changeCmPositionMode', 'dualSidePosition', dualSidePosition);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (dualSidePosition !== undefined && dualSidePosition !== null) {
                localVarQueryParameter['dualSidePosition'] = dualSidePosition;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/positionSide/dual',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's initial leverage of specific symbol in UM.
         *
         * Weight: 1
         *
         * @summary Change UM Initial Leverage(TRADE)
         * @param {string} symbol
         * @param {number | bigint} leverage target initial leverage: int from 1 to 125
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeUmInitialLeverage: async (
            symbol: string,
            leverage: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('changeUmInitialLeverage', 'symbol', symbol);
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('changeUmInitialLeverage', 'leverage', leverage);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (leverage !== undefined && leverage !== null) {
                localVarQueryParameter['leverage'] = leverage;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/leverage',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         *
         * Weight: 1
         *
         * @summary Change UM Position Mode(TRADE)
         * @param {string} dualSidePosition "true": Hedge Mode; "false": One-way Mode
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeUmPositionMode: async (
            dualSidePosition: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('changeUmPositionMode', 'dualSidePosition', dualSidePosition);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (dualSidePosition !== undefined && dualSidePosition !== null) {
                localVarQueryParameter['dualSidePosition'] = dualSidePosition;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/positionSide/dual',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query CM notional and leverage brackets
         *
         * Weight: 1
         *
         * @summary CM Notional and Leverage Brackets(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cmNotionalAndLeverageBrackets: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/leverageBracket',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Fund collection for Portfolio Margin
         *
         * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
         * You can only use this function 500 times per hour in a rolling manner.
         *
         * Weight: 750
         *
         * @summary Fund Auto-collection(TRADE)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        fundAutoCollection: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/auto-collection',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Transfers specific asset from Futures Account to Margin account
         *
         * The BNB transfer is not be supported
         *
         * Weight: 30
         *
         * @summary Fund Collection by Asset(TRADE)
         * @param {string} asset
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        fundCollectionByAsset: async (
            asset: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('fundCollectionByAsset', 'asset', asset);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/asset-collection',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Auto-repay-futures Status
         *
         * Weight: 30
         *
         * @summary Get Auto-repay-futures Status(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getAutoRepayFuturesStatus: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/repay-futures-switch',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current CM account asset and position information.
         *
         * Weight: 5
         *
         * @summary Get CM Account Detail(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getCmAccountDetail: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/account',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
         *
         * Weight: 30
         *
         * @summary Get CM Current Position Mode(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getCmCurrentPositionMode: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/positionSide/dual',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get CM Income History
         *
         *
         * If `incomeType` is not sent, all kinds of flow will be returned
         * "trandId" is unique in the same "incomeType" for a user
         * The interval between `startTime` and `endTime` can not exceed 200 days:
         * If `startTime` and `endTime` are not sent, the last 200 days will be returned
         *
         * Weight: 30
         *
         * @summary Get CM Income History(USER_DATA)
         * @param {string} [symbol]
         * @param {string} [incomeType] TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [page]
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getCmIncomeHistory: async (
            symbol?: string,
            incomeType?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            page?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (incomeType !== undefined && incomeType !== null) {
                localVarQueryParameter['incomeType'] = incomeType;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (page !== undefined && page !== null) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/income',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get download id for UM futures order history
         *
         * Request Limitation is 10 times per month, shared by front end download page and rest api
         * The time between `startTime` and `endTime` can not be longer than 1 year
         *
         * Weight: 1500
         *
         * @summary Get Download Id For UM Futures Order History (USER_DATA)
         * @param {number | bigint} startTime
         * @param {number | bigint} endTime
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getDownloadIdForUmFuturesOrderHistory: async (
            startTime: number | bigint,
            endTime: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getDownloadIdForUmFuturesOrderHistory', 'startTime', startTime);
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getDownloadIdForUmFuturesOrderHistory', 'endTime', endTime);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/order/asyn',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get download id for UM futures trade history
         *
         * Request Limitation is 5 times per month, shared by front end download page and rest api
         * The time between `startTime` and `endTime` can not be longer than 1 year
         *
         * Weight: 1500
         *
         * @summary Get Download Id For UM Futures Trade History (USER_DATA)
         * @param {number | bigint} startTime
         * @param {number | bigint} endTime
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getDownloadIdForUmFuturesTradeHistory: async (
            startTime: number | bigint,
            endTime: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('getDownloadIdForUmFuturesTradeHistory', 'startTime', startTime);
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getDownloadIdForUmFuturesTradeHistory', 'endTime', endTime);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/trade/asyn',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get download id for UM futures transaction history
         *
         * Request Limitation is 5 times per month, shared by front end download page and rest api
         * The time between `startTime` and `endTime` can not be longer than 1 year
         *
         * Weight: 1500
         *
         * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
         * @param {number | bigint} startTime
         * @param {number | bigint} endTime
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getDownloadIdForUmFuturesTransactionHistory: async (
            startTime: number | bigint,
            endTime: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists(
                'getDownloadIdForUmFuturesTransactionHistory',
                'startTime',
                startTime
            );
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('getDownloadIdForUmFuturesTransactionHistory', 'endTime', endTime);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/income/asyn',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Margin Borrow/Loan Interest History
         *
         *
         * Response in descending order
         * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
         * If `startTime` and `endTime` not sent, return records of the last 7 days by default
         * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
         * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
         * Type in response has 5 enums:
         * `PERIODIC` interest charged per hour
         * `ON_BORROW` first interest charged on borrow
         * `PERIODIC_CONVERTED` interest charged per hour converted into BNB
         * `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB
         * `PORTFOLIO` Portfolio Margin negative balance daily interest
         *
         * Weight: 1
         *
         * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
         * @param {string} [asset]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [current] Currently querying page. Start from 1. Default:1
         * @param {number | bigint} [size] Default:10 Max:100
         * @param {string} [archived] Default: `false`. Set to `true` for archived data from 6 months ago
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getMarginBorrowLoanInterestHistory: async (
            asset?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            current?: number | bigint,
            size?: number | bigint,
            archived?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (current !== undefined && current !== null) {
                localVarQueryParameter['current'] = current;
            }
            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }
            if (archived !== undefined && archived !== null) {
                localVarQueryParameter['archived'] = archived;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/marginInterestHistory',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current UM account asset and position information.
         *
         * Weight: 5
         *
         * @summary Get UM Account Detail(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmAccountDetail: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/account',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current UM account asset and position information.
         *
         * Weight: 5
         *
         * @summary Get UM Account Detail V2(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmAccountDetailV2: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v2/um/account',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
         *
         * Weight: 30
         *
         * @summary Get UM Current Position Mode(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmCurrentPositionMode: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/positionSide/dual',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get UM futures order download link by Id
         *
         * Download link expiration: 24h
         *
         * Weight: 10
         *
         * @summary Get UM Futures Order Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmFuturesOrderDownloadLinkById: async (
            downloadId: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getUmFuturesOrderDownloadLinkById', 'downloadId', downloadId);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (downloadId !== undefined && downloadId !== null) {
                localVarQueryParameter['downloadId'] = downloadId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/order/asyn/id',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get UM futures trade download link by Id
         *
         * Download link expiration: 24h
         *
         * Weight: 10
         *
         * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmFuturesTradeDownloadLinkById: async (
            downloadId: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getUmFuturesTradeDownloadLinkById', 'downloadId', downloadId);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (downloadId !== undefined && downloadId !== null) {
                localVarQueryParameter['downloadId'] = downloadId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/trade/asyn/id',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get UM futures Transaction download link by Id
         *
         * Download link expiration: 24h
         *
         * Weight: 10
         *
         * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
         * @param {string} downloadId get by download id api
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmFuturesTransactionDownloadLinkById: async (
            downloadId: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getUmFuturesTransactionDownloadLinkById', 'downloadId', downloadId);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (downloadId !== undefined && downloadId !== null) {
                localVarQueryParameter['downloadId'] = downloadId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/income/asyn/id',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get UM Income History
         *
         * If neither `startTime` nor `endTime` is sent, the recent 7-day data will be returned.
         * If `incomeType` is not sent, all kinds of flow will be returned
         * "trandId" is unique in the same incomeType for a user
         * Income history only contains data for the last three months
         *
         * Weight: 30
         *
         * @summary Get UM Income History(USER_DATA)
         * @param {string} [symbol]
         * @param {string} [incomeType] TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [page]
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmIncomeHistory: async (
            symbol?: string,
            incomeType?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            page?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (incomeType !== undefined && incomeType !== null) {
                localVarQueryParameter['incomeType'] = incomeType;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (page !== undefined && page !== null) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/income',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get User Commission Rate for CM
         *
         * Weight: 20
         *
         * @summary Get User Commission Rate for CM(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUserCommissionRateForCm: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUserCommissionRateForCm', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/commissionRate',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get User Commission Rate for UM
         *
         * Weight: 20
         *
         * @summary Get User Commission Rate for UM(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUserCommissionRateForUm: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getUserCommissionRateForUm', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/commissionRate',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query margin max borrow
         *
         * Weight: 5
         *
         * @summary Margin Max Borrow(USER_DATA)
         * @param {string} asset
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        marginMaxBorrow: async (
            asset: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('marginMaxBorrow', 'asset', asset);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/maxBorrowable',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Portfolio Margin UM Trading Quantitative Rules Indicators
         *
         * Weight: 1 for a single symbol
         * 10 when the symbol parameter is omitted
         *
         * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        portfolioMarginUmTradingQuantitativeRulesIndicators: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/apiTradingStatus',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current CM position information.
         *
         * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
         * for One-way Mode user, the response will only show the "BOTH" positions
         * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
         * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
         *
         * Weight: 1
         *
         * @summary Query CM Position Information(USER_DATA)
         * @param {string} [marginAsset]
         * @param {string} [pair]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCmPositionInformation: async (
            marginAsset?: string,
            pair?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (marginAsset !== undefined && marginAsset !== null) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }
            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/positionRisk',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query margin loan record
         *
         * txId or startTime must be sent. txId takes precedence.
         * Response in descending order
         * The max interval between `startTime` and `endTime` is 30 days.
         * If `startTime` and `endTime` not sent, return records of the last 7 days by default
         * Set `archived` to `true` to query data from 6 months ago
         *
         * Weight: 10
         *
         * @summary Query Margin Loan Record(USER_DATA)
         * @param {string} asset
         * @param {number | bigint} [txId] the `tranId` in `POST/papi/v1/marginLoan`
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [current] Currently querying page. Start from 1. Default:1
         * @param {number | bigint} [size] Default:10 Max:100
         * @param {string} [archived] Default: `false`. Set to `true` for archived data from 6 months ago
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginLoanRecord: async (
            asset: string,
            txId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            current?: number | bigint,
            size?: number | bigint,
            archived?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryMarginLoanRecord', 'asset', asset);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (txId !== undefined && txId !== null) {
                localVarQueryParameter['txId'] = txId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (current !== undefined && current !== null) {
                localVarQueryParameter['current'] = current;
            }
            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }
            if (archived !== undefined && archived !== null) {
                localVarQueryParameter['archived'] = archived;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/marginLoan',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Max Withdraw
         *
         * Weight: 5
         *
         * @summary Query Margin Max Withdraw(USER_DATA)
         * @param {string} asset
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginMaxWithdraw: async (
            asset: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryMarginMaxWithdraw', 'asset', asset);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/maxWithdraw',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query margin repay record.
         *
         * txId or startTime must be sent. txId takes precedence.
         * Response in descending order
         * The max interval between `startTime` and `endTime` is 30 days.
         * If `startTime` and `endTime` not sent, return records of the last 7 days by default
         * Set `archived` to `true` to query data from 6 months ago
         *
         * Weight: 10
         *
         * @summary Query Margin repay Record(USER_DATA)
         * @param {string} asset
         * @param {number | bigint} [txId] the `tranId` in `POST/papi/v1/marginLoan`
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [current] Currently querying page. Start from 1. Default:1
         * @param {number | bigint} [size] Default:10 Max:100
         * @param {string} [archived] Default: `false`. Set to `true` for archived data from 6 months ago
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginRepayRecord: async (
            asset: string,
            txId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            current?: number | bigint,
            size?: number | bigint,
            archived?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryMarginRepayRecord', 'asset', asset);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (txId !== undefined && txId !== null) {
                localVarQueryParameter['txId'] = txId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (current !== undefined && current !== null) {
                localVarQueryParameter['current'] = current;
            }
            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }
            if (archived !== undefined && archived !== null) {
                localVarQueryParameter['archived'] = archived;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/repayLoan',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query interest history of negative balance for portfolio margin.
         *
         * Response in descending order
         * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
         * If `startTime` and `endTime` not sent, return records of the last 7 days by default
         * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
         * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
         *
         * Weight: 50
         *
         * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
         * @param {string} [asset]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [size] Default:10 Max:100
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryPortfolioMarginNegativeBalanceInterestHistory: async (
            asset?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            size?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/portfolio/interest-history',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current UM position information.
         *
         * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
         * for One-way Mode user, the response will only show the "BOTH" positions
         * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
         *
         * Weight: 5
         *
         * @summary Query UM Position Information(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUmPositionInformation: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/positionRisk',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query user negative balance auto exchange record
         *
         * Response in descending order
         * The max interval between `startTime` and `endTime` is 3 months.
         *
         * Weight: 100
         *
         * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
         * @param {number | bigint} startTime
         * @param {number | bigint} endTime
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUserNegativeBalanceAutoExchangeRecord: async (
            startTime: number | bigint,
            endTime: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('queryUserNegativeBalanceAutoExchangeRecord', 'startTime', startTime);
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('queryUserNegativeBalanceAutoExchangeRecord', 'endTime', endTime);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/portfolio/negative-balance-exchange-record',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query User Rate Limit
         *
         * Weight: 1
         *
         * @summary Query User Rate Limit (USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUserRateLimit: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/rateLimit/order',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Repay futures Negative Balance
         *
         * Weight: 750
         *
         * @summary Repay futures Negative Balance(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        repayFuturesNegativeBalance: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/repay-futures-negative-balance',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query UM Futures account configuration
         *
         * Weight: 5
         *
         * @summary UM Futures Account Configuration(USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        umFuturesAccountConfiguration: async (
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/accountConfig',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current UM account symbol configuration.
         *
         * Weight: 5
         *
         * @summary UM Futures Symbol Configuration(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        umFuturesSymbolConfiguration: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/symbolConfig',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query UM notional and leverage brackets
         *
         * Weight: 1
         *
         * @summary UM Notional and Leverage Brackets (USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        umNotionalAndLeverageBrackets: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/leverageBracket',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * AccountApi - interface
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * Query account balance
     *
     * Weight: 20
     *
     * @summary Account Balance(USER_DATA)
     * @param {AccountBalanceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    accountBalance(
        requestParameters?: AccountBalanceRequest
    ): Promise<RestApiResponse<AccountBalanceResponse>>;
    /**
     * Query account information
     *
     * Weight: 20
     *
     * @summary Account Information(USER_DATA)
     * @param {AccountInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    accountInformation(
        requestParameters?: AccountInformationRequest
    ): Promise<RestApiResponse<AccountInformationResponse>>;
    /**
     * Transfer BNB in and out of UM
     *
     * The endpoint can only be called 10 times per 10 minutes in a rolling manner
     *
     * Weight: 750
     *
     * @summary BNB transfer (TRADE)
     * @param {BnbTransferRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    bnbTransfer(
        requestParameters: BnbTransferRequest
    ): Promise<RestApiResponse<BnbTransferResponse>>;
    /**
     * Change Auto-repay-futures Status
     *
     * Weight: 750
     *
     * @summary Change Auto-repay-futures Status(TRADE)
     * @param {ChangeAutoRepayFuturesStatusRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    changeAutoRepayFuturesStatus(
        requestParameters: ChangeAutoRepayFuturesStatusRequest
    ): Promise<RestApiResponse<ChangeAutoRepayFuturesStatusResponse>>;
    /**
     * Change user's initial leverage of specific symbol in CM.
     *
     * Weight: 1
     *
     * @summary Change CM Initial Leverage (TRADE)
     * @param {ChangeCmInitialLeverageRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    changeCmInitialLeverage(
        requestParameters: ChangeCmInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeCmInitialLeverageResponse>>;
    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     *
     * Weight: 1
     *
     * @summary Change CM Position Mode(TRADE)
     * @param {ChangeCmPositionModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    changeCmPositionMode(
        requestParameters: ChangeCmPositionModeRequest
    ): Promise<RestApiResponse<ChangeCmPositionModeResponse>>;
    /**
     * Change user's initial leverage of specific symbol in UM.
     *
     * Weight: 1
     *
     * @summary Change UM Initial Leverage(TRADE)
     * @param {ChangeUmInitialLeverageRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    changeUmInitialLeverage(
        requestParameters: ChangeUmInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeUmInitialLeverageResponse>>;
    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     *
     * Weight: 1
     *
     * @summary Change UM Position Mode(TRADE)
     * @param {ChangeUmPositionModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    changeUmPositionMode(
        requestParameters: ChangeUmPositionModeRequest
    ): Promise<RestApiResponse<ChangeUmPositionModeResponse>>;
    /**
     * Query CM notional and leverage brackets
     *
     * Weight: 1
     *
     * @summary CM Notional and Leverage Brackets(USER_DATA)
     * @param {CmNotionalAndLeverageBracketsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    cmNotionalAndLeverageBrackets(
        requestParameters?: CmNotionalAndLeverageBracketsRequest
    ): Promise<RestApiResponse<CmNotionalAndLeverageBracketsResponse>>;
    /**
     * Fund collection for Portfolio Margin
     *
     * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
     * You can only use this function 500 times per hour in a rolling manner.
     *
     * Weight: 750
     *
     * @summary Fund Auto-collection(TRADE)
     * @param {FundAutoCollectionRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    fundAutoCollection(
        requestParameters?: FundAutoCollectionRequest
    ): Promise<RestApiResponse<FundAutoCollectionResponse>>;
    /**
     * Transfers specific asset from Futures Account to Margin account
     *
     * The BNB transfer is not be supported
     *
     * Weight: 30
     *
     * @summary Fund Collection by Asset(TRADE)
     * @param {FundCollectionByAssetRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    fundCollectionByAsset(
        requestParameters: FundCollectionByAssetRequest
    ): Promise<RestApiResponse<FundCollectionByAssetResponse>>;
    /**
     * Query Auto-repay-futures Status
     *
     * Weight: 30
     *
     * @summary Get Auto-repay-futures Status(USER_DATA)
     * @param {GetAutoRepayFuturesStatusRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getAutoRepayFuturesStatus(
        requestParameters?: GetAutoRepayFuturesStatusRequest
    ): Promise<RestApiResponse<GetAutoRepayFuturesStatusResponse>>;
    /**
     * Get current CM account asset and position information.
     *
     * Weight: 5
     *
     * @summary Get CM Account Detail(USER_DATA)
     * @param {GetCmAccountDetailRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getCmAccountDetail(
        requestParameters?: GetCmAccountDetailRequest
    ): Promise<RestApiResponse<GetCmAccountDetailResponse>>;
    /**
     * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     *
     * Weight: 30
     *
     * @summary Get CM Current Position Mode(USER_DATA)
     * @param {GetCmCurrentPositionModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getCmCurrentPositionMode(
        requestParameters?: GetCmCurrentPositionModeRequest
    ): Promise<RestApiResponse<GetCmCurrentPositionModeResponse>>;
    /**
     * Get CM Income History
     *
     *
     * If `incomeType` is not sent, all kinds of flow will be returned
     * "trandId" is unique in the same "incomeType" for a user
     * The interval between `startTime` and `endTime` can not exceed 200 days:
     * If `startTime` and `endTime` are not sent, the last 200 days will be returned
     *
     * Weight: 30
     *
     * @summary Get CM Income History(USER_DATA)
     * @param {GetCmIncomeHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getCmIncomeHistory(
        requestParameters?: GetCmIncomeHistoryRequest
    ): Promise<RestApiResponse<GetCmIncomeHistoryResponse>>;
    /**
     * Get download id for UM futures order history
     *
     * Request Limitation is 10 times per month, shared by front end download page and rest api
     * The time between `startTime` and `endTime` can not be longer than 1 year
     *
     * Weight: 1500
     *
     * @summary Get Download Id For UM Futures Order History (USER_DATA)
     * @param {GetDownloadIdForUmFuturesOrderHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getDownloadIdForUmFuturesOrderHistory(
        requestParameters: GetDownloadIdForUmFuturesOrderHistoryRequest
    ): Promise<RestApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>>;
    /**
     * Get download id for UM futures trade history
     *
     * Request Limitation is 5 times per month, shared by front end download page and rest api
     * The time between `startTime` and `endTime` can not be longer than 1 year
     *
     * Weight: 1500
     *
     * @summary Get Download Id For UM Futures Trade History (USER_DATA)
     * @param {GetDownloadIdForUmFuturesTradeHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getDownloadIdForUmFuturesTradeHistory(
        requestParameters: GetDownloadIdForUmFuturesTradeHistoryRequest
    ): Promise<RestApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>>;
    /**
     * Get download id for UM futures transaction history
     *
     * Request Limitation is 5 times per month, shared by front end download page and rest api
     * The time between `startTime` and `endTime` can not be longer than 1 year
     *
     * Weight: 1500
     *
     * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
     * @param {GetDownloadIdForUmFuturesTransactionHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getDownloadIdForUmFuturesTransactionHistory(
        requestParameters: GetDownloadIdForUmFuturesTransactionHistoryRequest
    ): Promise<RestApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>>;
    /**
     * Get Margin Borrow/Loan Interest History
     *
     *
     * Response in descending order
     * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
     * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
     * Type in response has 5 enums:
     * `PERIODIC` interest charged per hour
     * `ON_BORROW` first interest charged on borrow
     * `PERIODIC_CONVERTED` interest charged per hour converted into BNB
     * `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB
     * `PORTFOLIO` Portfolio Margin negative balance daily interest
     *
     * Weight: 1
     *
     * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
     * @param {GetMarginBorrowLoanInterestHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getMarginBorrowLoanInterestHistory(
        requestParameters?: GetMarginBorrowLoanInterestHistoryRequest
    ): Promise<RestApiResponse<GetMarginBorrowLoanInterestHistoryResponse>>;
    /**
     * Get current UM account asset and position information.
     *
     * Weight: 5
     *
     * @summary Get UM Account Detail(USER_DATA)
     * @param {GetUmAccountDetailRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmAccountDetail(
        requestParameters?: GetUmAccountDetailRequest
    ): Promise<RestApiResponse<GetUmAccountDetailResponse>>;
    /**
     * Get current UM account asset and position information.
     *
     * Weight: 5
     *
     * @summary Get UM Account Detail V2(USER_DATA)
     * @param {GetUmAccountDetailV2Request} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmAccountDetailV2(
        requestParameters?: GetUmAccountDetailV2Request
    ): Promise<RestApiResponse<GetUmAccountDetailV2Response>>;
    /**
     * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     *
     * Weight: 30
     *
     * @summary Get UM Current Position Mode(USER_DATA)
     * @param {GetUmCurrentPositionModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmCurrentPositionMode(
        requestParameters?: GetUmCurrentPositionModeRequest
    ): Promise<RestApiResponse<GetUmCurrentPositionModeResponse>>;
    /**
     * Get UM futures order download link by Id
     *
     * Download link expiration: 24h
     *
     * Weight: 10
     *
     * @summary Get UM Futures Order Download Link by Id(USER_DATA)
     * @param {GetUmFuturesOrderDownloadLinkByIdRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmFuturesOrderDownloadLinkById(
        requestParameters: GetUmFuturesOrderDownloadLinkByIdRequest
    ): Promise<RestApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>>;
    /**
     * Get UM futures trade download link by Id
     *
     * Download link expiration: 24h
     *
     * Weight: 10
     *
     * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
     * @param {GetUmFuturesTradeDownloadLinkByIdRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmFuturesTradeDownloadLinkById(
        requestParameters: GetUmFuturesTradeDownloadLinkByIdRequest
    ): Promise<RestApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>>;
    /**
     * Get UM futures Transaction download link by Id
     *
     * Download link expiration: 24h
     *
     * Weight: 10
     *
     * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
     * @param {GetUmFuturesTransactionDownloadLinkByIdRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmFuturesTransactionDownloadLinkById(
        requestParameters: GetUmFuturesTransactionDownloadLinkByIdRequest
    ): Promise<RestApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>>;
    /**
     * Get UM Income History
     *
     * If neither `startTime` nor `endTime` is sent, the recent 7-day data will be returned.
     * If `incomeType` is not sent, all kinds of flow will be returned
     * "trandId" is unique in the same incomeType for a user
     * Income history only contains data for the last three months
     *
     * Weight: 30
     *
     * @summary Get UM Income History(USER_DATA)
     * @param {GetUmIncomeHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUmIncomeHistory(
        requestParameters?: GetUmIncomeHistoryRequest
    ): Promise<RestApiResponse<GetUmIncomeHistoryResponse>>;
    /**
     * Get User Commission Rate for CM
     *
     * Weight: 20
     *
     * @summary Get User Commission Rate for CM(USER_DATA)
     * @param {GetUserCommissionRateForCmRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUserCommissionRateForCm(
        requestParameters: GetUserCommissionRateForCmRequest
    ): Promise<RestApiResponse<GetUserCommissionRateForCmResponse>>;
    /**
     * Get User Commission Rate for UM
     *
     * Weight: 20
     *
     * @summary Get User Commission Rate for UM(USER_DATA)
     * @param {GetUserCommissionRateForUmRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    getUserCommissionRateForUm(
        requestParameters: GetUserCommissionRateForUmRequest
    ): Promise<RestApiResponse<GetUserCommissionRateForUmResponse>>;
    /**
     * Query margin max borrow
     *
     * Weight: 5
     *
     * @summary Margin Max Borrow(USER_DATA)
     * @param {MarginMaxBorrowRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    marginMaxBorrow(
        requestParameters: MarginMaxBorrowRequest
    ): Promise<RestApiResponse<MarginMaxBorrowResponse>>;
    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators
     *
     * Weight: 1 for a single symbol
     * 10 when the symbol parameter is omitted
     *
     * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     * @param {PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    portfolioMarginUmTradingQuantitativeRulesIndicators(
        requestParameters?: PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest
    ): Promise<RestApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>>;
    /**
     * Get current CM position information.
     *
     * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
     * for One-way Mode user, the response will only show the "BOTH" positions
     * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 1
     *
     * @summary Query CM Position Information(USER_DATA)
     * @param {QueryCmPositionInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryCmPositionInformation(
        requestParameters?: QueryCmPositionInformationRequest
    ): Promise<RestApiResponse<QueryCmPositionInformationResponse>>;
    /**
     * Query margin loan record
     *
     * txId or startTime must be sent. txId takes precedence.
     * Response in descending order
     * The max interval between `startTime` and `endTime` is 30 days.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * Set `archived` to `true` to query data from 6 months ago
     *
     * Weight: 10
     *
     * @summary Query Margin Loan Record(USER_DATA)
     * @param {QueryMarginLoanRecordRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryMarginLoanRecord(
        requestParameters: QueryMarginLoanRecordRequest
    ): Promise<RestApiResponse<QueryMarginLoanRecordResponse>>;
    /**
     * Query Margin Max Withdraw
     *
     * Weight: 5
     *
     * @summary Query Margin Max Withdraw(USER_DATA)
     * @param {QueryMarginMaxWithdrawRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryMarginMaxWithdraw(
        requestParameters: QueryMarginMaxWithdrawRequest
    ): Promise<RestApiResponse<QueryMarginMaxWithdrawResponse>>;
    /**
     * Query margin repay record.
     *
     * txId or startTime must be sent. txId takes precedence.
     * Response in descending order
     * The max interval between `startTime` and `endTime` is 30 days.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * Set `archived` to `true` to query data from 6 months ago
     *
     * Weight: 10
     *
     * @summary Query Margin repay Record(USER_DATA)
     * @param {QueryMarginRepayRecordRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryMarginRepayRecord(
        requestParameters: QueryMarginRepayRecordRequest
    ): Promise<RestApiResponse<QueryMarginRepayRecordResponse>>;
    /**
     * Query interest history of negative balance for portfolio margin.
     *
     * Response in descending order
     * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
     * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
     *
     * Weight: 50
     *
     * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     * @param {QueryPortfolioMarginNegativeBalanceInterestHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryPortfolioMarginNegativeBalanceInterestHistory(
        requestParameters?: QueryPortfolioMarginNegativeBalanceInterestHistoryRequest
    ): Promise<RestApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>>;
    /**
     * Get current UM position information.
     *
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     * for One-way Mode user, the response will only show the "BOTH" positions
     * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
     *
     * Weight: 5
     *
     * @summary Query UM Position Information(USER_DATA)
     * @param {QueryUmPositionInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryUmPositionInformation(
        requestParameters?: QueryUmPositionInformationRequest
    ): Promise<RestApiResponse<QueryUmPositionInformationResponse>>;
    /**
     * Query user negative balance auto exchange record
     *
     * Response in descending order
     * The max interval between `startTime` and `endTime` is 3 months.
     *
     * Weight: 100
     *
     * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
     * @param {QueryUserNegativeBalanceAutoExchangeRecordRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryUserNegativeBalanceAutoExchangeRecord(
        requestParameters: QueryUserNegativeBalanceAutoExchangeRecordRequest
    ): Promise<RestApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>>;
    /**
     * Query User Rate Limit
     *
     * Weight: 1
     *
     * @summary Query User Rate Limit (USER_DATA)
     * @param {QueryUserRateLimitRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    queryUserRateLimit(
        requestParameters?: QueryUserRateLimitRequest
    ): Promise<RestApiResponse<QueryUserRateLimitResponse>>;
    /**
     * Repay futures Negative Balance
     *
     * Weight: 750
     *
     * @summary Repay futures Negative Balance(USER_DATA)
     * @param {RepayFuturesNegativeBalanceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    repayFuturesNegativeBalance(
        requestParameters?: RepayFuturesNegativeBalanceRequest
    ): Promise<RestApiResponse<RepayFuturesNegativeBalanceResponse>>;
    /**
     * Query UM Futures account configuration
     *
     * Weight: 5
     *
     * @summary UM Futures Account Configuration(USER_DATA)
     * @param {UmFuturesAccountConfigurationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    umFuturesAccountConfiguration(
        requestParameters?: UmFuturesAccountConfigurationRequest
    ): Promise<RestApiResponse<UmFuturesAccountConfigurationResponse>>;
    /**
     * Get current UM account symbol configuration.
     *
     * Weight: 5
     *
     * @summary UM Futures Symbol Configuration(USER_DATA)
     * @param {UmFuturesSymbolConfigurationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    umFuturesSymbolConfiguration(
        requestParameters?: UmFuturesSymbolConfigurationRequest
    ): Promise<RestApiResponse<UmFuturesSymbolConfigurationResponse>>;
    /**
     * Query UM notional and leverage brackets
     *
     * Weight: 1
     *
     * @summary UM Notional and Leverage Brackets (USER_DATA)
     * @param {UmNotionalAndLeverageBracketsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApiInterface
     */
    umNotionalAndLeverageBrackets(
        requestParameters?: UmNotionalAndLeverageBracketsRequest
    ): Promise<RestApiResponse<UmNotionalAndLeverageBracketsResponse>>;
}

/**
 * Request parameters for accountBalance operation in AccountApi.
 * @interface AccountBalanceRequest
 */
export interface AccountBalanceRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiAccountBalance
     */
    readonly asset?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiAccountBalance
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for accountInformation operation in AccountApi.
 * @interface AccountInformationRequest
 */
export interface AccountInformationRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiAccountInformation
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for bnbTransfer operation in AccountApi.
 * @interface BnbTransferRequest
 */
export interface BnbTransferRequest {
    /**
     *
     * @type {number}
     * @memberof AccountApiBnbTransfer
     */
    readonly amount: number;

    /**
     * "TO_UM","FROM_UM"
     * @type {string}
     * @memberof AccountApiBnbTransfer
     */
    readonly transferSide: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiBnbTransfer
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for changeAutoRepayFuturesStatus operation in AccountApi.
 * @interface ChangeAutoRepayFuturesStatusRequest
 */
export interface ChangeAutoRepayFuturesStatusRequest {
    /**
     * Default: `true`; `false` for turn off the auto-repay futures negative balance function
     * @type {string}
     * @memberof AccountApiChangeAutoRepayFuturesStatus
     */
    readonly autoRepay: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiChangeAutoRepayFuturesStatus
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for changeCmInitialLeverage operation in AccountApi.
 * @interface ChangeCmInitialLeverageRequest
 */
export interface ChangeCmInitialLeverageRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiChangeCmInitialLeverage
     */
    readonly symbol: string;

    /**
     * target initial leverage: int from 1 to 125
     * @type {number | bigint}
     * @memberof AccountApiChangeCmInitialLeverage
     */
    readonly leverage: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiChangeCmInitialLeverage
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for changeCmPositionMode operation in AccountApi.
 * @interface ChangeCmPositionModeRequest
 */
export interface ChangeCmPositionModeRequest {
    /**
     * "true": Hedge Mode; "false": One-way Mode
     * @type {string}
     * @memberof AccountApiChangeCmPositionMode
     */
    readonly dualSidePosition: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiChangeCmPositionMode
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for changeUmInitialLeverage operation in AccountApi.
 * @interface ChangeUmInitialLeverageRequest
 */
export interface ChangeUmInitialLeverageRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiChangeUmInitialLeverage
     */
    readonly symbol: string;

    /**
     * target initial leverage: int from 1 to 125
     * @type {number | bigint}
     * @memberof AccountApiChangeUmInitialLeverage
     */
    readonly leverage: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiChangeUmInitialLeverage
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for changeUmPositionMode operation in AccountApi.
 * @interface ChangeUmPositionModeRequest
 */
export interface ChangeUmPositionModeRequest {
    /**
     * "true": Hedge Mode; "false": One-way Mode
     * @type {string}
     * @memberof AccountApiChangeUmPositionMode
     */
    readonly dualSidePosition: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiChangeUmPositionMode
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cmNotionalAndLeverageBrackets operation in AccountApi.
 * @interface CmNotionalAndLeverageBracketsRequest
 */
export interface CmNotionalAndLeverageBracketsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiCmNotionalAndLeverageBrackets
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiCmNotionalAndLeverageBrackets
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for fundAutoCollection operation in AccountApi.
 * @interface FundAutoCollectionRequest
 */
export interface FundAutoCollectionRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiFundAutoCollection
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for fundCollectionByAsset operation in AccountApi.
 * @interface FundCollectionByAssetRequest
 */
export interface FundCollectionByAssetRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiFundCollectionByAsset
     */
    readonly asset: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiFundCollectionByAsset
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getAutoRepayFuturesStatus operation in AccountApi.
 * @interface GetAutoRepayFuturesStatusRequest
 */
export interface GetAutoRepayFuturesStatusRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetAutoRepayFuturesStatus
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getCmAccountDetail operation in AccountApi.
 * @interface GetCmAccountDetailRequest
 */
export interface GetCmAccountDetailRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetCmAccountDetail
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getCmCurrentPositionMode operation in AccountApi.
 * @interface GetCmCurrentPositionModeRequest
 */
export interface GetCmCurrentPositionModeRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetCmCurrentPositionMode
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getCmIncomeHistory operation in AccountApi.
 * @interface GetCmIncomeHistoryRequest
 */
export interface GetCmIncomeHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly symbol?: string;

    /**
     * TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
     * @type {string}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly incomeType?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly endTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly page?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetCmIncomeHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getDownloadIdForUmFuturesOrderHistory operation in AccountApi.
 * @interface GetDownloadIdForUmFuturesOrderHistoryRequest
 */
export interface GetDownloadIdForUmFuturesOrderHistoryRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesOrderHistory
     */
    readonly startTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesOrderHistory
     */
    readonly endTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesOrderHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getDownloadIdForUmFuturesTradeHistory operation in AccountApi.
 * @interface GetDownloadIdForUmFuturesTradeHistoryRequest
 */
export interface GetDownloadIdForUmFuturesTradeHistoryRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesTradeHistory
     */
    readonly startTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesTradeHistory
     */
    readonly endTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesTradeHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getDownloadIdForUmFuturesTransactionHistory operation in AccountApi.
 * @interface GetDownloadIdForUmFuturesTransactionHistoryRequest
 */
export interface GetDownloadIdForUmFuturesTransactionHistoryRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesTransactionHistory
     */
    readonly startTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesTransactionHistory
     */
    readonly endTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetDownloadIdForUmFuturesTransactionHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getMarginBorrowLoanInterestHistory operation in AccountApi.
 * @interface GetMarginBorrowLoanInterestHistoryRequest
 */
export interface GetMarginBorrowLoanInterestHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly asset?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly endTime?: number | bigint;

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number | bigint}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly current?: number | bigint;

    /**
     * Default:10 Max:100
     * @type {number | bigint}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly size?: number | bigint;

    /**
     * Default: `false`. Set to `true` for archived data from 6 months ago
     * @type {string}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly archived?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetMarginBorrowLoanInterestHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmAccountDetail operation in AccountApi.
 * @interface GetUmAccountDetailRequest
 */
export interface GetUmAccountDetailRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmAccountDetail
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmAccountDetailV2 operation in AccountApi.
 * @interface GetUmAccountDetailV2Request
 */
export interface GetUmAccountDetailV2Request {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmAccountDetailV2
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmCurrentPositionMode operation in AccountApi.
 * @interface GetUmCurrentPositionModeRequest
 */
export interface GetUmCurrentPositionModeRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmCurrentPositionMode
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmFuturesOrderDownloadLinkById operation in AccountApi.
 * @interface GetUmFuturesOrderDownloadLinkByIdRequest
 */
export interface GetUmFuturesOrderDownloadLinkByIdRequest {
    /**
     * get by download id api
     * @type {string}
     * @memberof AccountApiGetUmFuturesOrderDownloadLinkById
     */
    readonly downloadId: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmFuturesOrderDownloadLinkById
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmFuturesTradeDownloadLinkById operation in AccountApi.
 * @interface GetUmFuturesTradeDownloadLinkByIdRequest
 */
export interface GetUmFuturesTradeDownloadLinkByIdRequest {
    /**
     * get by download id api
     * @type {string}
     * @memberof AccountApiGetUmFuturesTradeDownloadLinkById
     */
    readonly downloadId: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmFuturesTradeDownloadLinkById
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmFuturesTransactionDownloadLinkById operation in AccountApi.
 * @interface GetUmFuturesTransactionDownloadLinkByIdRequest
 */
export interface GetUmFuturesTransactionDownloadLinkByIdRequest {
    /**
     * get by download id api
     * @type {string}
     * @memberof AccountApiGetUmFuturesTransactionDownloadLinkById
     */
    readonly downloadId: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmFuturesTransactionDownloadLinkById
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmIncomeHistory operation in AccountApi.
 * @interface GetUmIncomeHistoryRequest
 */
export interface GetUmIncomeHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly symbol?: string;

    /**
     * TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
     * @type {string}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly incomeType?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly endTime?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly page?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUmIncomeHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUserCommissionRateForCm operation in AccountApi.
 * @interface GetUserCommissionRateForCmRequest
 */
export interface GetUserCommissionRateForCmRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiGetUserCommissionRateForCm
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUserCommissionRateForCm
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUserCommissionRateForUm operation in AccountApi.
 * @interface GetUserCommissionRateForUmRequest
 */
export interface GetUserCommissionRateForUmRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiGetUserCommissionRateForUm
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiGetUserCommissionRateForUm
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for marginMaxBorrow operation in AccountApi.
 * @interface MarginMaxBorrowRequest
 */
export interface MarginMaxBorrowRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiMarginMaxBorrow
     */
    readonly asset: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiMarginMaxBorrow
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for portfolioMarginUmTradingQuantitativeRulesIndicators operation in AccountApi.
 * @interface PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest
 */
export interface PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiPortfolioMarginUmTradingQuantitativeRulesIndicators
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiPortfolioMarginUmTradingQuantitativeRulesIndicators
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCmPositionInformation operation in AccountApi.
 * @interface QueryCmPositionInformationRequest
 */
export interface QueryCmPositionInformationRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiQueryCmPositionInformation
     */
    readonly marginAsset?: string;

    /**
     *
     * @type {string}
     * @memberof AccountApiQueryCmPositionInformation
     */
    readonly pair?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryCmPositionInformation
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginLoanRecord operation in AccountApi.
 * @interface QueryMarginLoanRecordRequest
 */
export interface QueryMarginLoanRecordRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly asset: string;

    /**
     * the `tranId` in `POST/papi/v1/marginLoan`
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly txId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly endTime?: number | bigint;

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly current?: number | bigint;

    /**
     * Default:10 Max:100
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly size?: number | bigint;

    /**
     * Default: `false`. Set to `true` for archived data from 6 months ago
     * @type {string}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly archived?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginLoanRecord
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginMaxWithdraw operation in AccountApi.
 * @interface QueryMarginMaxWithdrawRequest
 */
export interface QueryMarginMaxWithdrawRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiQueryMarginMaxWithdraw
     */
    readonly asset: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginMaxWithdraw
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginRepayRecord operation in AccountApi.
 * @interface QueryMarginRepayRecordRequest
 */
export interface QueryMarginRepayRecordRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly asset: string;

    /**
     * the `tranId` in `POST/papi/v1/marginLoan`
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly txId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly endTime?: number | bigint;

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly current?: number | bigint;

    /**
     * Default:10 Max:100
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly size?: number | bigint;

    /**
     * Default: `false`. Set to `true` for archived data from 6 months ago
     * @type {string}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly archived?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryMarginRepayRecord
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryPortfolioMarginNegativeBalanceInterestHistory operation in AccountApi.
 * @interface QueryPortfolioMarginNegativeBalanceInterestHistoryRequest
 */
export interface QueryPortfolioMarginNegativeBalanceInterestHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiQueryPortfolioMarginNegativeBalanceInterestHistory
     */
    readonly asset?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiQueryPortfolioMarginNegativeBalanceInterestHistory
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof AccountApiQueryPortfolioMarginNegativeBalanceInterestHistory
     */
    readonly endTime?: number | bigint;

    /**
     * Default:10 Max:100
     * @type {number | bigint}
     * @memberof AccountApiQueryPortfolioMarginNegativeBalanceInterestHistory
     */
    readonly size?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryPortfolioMarginNegativeBalanceInterestHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUmPositionInformation operation in AccountApi.
 * @interface QueryUmPositionInformationRequest
 */
export interface QueryUmPositionInformationRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiQueryUmPositionInformation
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryUmPositionInformation
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUserNegativeBalanceAutoExchangeRecord operation in AccountApi.
 * @interface QueryUserNegativeBalanceAutoExchangeRecordRequest
 */
export interface QueryUserNegativeBalanceAutoExchangeRecordRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryUserNegativeBalanceAutoExchangeRecord
     */
    readonly startTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryUserNegativeBalanceAutoExchangeRecord
     */
    readonly endTime: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryUserNegativeBalanceAutoExchangeRecord
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUserRateLimit operation in AccountApi.
 * @interface QueryUserRateLimitRequest
 */
export interface QueryUserRateLimitRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiQueryUserRateLimit
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for repayFuturesNegativeBalance operation in AccountApi.
 * @interface RepayFuturesNegativeBalanceRequest
 */
export interface RepayFuturesNegativeBalanceRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiRepayFuturesNegativeBalance
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for umFuturesAccountConfiguration operation in AccountApi.
 * @interface UmFuturesAccountConfigurationRequest
 */
export interface UmFuturesAccountConfigurationRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiUmFuturesAccountConfiguration
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for umFuturesSymbolConfiguration operation in AccountApi.
 * @interface UmFuturesSymbolConfigurationRequest
 */
export interface UmFuturesSymbolConfigurationRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiUmFuturesSymbolConfiguration
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiUmFuturesSymbolConfiguration
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for umNotionalAndLeverageBrackets operation in AccountApi.
 * @interface UmNotionalAndLeverageBracketsRequest
 */
export interface UmNotionalAndLeverageBracketsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountApiUmNotionalAndLeverageBrackets
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof AccountApiUmNotionalAndLeverageBrackets
     */
    readonly recvWindow?: number | bigint;
}

/**
 * AccountApi - object-oriented interface
 * @class AccountApi
 */
export class AccountApi implements AccountApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
    }

    /**
     * Query account balance
     *
     * Weight: 20
     *
     * @summary Account Balance(USER_DATA)
     * @param {AccountBalanceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AccountBalanceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Account-Balance Binance API Documentation}
     */
    public async accountBalance(
        requestParameters: AccountBalanceRequest = {}
    ): Promise<RestApiResponse<AccountBalanceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountBalance(
            requestParameters?.asset,
            requestParameters?.recvWindow
        );
        return sendRequest<AccountBalanceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query account information
     *
     * Weight: 20
     *
     * @summary Account Information(USER_DATA)
     * @param {AccountInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AccountInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Account-Information Binance API Documentation}
     */
    public async accountInformation(
        requestParameters: AccountInformationRequest = {}
    ): Promise<RestApiResponse<AccountInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountInformation(
            requestParameters?.recvWindow
        );
        return sendRequest<AccountInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Transfer BNB in and out of UM
     *
     * The endpoint can only be called 10 times per 10 minutes in a rolling manner
     *
     * Weight: 750
     *
     * @summary BNB transfer (TRADE)
     * @param {BnbTransferRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<BnbTransferResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/BNB-transfer Binance API Documentation}
     */
    public async bnbTransfer(
        requestParameters: BnbTransferRequest
    ): Promise<RestApiResponse<BnbTransferResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.bnbTransfer(
            requestParameters?.amount,
            requestParameters?.transferSide,
            requestParameters?.recvWindow
        );
        return sendRequest<BnbTransferResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change Auto-repay-futures Status
     *
     * Weight: 750
     *
     * @summary Change Auto-repay-futures Status(TRADE)
     * @param {ChangeAutoRepayFuturesStatusRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeAutoRepayFuturesStatusResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-Auto-repay-futures-Status Binance API Documentation}
     */
    public async changeAutoRepayFuturesStatus(
        requestParameters: ChangeAutoRepayFuturesStatusRequest
    ): Promise<RestApiResponse<ChangeAutoRepayFuturesStatusResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeAutoRepayFuturesStatus(
            requestParameters?.autoRepay,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeAutoRepayFuturesStatusResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's initial leverage of specific symbol in CM.
     *
     * Weight: 1
     *
     * @summary Change CM Initial Leverage (TRADE)
     * @param {ChangeCmInitialLeverageRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeCmInitialLeverageResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-CM-Initial-Leverage Binance API Documentation}
     */
    public async changeCmInitialLeverage(
        requestParameters: ChangeCmInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeCmInitialLeverageResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeCmInitialLeverage(
            requestParameters?.symbol,
            requestParameters?.leverage,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeCmInitialLeverageResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     *
     * Weight: 1
     *
     * @summary Change CM Position Mode(TRADE)
     * @param {ChangeCmPositionModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeCmPositionModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-CM-Position-Mode Binance API Documentation}
     */
    public async changeCmPositionMode(
        requestParameters: ChangeCmPositionModeRequest
    ): Promise<RestApiResponse<ChangeCmPositionModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeCmPositionMode(
            requestParameters?.dualSidePosition,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeCmPositionModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's initial leverage of specific symbol in UM.
     *
     * Weight: 1
     *
     * @summary Change UM Initial Leverage(TRADE)
     * @param {ChangeUmInitialLeverageRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeUmInitialLeverageResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-UM-Initial-Leverage Binance API Documentation}
     */
    public async changeUmInitialLeverage(
        requestParameters: ChangeUmInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeUmInitialLeverageResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeUmInitialLeverage(
            requestParameters?.symbol,
            requestParameters?.leverage,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeUmInitialLeverageResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     *
     * Weight: 1
     *
     * @summary Change UM Position Mode(TRADE)
     * @param {ChangeUmPositionModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeUmPositionModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-UM-Position-Mode Binance API Documentation}
     */
    public async changeUmPositionMode(
        requestParameters: ChangeUmPositionModeRequest
    ): Promise<RestApiResponse<ChangeUmPositionModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeUmPositionMode(
            requestParameters?.dualSidePosition,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeUmPositionModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query CM notional and leverage brackets
     *
     * Weight: 1
     *
     * @summary CM Notional and Leverage Brackets(USER_DATA)
     * @param {CmNotionalAndLeverageBracketsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CmNotionalAndLeverageBracketsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/CM-Notional-and-Leverage-Brackets Binance API Documentation}
     */
    public async cmNotionalAndLeverageBrackets(
        requestParameters: CmNotionalAndLeverageBracketsRequest = {}
    ): Promise<RestApiResponse<CmNotionalAndLeverageBracketsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cmNotionalAndLeverageBrackets(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<CmNotionalAndLeverageBracketsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Fund collection for Portfolio Margin
     *
     * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
     * You can only use this function 500 times per hour in a rolling manner.
     *
     * Weight: 750
     *
     * @summary Fund Auto-collection(TRADE)
     * @param {FundAutoCollectionRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<FundAutoCollectionResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Fund-Auto-collection Binance API Documentation}
     */
    public async fundAutoCollection(
        requestParameters: FundAutoCollectionRequest = {}
    ): Promise<RestApiResponse<FundAutoCollectionResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.fundAutoCollection(
            requestParameters?.recvWindow
        );
        return sendRequest<FundAutoCollectionResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Transfers specific asset from Futures Account to Margin account
     *
     * The BNB transfer is not be supported
     *
     * Weight: 30
     *
     * @summary Fund Collection by Asset(TRADE)
     * @param {FundCollectionByAssetRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<FundCollectionByAssetResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Fund-Collection-by-Asset Binance API Documentation}
     */
    public async fundCollectionByAsset(
        requestParameters: FundCollectionByAssetRequest
    ): Promise<RestApiResponse<FundCollectionByAssetResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.fundCollectionByAsset(
            requestParameters?.asset,
            requestParameters?.recvWindow
        );
        return sendRequest<FundCollectionByAssetResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Auto-repay-futures Status
     *
     * Weight: 30
     *
     * @summary Get Auto-repay-futures Status(USER_DATA)
     * @param {GetAutoRepayFuturesStatusRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetAutoRepayFuturesStatusResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Auto-repay-futures-Status Binance API Documentation}
     */
    public async getAutoRepayFuturesStatus(
        requestParameters: GetAutoRepayFuturesStatusRequest = {}
    ): Promise<RestApiResponse<GetAutoRepayFuturesStatusResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getAutoRepayFuturesStatus(
            requestParameters?.recvWindow
        );
        return sendRequest<GetAutoRepayFuturesStatusResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current CM account asset and position information.
     *
     * Weight: 5
     *
     * @summary Get CM Account Detail(USER_DATA)
     * @param {GetCmAccountDetailRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetCmAccountDetailResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Account-Detail Binance API Documentation}
     */
    public async getCmAccountDetail(
        requestParameters: GetCmAccountDetailRequest = {}
    ): Promise<RestApiResponse<GetCmAccountDetailResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getCmAccountDetail(
            requestParameters?.recvWindow
        );
        return sendRequest<GetCmAccountDetailResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     *
     * Weight: 30
     *
     * @summary Get CM Current Position Mode(USER_DATA)
     * @param {GetCmCurrentPositionModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetCmCurrentPositionModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Current-Position-Mode Binance API Documentation}
     */
    public async getCmCurrentPositionMode(
        requestParameters: GetCmCurrentPositionModeRequest = {}
    ): Promise<RestApiResponse<GetCmCurrentPositionModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getCmCurrentPositionMode(
            requestParameters?.recvWindow
        );
        return sendRequest<GetCmCurrentPositionModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get CM Income History
     *
     *
     * If `incomeType` is not sent, all kinds of flow will be returned
     * "trandId" is unique in the same "incomeType" for a user
     * The interval between `startTime` and `endTime` can not exceed 200 days:
     * If `startTime` and `endTime` are not sent, the last 200 days will be returned
     *
     * Weight: 30
     *
     * @summary Get CM Income History(USER_DATA)
     * @param {GetCmIncomeHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetCmIncomeHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Income-History Binance API Documentation}
     */
    public async getCmIncomeHistory(
        requestParameters: GetCmIncomeHistoryRequest = {}
    ): Promise<RestApiResponse<GetCmIncomeHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getCmIncomeHistory(
            requestParameters?.symbol,
            requestParameters?.incomeType,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.page,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<GetCmIncomeHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get download id for UM futures order history
     *
     * Request Limitation is 10 times per month, shared by front end download page and rest api
     * The time between `startTime` and `endTime` can not be longer than 1 year
     *
     * Weight: 1500
     *
     * @summary Get Download Id For UM Futures Order History (USER_DATA)
     * @param {GetDownloadIdForUmFuturesOrderHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Download-Id-For-UM-Futures-Order-History Binance API Documentation}
     */
    public async getDownloadIdForUmFuturesOrderHistory(
        requestParameters: GetDownloadIdForUmFuturesOrderHistoryRequest
    ): Promise<RestApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getDownloadIdForUmFuturesOrderHistory(
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.recvWindow
            );
        return sendRequest<GetDownloadIdForUmFuturesOrderHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get download id for UM futures trade history
     *
     * Request Limitation is 5 times per month, shared by front end download page and rest api
     * The time between `startTime` and `endTime` can not be longer than 1 year
     *
     * Weight: 1500
     *
     * @summary Get Download Id For UM Futures Trade History (USER_DATA)
     * @param {GetDownloadIdForUmFuturesTradeHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Download-Id-For-UM-Futures-Trade-History Binance API Documentation}
     */
    public async getDownloadIdForUmFuturesTradeHistory(
        requestParameters: GetDownloadIdForUmFuturesTradeHistoryRequest
    ): Promise<RestApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getDownloadIdForUmFuturesTradeHistory(
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.recvWindow
            );
        return sendRequest<GetDownloadIdForUmFuturesTradeHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get download id for UM futures transaction history
     *
     * Request Limitation is 5 times per month, shared by front end download page and rest api
     * The time between `startTime` and `endTime` can not be longer than 1 year
     *
     * Weight: 1500
     *
     * @summary Get Download Id For UM Futures Transaction History (USER_DATA)
     * @param {GetDownloadIdForUmFuturesTransactionHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Download-Id-For-UM-Futures-Transaction-History Binance API Documentation}
     */
    public async getDownloadIdForUmFuturesTransactionHistory(
        requestParameters: GetDownloadIdForUmFuturesTransactionHistoryRequest
    ): Promise<RestApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getDownloadIdForUmFuturesTransactionHistory(
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.recvWindow
            );
        return sendRequest<GetDownloadIdForUmFuturesTransactionHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get Margin Borrow/Loan Interest History
     *
     *
     * Response in descending order
     * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
     * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
     * Type in response has 5 enums:
     * `PERIODIC` interest charged per hour
     * `ON_BORROW` first interest charged on borrow
     * `PERIODIC_CONVERTED` interest charged per hour converted into BNB
     * `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB
     * `PORTFOLIO` Portfolio Margin negative balance daily interest
     *
     * Weight: 1
     *
     * @summary Get Margin Borrow/Loan Interest History(USER_DATA)
     * @param {GetMarginBorrowLoanInterestHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetMarginBorrowLoanInterestHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Margin-BorrowLoan-Interest-History Binance API Documentation}
     */
    public async getMarginBorrowLoanInterestHistory(
        requestParameters: GetMarginBorrowLoanInterestHistoryRequest = {}
    ): Promise<RestApiResponse<GetMarginBorrowLoanInterestHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getMarginBorrowLoanInterestHistory(
                requestParameters?.asset,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.current,
                requestParameters?.size,
                requestParameters?.archived,
                requestParameters?.recvWindow
            );
        return sendRequest<GetMarginBorrowLoanInterestHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current UM account asset and position information.
     *
     * Weight: 5
     *
     * @summary Get UM Account Detail(USER_DATA)
     * @param {GetUmAccountDetailRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmAccountDetailResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Account-Detail Binance API Documentation}
     */
    public async getUmAccountDetail(
        requestParameters: GetUmAccountDetailRequest = {}
    ): Promise<RestApiResponse<GetUmAccountDetailResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUmAccountDetail(
            requestParameters?.recvWindow
        );
        return sendRequest<GetUmAccountDetailResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current UM account asset and position information.
     *
     * Weight: 5
     *
     * @summary Get UM Account Detail V2(USER_DATA)
     * @param {GetUmAccountDetailV2Request} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmAccountDetailV2Response>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Account-Detail-V2 Binance API Documentation}
     */
    public async getUmAccountDetailV2(
        requestParameters: GetUmAccountDetailV2Request = {}
    ): Promise<RestApiResponse<GetUmAccountDetailV2Response>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUmAccountDetailV2(
            requestParameters?.recvWindow
        );
        return sendRequest<GetUmAccountDetailV2Response>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     *
     * Weight: 30
     *
     * @summary Get UM Current Position Mode(USER_DATA)
     * @param {GetUmCurrentPositionModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmCurrentPositionModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Current-Position-Mode Binance API Documentation}
     */
    public async getUmCurrentPositionMode(
        requestParameters: GetUmCurrentPositionModeRequest = {}
    ): Promise<RestApiResponse<GetUmCurrentPositionModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUmCurrentPositionMode(
            requestParameters?.recvWindow
        );
        return sendRequest<GetUmCurrentPositionModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get UM futures order download link by Id
     *
     * Download link expiration: 24h
     *
     * Weight: 10
     *
     * @summary Get UM Futures Order Download Link by Id(USER_DATA)
     * @param {GetUmFuturesOrderDownloadLinkByIdRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Futures-Order-Download-Link-by-Id Binance API Documentation}
     */
    public async getUmFuturesOrderDownloadLinkById(
        requestParameters: GetUmFuturesOrderDownloadLinkByIdRequest
    ): Promise<RestApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getUmFuturesOrderDownloadLinkById(
                requestParameters?.downloadId,
                requestParameters?.recvWindow
            );
        return sendRequest<GetUmFuturesOrderDownloadLinkByIdResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get UM futures trade download link by Id
     *
     * Download link expiration: 24h
     *
     * Weight: 10
     *
     * @summary Get UM Futures Trade Download Link by Id(USER_DATA)
     * @param {GetUmFuturesTradeDownloadLinkByIdRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Futures-Trade-Download-Link-by-Id Binance API Documentation}
     */
    public async getUmFuturesTradeDownloadLinkById(
        requestParameters: GetUmFuturesTradeDownloadLinkByIdRequest
    ): Promise<RestApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getUmFuturesTradeDownloadLinkById(
                requestParameters?.downloadId,
                requestParameters?.recvWindow
            );
        return sendRequest<GetUmFuturesTradeDownloadLinkByIdResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get UM futures Transaction download link by Id
     *
     * Download link expiration: 24h
     *
     * Weight: 10
     *
     * @summary Get UM Futures Transaction Download Link by Id(USER_DATA)
     * @param {GetUmFuturesTransactionDownloadLinkByIdRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Futures-Transaction-Download-Link-by-Id Binance API Documentation}
     */
    public async getUmFuturesTransactionDownloadLinkById(
        requestParameters: GetUmFuturesTransactionDownloadLinkByIdRequest
    ): Promise<RestApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getUmFuturesTransactionDownloadLinkById(
                requestParameters?.downloadId,
                requestParameters?.recvWindow
            );
        return sendRequest<GetUmFuturesTransactionDownloadLinkByIdResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get UM Income History
     *
     * If neither `startTime` nor `endTime` is sent, the recent 7-day data will be returned.
     * If `incomeType` is not sent, all kinds of flow will be returned
     * "trandId" is unique in the same incomeType for a user
     * Income history only contains data for the last three months
     *
     * Weight: 30
     *
     * @summary Get UM Income History(USER_DATA)
     * @param {GetUmIncomeHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmIncomeHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Income-History Binance API Documentation}
     */
    public async getUmIncomeHistory(
        requestParameters: GetUmIncomeHistoryRequest = {}
    ): Promise<RestApiResponse<GetUmIncomeHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUmIncomeHistory(
            requestParameters?.symbol,
            requestParameters?.incomeType,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.page,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<GetUmIncomeHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get User Commission Rate for CM
     *
     * Weight: 20
     *
     * @summary Get User Commission Rate for CM(USER_DATA)
     * @param {GetUserCommissionRateForCmRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUserCommissionRateForCmResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-User-Commission-Rate-for-CM Binance API Documentation}
     */
    public async getUserCommissionRateForCm(
        requestParameters: GetUserCommissionRateForCmRequest
    ): Promise<RestApiResponse<GetUserCommissionRateForCmResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUserCommissionRateForCm(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<GetUserCommissionRateForCmResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get User Commission Rate for UM
     *
     * Weight: 20
     *
     * @summary Get User Commission Rate for UM(USER_DATA)
     * @param {GetUserCommissionRateForUmRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUserCommissionRateForUmResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-User-Commission-Rate-for-UM Binance API Documentation}
     */
    public async getUserCommissionRateForUm(
        requestParameters: GetUserCommissionRateForUmRequest
    ): Promise<RestApiResponse<GetUserCommissionRateForUmResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUserCommissionRateForUm(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<GetUserCommissionRateForUmResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query margin max borrow
     *
     * Weight: 5
     *
     * @summary Margin Max Borrow(USER_DATA)
     * @param {MarginMaxBorrowRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginMaxBorrowResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Margin-Max-Borrow Binance API Documentation}
     */
    public async marginMaxBorrow(
        requestParameters: MarginMaxBorrowRequest
    ): Promise<RestApiResponse<MarginMaxBorrowResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginMaxBorrow(
            requestParameters?.asset,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginMaxBorrowResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators
     *
     * Weight: 1 for a single symbol
     * 10 when the symbol parameter is omitted
     *
     * @summary Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     * @param {PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Portfolio-Margin-UM-Trading-Quantitative-Rules-Indicators Binance API Documentation}
     */
    public async portfolioMarginUmTradingQuantitativeRulesIndicators(
        requestParameters: PortfolioMarginUmTradingQuantitativeRulesIndicatorsRequest = {}
    ): Promise<RestApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.portfolioMarginUmTradingQuantitativeRulesIndicators(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current CM position information.
     *
     * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
     * for One-way Mode user, the response will only show the "BOTH" positions
     * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 1
     *
     * @summary Query CM Position Information(USER_DATA)
     * @param {QueryCmPositionInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCmPositionInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-CM-Position-Information Binance API Documentation}
     */
    public async queryCmPositionInformation(
        requestParameters: QueryCmPositionInformationRequest = {}
    ): Promise<RestApiResponse<QueryCmPositionInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCmPositionInformation(
            requestParameters?.marginAsset,
            requestParameters?.pair,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCmPositionInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query margin loan record
     *
     * txId or startTime must be sent. txId takes precedence.
     * Response in descending order
     * The max interval between `startTime` and `endTime` is 30 days.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * Set `archived` to `true` to query data from 6 months ago
     *
     * Weight: 10
     *
     * @summary Query Margin Loan Record(USER_DATA)
     * @param {QueryMarginLoanRecordRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginLoanRecordResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-Margin-Loan-Record Binance API Documentation}
     */
    public async queryMarginLoanRecord(
        requestParameters: QueryMarginLoanRecordRequest
    ): Promise<RestApiResponse<QueryMarginLoanRecordResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginLoanRecord(
            requestParameters?.asset,
            requestParameters?.txId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.current,
            requestParameters?.size,
            requestParameters?.archived,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginLoanRecordResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Max Withdraw
     *
     * Weight: 5
     *
     * @summary Query Margin Max Withdraw(USER_DATA)
     * @param {QueryMarginMaxWithdrawRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginMaxWithdrawResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-Margin-Max-Withdraw Binance API Documentation}
     */
    public async queryMarginMaxWithdraw(
        requestParameters: QueryMarginMaxWithdrawRequest
    ): Promise<RestApiResponse<QueryMarginMaxWithdrawResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginMaxWithdraw(
            requestParameters?.asset,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginMaxWithdrawResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query margin repay record.
     *
     * txId or startTime must be sent. txId takes precedence.
     * Response in descending order
     * The max interval between `startTime` and `endTime` is 30 days.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * Set `archived` to `true` to query data from 6 months ago
     *
     * Weight: 10
     *
     * @summary Query Margin repay Record(USER_DATA)
     * @param {QueryMarginRepayRecordRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginRepayRecordResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-Margin-repay-Record Binance API Documentation}
     */
    public async queryMarginRepayRecord(
        requestParameters: QueryMarginRepayRecordRequest
    ): Promise<RestApiResponse<QueryMarginRepayRecordResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginRepayRecord(
            requestParameters?.asset,
            requestParameters?.txId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.current,
            requestParameters?.size,
            requestParameters?.archived,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginRepayRecordResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query interest history of negative balance for portfolio margin.
     *
     * Response in descending order
     * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
     * If `startTime` and `endTime` not sent, return records of the last 7 days by default
     * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
     * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
     *
     * Weight: 50
     *
     * @summary Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     * @param {QueryPortfolioMarginNegativeBalanceInterestHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-Portfolio-Margin-Negative-Balance-Interest-History Binance API Documentation}
     */
    public async queryPortfolioMarginNegativeBalanceInterestHistory(
        requestParameters: QueryPortfolioMarginNegativeBalanceInterestHistoryRequest = {}
    ): Promise<RestApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryPortfolioMarginNegativeBalanceInterestHistory(
                requestParameters?.asset,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.size,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current UM position information.
     *
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     * for One-way Mode user, the response will only show the "BOTH" positions
     * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
     *
     * Weight: 5
     *
     * @summary Query UM Position Information(USER_DATA)
     * @param {QueryUmPositionInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUmPositionInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-UM-Position-Information Binance API Documentation}
     */
    public async queryUmPositionInformation(
        requestParameters: QueryUmPositionInformationRequest = {}
    ): Promise<RestApiResponse<QueryUmPositionInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUmPositionInformation(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUmPositionInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query user negative balance auto exchange record
     *
     * Response in descending order
     * The max interval between `startTime` and `endTime` is 3 months.
     *
     * Weight: 100
     *
     * @summary Query User Negative Balance Auto Exchange Record (USER_DATA)
     * @param {QueryUserNegativeBalanceAutoExchangeRecordRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-User-Negative-Balance-Auto-Exchange-Record Binance API Documentation}
     */
    public async queryUserNegativeBalanceAutoExchangeRecord(
        requestParameters: QueryUserNegativeBalanceAutoExchangeRecordRequest
    ): Promise<RestApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryUserNegativeBalanceAutoExchangeRecord(
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryUserNegativeBalanceAutoExchangeRecordResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query User Rate Limit
     *
     * Weight: 1
     *
     * @summary Query User Rate Limit (USER_DATA)
     * @param {QueryUserRateLimitRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUserRateLimitResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-User-Rate-Limit Binance API Documentation}
     */
    public async queryUserRateLimit(
        requestParameters: QueryUserRateLimitRequest = {}
    ): Promise<RestApiResponse<QueryUserRateLimitResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUserRateLimit(
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUserRateLimitResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Repay futures Negative Balance
     *
     * Weight: 750
     *
     * @summary Repay futures Negative Balance(USER_DATA)
     * @param {RepayFuturesNegativeBalanceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<RepayFuturesNegativeBalanceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Repay-futures-Negative-Balance Binance API Documentation}
     */
    public async repayFuturesNegativeBalance(
        requestParameters: RepayFuturesNegativeBalanceRequest = {}
    ): Promise<RestApiResponse<RepayFuturesNegativeBalanceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.repayFuturesNegativeBalance(
            requestParameters?.recvWindow
        );
        return sendRequest<RepayFuturesNegativeBalanceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query UM Futures account configuration
     *
     * Weight: 5
     *
     * @summary UM Futures Account Configuration(USER_DATA)
     * @param {UmFuturesAccountConfigurationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UmFuturesAccountConfigurationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Futures-Account-Config Binance API Documentation}
     */
    public async umFuturesAccountConfiguration(
        requestParameters: UmFuturesAccountConfigurationRequest = {}
    ): Promise<RestApiResponse<UmFuturesAccountConfigurationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.umFuturesAccountConfiguration(
                requestParameters?.recvWindow
            );
        return sendRequest<UmFuturesAccountConfigurationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current UM account symbol configuration.
     *
     * Weight: 5
     *
     * @summary UM Futures Symbol Configuration(USER_DATA)
     * @param {UmFuturesSymbolConfigurationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UmFuturesSymbolConfigurationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Futures-Symbol-Config Binance API Documentation}
     */
    public async umFuturesSymbolConfiguration(
        requestParameters: UmFuturesSymbolConfigurationRequest = {}
    ): Promise<RestApiResponse<UmFuturesSymbolConfigurationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.umFuturesSymbolConfiguration(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<UmFuturesSymbolConfigurationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query UM notional and leverage brackets
     *
     * Weight: 1
     *
     * @summary UM Notional and Leverage Brackets (USER_DATA)
     * @param {UmNotionalAndLeverageBracketsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UmNotionalAndLeverageBracketsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof AccountApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/account/UM-Notional-and-Leverage-Brackets Binance API Documentation}
     */
    public async umNotionalAndLeverageBrackets(
        requestParameters: UmNotionalAndLeverageBracketsRequest = {}
    ): Promise<RestApiResponse<UmNotionalAndLeverageBracketsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.umNotionalAndLeverageBrackets(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<UmNotionalAndLeverageBracketsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}
