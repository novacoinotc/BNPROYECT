/**
 * Binance Derivatives Trading Portfolio Margin REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    CancelAllCmOpenConditionalOrdersResponse,
    CancelAllCmOpenOrdersResponse,
    CancelAllUmOpenConditionalOrdersResponse,
    CancelAllUmOpenOrdersResponse,
    CancelCmConditionalOrderResponse,
    CancelCmOrderResponse,
    CancelMarginAccountAllOpenOrdersOnASymbolResponse,
    CancelMarginAccountOcoOrdersResponse,
    CancelMarginAccountOrderResponse,
    CancelUmConditionalOrderResponse,
    CancelUmOrderResponse,
    CmAccountTradeListResponse,
    CmPositionAdlQuantileEstimationResponse,
    GetUmFuturesBnbBurnStatusResponse,
    MarginAccountBorrowResponse,
    MarginAccountNewOcoResponse,
    MarginAccountRepayDebtResponse,
    MarginAccountRepayResponse,
    MarginAccountTradeListResponse,
    ModifyCmOrderResponse,
    ModifyUmOrderResponse,
    NewCmConditionalOrderResponse,
    NewCmOrderResponse,
    NewMarginOrderResponse,
    NewUmConditionalOrderResponse,
    NewUmOrderResponse,
    QueryAllCmConditionalOrdersResponse,
    QueryAllCmOrdersResponse,
    QueryAllCurrentCmOpenConditionalOrdersResponse,
    QueryAllCurrentCmOpenOrdersResponse,
    QueryAllCurrentUmOpenConditionalOrdersResponse,
    QueryAllCurrentUmOpenOrdersResponse,
    QueryAllMarginAccountOrdersResponse,
    QueryAllUmConditionalOrdersResponse,
    QueryAllUmOrdersResponse,
    QueryCmConditionalOrderHistoryResponse,
    QueryCmModifyOrderHistoryResponse,
    QueryCmOrderResponse,
    QueryCurrentCmOpenConditionalOrderResponse,
    QueryCurrentCmOpenOrderResponse,
    QueryCurrentMarginOpenOrderResponse,
    QueryCurrentUmOpenConditionalOrderResponse,
    QueryCurrentUmOpenOrderResponse,
    QueryMarginAccountOrderResponse,
    QueryMarginAccountsAllOcoResponse,
    QueryMarginAccountsOcoResponse,
    QueryMarginAccountsOpenOcoResponse,
    QueryUmConditionalOrderHistoryResponse,
    QueryUmModifyOrderHistoryResponse,
    QueryUmOrderResponse,
    QueryUsersCmForceOrdersResponse,
    QueryUsersMarginForceOrdersResponse,
    QueryUsersUmForceOrdersResponse,
    ToggleBnbBurnOnUmFuturesTradeResponse,
    UmAccountTradeListResponse,
    UmPositionAdlQuantileEstimationResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Cancel All CM Open Conditional Orders
         *
         * Weight: 1
         *
         * @summary Cancel All CM Open Conditional Orders(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllCmOpenConditionalOrders: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllCmOpenConditionalOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/allOpenOrders',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         *
         * Weight: 1
         *
         * @summary Cancel All CM Open Orders(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllCmOpenOrders: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllCmOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/allOpenOrders',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel All UM Open Conditional Orders
         *
         * Weight: 1
         *
         * @summary Cancel All UM Open Conditional Orders (TRADE)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllUmOpenConditionalOrders: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllUmOpenConditionalOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/allOpenOrders',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel all active LIMIT orders on specific symbol
         *
         * Weight: 1
         *
         * @summary Cancel All UM Open Orders(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllUmOpenOrders: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllUmOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/allOpenOrders',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel CM Conditional Order
         *
         * Either `strategyId` or `newClientStrategyId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel CM Conditional Order(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [strategyId]
         * @param {string} [newClientStrategyId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelCmConditionalOrder: async (
            symbol: string,
            strategyId?: number | bigint,
            newClientStrategyId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelCmConditionalOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/order',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active LIMIT order
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel CM Order(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelCmOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelCmOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/order',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel Margin Account All Open Orders on a Symbol
         *
         * Weight: 5
         *
         * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelMarginAccountAllOpenOrdersOnASymbol: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelMarginAccountAllOpenOrdersOnASymbol', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/allOpenOrders',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel Margin Account OCO Orders
         *
         * Additional notes: Canceling an individual leg will cancel the entire OCO
         *
         * Weight: 2
         *
         * @summary Cancel Margin Account OCO Orders(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [orderListId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [listClientOrderId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelMarginAccountOcoOrders: async (
            symbol: string,
            orderListId?: number | bigint,
            listClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelMarginAccountOcoOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }
            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }
            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/orderList',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel Margin Account Order
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         *
         * Weight: 2
         *
         * @summary Cancel Margin Account Order(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelMarginAccountOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelMarginAccountOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/order',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel UM Conditional Order
         *
         * Either `strategyId` or `newClientStrategyId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel UM Conditional Order(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [strategyId]
         * @param {string} [newClientStrategyId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelUmConditionalOrder: async (
            symbol: string,
            strategyId?: number | bigint,
            newClientStrategyId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelUmConditionalOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/order',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active UM LIMIT order
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel UM Order(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelUmOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelUmOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/order',
                method: 'DELETE',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get trades for a specific account and CM symbol.
         *
         * Either `symbol` or `pair` must be sent
         * `symbol` and `pair` cannot be sent together
         * `pair` and `fromId` cannot be sent together
         * `OrderId` can only be sent together with symbol
         * If a `pair` is sent, tickers for all symbols of the `pair` will be returned
         * The parameter `fromId` cannot be sent with `startTime` or `endTime`
         * If `startTime` and `endTime` are both not sent, then the last '24 hours' data will be returned.
         * The time between `startTime` and `endTime` cannot be longer than 24 hours.
         *
         * Weight: 20 with symbol, 40 with pair
         *
         * @summary CM Account Trade List(USER_DATA)
         * @param {string} [symbol]
         * @param {string} [pair]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cmAccountTradeList: async (
            symbol?: string,
            pair?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            fromId?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/userTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query CM Position ADL Quantile Estimation
         * Values update every 30s.
         * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
         * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
         * If the positions of the symbol are crossed margined in Hedge Mode:
         * "HEDGE" as a sign will be returned instead of "BOTH";
         * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
         *
         * Weight: 5
         *
         * @summary CM Position ADL Quantile Estimation(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cmPositionAdlQuantileEstimation: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/adlQuantile',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
         *
         * Weight: 30
         *
         * @summary Get UM Futures BNB Burn Status (USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getUmFuturesBnbBurnStatus: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/feeBurn',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Apply for a margin loan.
         *
         * Weight: 100
         *
         * @summary Margin Account Borrow(MARGIN)
         * @param {string} asset
         * @param {number} amount
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        marginAccountBorrow: async (
            asset: string,
            amount: number,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('marginAccountBorrow', 'asset', asset);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('marginAccountBorrow', 'amount', amount);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (amount !== undefined && amount !== null) {
                localVarQueryParameter['amount'] = amount;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/marginLoan',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new OCO for a margin account
         *
         * Price Restrictions:
         * `SELL`: Limit Price > Last Price > Stop Price
         * `BUY`: Limit Price < Last Price < Stop Price
         * Quantity Restrictions:
         * Both legs must have the same quantity
         * `ICEBERG` quantities however do not have to be the same.
         * Order Rate Limit
         * `OCO` counts as 2 orders against the order rate limit.
         *
         * Weight: 1
         *
         * @summary Margin Account New OCO(TRADE)
         * @param {string} symbol
         * @param {MarginAccountNewOcoSideEnum} side
         * @param {number} quantity Order quantity
         * @param {number} price
         * @param {number} stopPrice
         * @param {string} [listClientOrderId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [limitClientOrderId] A unique Id for the limit order
         * @param {number} [limitIcebergQty]
         * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
         * @param {number} [stopLimitPrice] If provided, stopLimitTimeInForce is required.
         * @param {number} [stopIcebergQty]
         * @param {MarginAccountNewOcoStopLimitTimeInForceEnum} [stopLimitTimeInForce] Valid values are `GTC/FOK/IOC`
         * @param {MarginAccountNewOcoNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {MarginAccountNewOcoSideEffectTypeEnum} [sideEffectType] NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY; default NO_SIDE_EFFECT.
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        marginAccountNewOco: async (
            symbol: string,
            side: MarginAccountNewOcoSideEnum,
            quantity: number,
            price: number,
            stopPrice: number,
            listClientOrderId?: string,
            limitClientOrderId?: string,
            limitIcebergQty?: number,
            stopClientOrderId?: string,
            stopLimitPrice?: number,
            stopIcebergQty?: number,
            stopLimitTimeInForce?: MarginAccountNewOcoStopLimitTimeInForceEnum,
            newOrderRespType?: MarginAccountNewOcoNewOrderRespTypeEnum,
            sideEffectType?: MarginAccountNewOcoSideEffectTypeEnum,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountNewOco', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('marginAccountNewOco', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('marginAccountNewOco', 'quantity', quantity);
            // verify required parameter 'price' is not null or undefined
            assertParamExists('marginAccountNewOco', 'price', price);
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('marginAccountNewOco', 'stopPrice', stopPrice);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (limitClientOrderId !== undefined && limitClientOrderId !== null) {
                localVarQueryParameter['limitClientOrderId'] = limitClientOrderId;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (limitIcebergQty !== undefined && limitIcebergQty !== null) {
                localVarQueryParameter['limitIcebergQty'] = limitIcebergQty;
            }
            if (stopClientOrderId !== undefined && stopClientOrderId !== null) {
                localVarQueryParameter['stopClientOrderId'] = stopClientOrderId;
            }
            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }
            if (stopLimitPrice !== undefined && stopLimitPrice !== null) {
                localVarQueryParameter['stopLimitPrice'] = stopLimitPrice;
            }
            if (stopIcebergQty !== undefined && stopIcebergQty !== null) {
                localVarQueryParameter['stopIcebergQty'] = stopIcebergQty;
            }
            if (stopLimitTimeInForce !== undefined && stopLimitTimeInForce !== null) {
                localVarQueryParameter['stopLimitTimeInForce'] = stopLimitTimeInForce;
            }
            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }
            if (sideEffectType !== undefined && sideEffectType !== null) {
                localVarQueryParameter['sideEffectType'] = sideEffectType;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/order/oco',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Repay for a margin loan.
         *
         * Weight: 100
         *
         * @summary Margin Account Repay(MARGIN)
         * @param {string} asset
         * @param {number} amount
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        marginAccountRepay: async (
            asset: string,
            amount: number,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('marginAccountRepay', 'asset', asset);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('marginAccountRepay', 'amount', amount);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (amount !== undefined && amount !== null) {
                localVarQueryParameter['amount'] = amount;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/repayLoan',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Repay debt for a margin loan.
         *
         * The repay asset amount cannot exceed 50000 USD equivalent value for a single request.
         * If `amount` is not sent, all the asset loan will be repaid if having enough specific repay assets.
         * If `amount` is sent, only the certain amount of the asset loan will be repaid if having enough specific repay assets.
         * The system will use the same asset to repay the loan first (if have) no matter whether put the asset in `specifyRepayAssets`
         *
         * Weight: 3000
         *
         * @summary Margin Account Repay Debt(TRADE)
         * @param {string} asset
         * @param {string} [amount]
         * @param {string} [specifyRepayAssets] Specific asset list to repay debt; Can be added in batch, separated by commas
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        marginAccountRepayDebt: async (
            asset: string,
            amount?: string,
            specifyRepayAssets?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('marginAccountRepayDebt', 'asset', asset);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (asset !== undefined && asset !== null) {
                localVarQueryParameter['asset'] = asset;
            }
            if (amount !== undefined && amount !== null) {
                localVarQueryParameter['amount'] = amount;
            }
            if (specifyRepayAssets !== undefined && specifyRepayAssets !== null) {
                localVarQueryParameter['specifyRepayAssets'] = specifyRepayAssets;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/repay-debt',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Margin Account Trade List
         *
         * Weight: 5
         *
         * @summary Margin Account Trade List (USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        marginAccountTradeList: async (
            symbol: string,
            orderId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            fromId?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountTradeList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/myTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         * Both `quantity` and `price` must be sent
         * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
         * However the order will be cancelled by the amendment in the following situations:
         * when the order is in partially filled status and the new `quantity` <= `executedQty`
         * When the order is `GTX` and the new price will cause it to be executed immediately
         *
         * Weight: 1
         *
         * @summary Modify CM Order(TRADE)
         * @param {string} symbol
         * @param {ModifyCmOrderSideEnum} side
         * @param {number} quantity Order quantity
         * @param {number} price
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {ModifyCmOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyCmOrder: async (
            symbol: string,
            side: ModifyCmOrderSideEnum,
            quantity: number,
            price: number,
            orderId?: number | bigint,
            origClientOrderId?: string,
            priceMatch?: ModifyCmOrderPriceMatchEnum,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('modifyCmOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('modifyCmOrder', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('modifyCmOrder', 'quantity', quantity);
            // verify required parameter 'price' is not null or undefined
            assertParamExists('modifyCmOrder', 'price', price);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/order',
                method: 'PUT',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         *
         * Either orderId or origClientOrderId must be sent, and the orderId will prevail if both are sent.
         * Both quantity and price must be sent
         * When the new quantity or price doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
         * However the order will be cancelled by the amendment in the following situations:
         * when the order is in partially filled status and the new quantity <= executedQty
         * When the order is GTX and the new price will cause it to be executed immediately
         *
         * Weight: 1
         *
         * @summary Modify UM Order(TRADE)
         * @param {string} symbol
         * @param {ModifyUmOrderSideEnum} side
         * @param {number} quantity Order quantity
         * @param {number} price
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {ModifyUmOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyUmOrder: async (
            symbol: string,
            side: ModifyUmOrderSideEnum,
            quantity: number,
            price: number,
            orderId?: number | bigint,
            origClientOrderId?: string,
            priceMatch?: ModifyUmOrderPriceMatchEnum,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('modifyUmOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('modifyUmOrder', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('modifyUmOrder', 'quantity', quantity);
            // verify required parameter 'price' is not null or undefined
            assertParamExists('modifyUmOrder', 'price', price);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/order',
                method: 'PUT',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * New CM Conditional Order
         *
         * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
         * Condition orders will be triggered when:
         * `STOP`, `STOP_MARKET`:
         * BUY: "MARK_PRICE"  >= `stopPrice`
         * SELL: "MARK_PRICE" <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: "MARK_PRICE" <= `stopPrice`
         * SELL: "MARK_PRICE" >= `stopPrice`
         * `TRAILING_STOP_MARKET`:
         * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
         * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
         * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
         * BUY: `activationPrice` should be smaller than latest mark price.
         * SELL: `activationPrice` should be larger than latest mark price.
         * Condition orders will be triggered when:
         * If parameter`priceProtect`is sent as true:
         * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
         * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
         * `STOP`, `STOP_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         *
         * Weight: 1
         *
         * @summary New CM Conditional Order(TRADE)
         * @param {string} symbol
         * @param {NewCmConditionalOrderSideEnum} side
         * @param {NewCmConditionalOrderStrategyTypeEnum} strategyType "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
         * @param {NewCmConditionalOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
         * @param {NewCmConditionalOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode .
         * @param {number} [price]
         * @param {NewCmConditionalOrderWorkingTypeEnum} [workingType] stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
         * @param {string} [priceProtect] "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
         * @param {string} [newClientStrategyId]
         * @param {number} [stopPrice] Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {number} [activationPrice] Used with `TRAILING_STOP_MARKET` orders, default as the mark price
         * @param {number} [callbackRate] Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newCmConditionalOrder: async (
            symbol: string,
            side: NewCmConditionalOrderSideEnum,
            strategyType: NewCmConditionalOrderStrategyTypeEnum,
            positionSide?: NewCmConditionalOrderPositionSideEnum,
            timeInForce?: NewCmConditionalOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            workingType?: NewCmConditionalOrderWorkingTypeEnum,
            priceProtect?: string,
            newClientStrategyId?: string,
            stopPrice?: number,
            activationPrice?: number,
            callbackRate?: number,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newCmConditionalOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newCmConditionalOrder', 'side', side);
            // verify required parameter 'strategyType' is not null or undefined
            assertParamExists('newCmConditionalOrder', 'strategyType', strategyType);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }
            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }
            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }
            if (priceProtect !== undefined && priceProtect !== null) {
                localVarQueryParameter['priceProtect'] = priceProtect;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }
            if (activationPrice !== undefined && activationPrice !== null) {
                localVarQueryParameter['activationPrice'] = activationPrice;
            }
            if (callbackRate !== undefined && callbackRate !== null) {
                localVarQueryParameter['callbackRate'] = callbackRate;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/order',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place new CM order
         *
         * If `newOrderRespType` is sent as `RESULT` :
         * `MARKET` order: the final FILLED result of the order will be return directly.
         * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
         *
         * Weight: 1
         *
         * @summary New CM Order(TRADE)
         * @param {string} symbol
         * @param {NewCmOrderSideEnum} side
         * @param {NewCmOrderTypeEnum} type `LIMIT`, `MARKET`
         * @param {NewCmOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
         * @param {NewCmOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode .
         * @param {number} [price]
         * @param {NewCmOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {NewCmOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newCmOrder: async (
            symbol: string,
            side: NewCmOrderSideEnum,
            type: NewCmOrderTypeEnum,
            positionSide?: NewCmOrderPositionSideEnum,
            timeInForce?: NewCmOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            priceMatch?: NewCmOrderPriceMatchEnum,
            newClientOrderId?: string,
            newOrderRespType?: NewCmOrderNewOrderRespTypeEnum,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newCmOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newCmOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newCmOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }
            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }
            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }
            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }
            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/order',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * New Margin Order
         *
         * Weight: 1
         *
         * @summary New Margin Order(TRADE)
         * @param {string} symbol
         * @param {NewMarginOrderSideEnum} side
         * @param {NewMarginOrderTypeEnum} type `LIMIT`, `MARKET`
         * @param {number} [quantity]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {number} [stopPrice] Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {NewMarginOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {number} [icebergQty] Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order
         * @param {NewMarginOrderSideEffectTypeEnum} [sideEffectType] NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY; default NO_SIDE_EFFECT.
         * @param {NewMarginOrderTimeInForceEnum} [timeInForce]
         * @param {NewMarginOrderSelfTradePreventionModeEnum} [selfTradePreventionMode] `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
         * @param {boolean} [autoRepayAtCancel] truetrue
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newMarginOrder: async (
            symbol: string,
            side: NewMarginOrderSideEnum,
            type: NewMarginOrderTypeEnum,
            quantity?: number,
            quoteOrderQty?: number,
            price?: number,
            stopPrice?: number,
            newClientOrderId?: string,
            newOrderRespType?: NewMarginOrderNewOrderRespTypeEnum,
            icebergQty?: number,
            sideEffectType?: NewMarginOrderSideEffectTypeEnum,
            timeInForce?: NewMarginOrderTimeInForceEnum,
            selfTradePreventionMode?: NewMarginOrderSelfTradePreventionModeEnum,
            autoRepayAtCancel?: boolean,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newMarginOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newMarginOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newMarginOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }
            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }
            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }
            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }
            if (sideEffectType !== undefined && sideEffectType !== null) {
                localVarQueryParameter['sideEffectType'] = sideEffectType;
            }
            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }
            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }
            if (autoRepayAtCancel !== undefined && autoRepayAtCancel !== null) {
                localVarQueryParameter['autoRepayAtCancel'] = autoRepayAtCancel;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/order',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place new UM conditional order
         *
         * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
         * Condition orders will be triggered when:
         * `STOP`, `STOP_MARKET`:
         * BUY: "MARK_PRICE"  >= `stopPrice`
         * SELL: "MARK_PRICE" <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: "MARK_PRICE" <= `stopPrice`
         * SELL: "MARK_PRICE" >= `stopPrice`
         * `TRAILING_STOP_MARKET`:
         * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
         * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
         * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
         * BUY: `activationPrice` should be smaller than latest mark price.
         * SELL: `activationPrice` should be larger than latest mark price.
         * Condition orders will be triggered when:
         * If parameter`priceProtect`is sent as true:
         * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
         * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
         * `STOP`, `STOP_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
         * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
         *
         * Weight: 1
         *
         * @summary New UM Conditional Order (TRADE)
         * @param {string} symbol
         * @param {NewUmConditionalOrderSideEnum} side
         * @param {NewUmConditionalOrderStrategyTypeEnum} strategyType "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
         * @param {NewUmConditionalOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
         * @param {NewUmConditionalOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode .
         * @param {number} [price]
         * @param {NewUmConditionalOrderWorkingTypeEnum} [workingType] stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
         * @param {string} [priceProtect] "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
         * @param {string} [newClientStrategyId]
         * @param {number} [stopPrice] Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {number} [activationPrice] Used with `TRAILING_STOP_MARKET` orders, default as the mark price
         * @param {number} [callbackRate] Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
         * @param {NewUmConditionalOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {NewUmConditionalOrderSelfTradePreventionModeEnum} [selfTradePreventionMode] `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
         * @param {number | bigint} [goodTillDate] order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newUmConditionalOrder: async (
            symbol: string,
            side: NewUmConditionalOrderSideEnum,
            strategyType: NewUmConditionalOrderStrategyTypeEnum,
            positionSide?: NewUmConditionalOrderPositionSideEnum,
            timeInForce?: NewUmConditionalOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            workingType?: NewUmConditionalOrderWorkingTypeEnum,
            priceProtect?: string,
            newClientStrategyId?: string,
            stopPrice?: number,
            activationPrice?: number,
            callbackRate?: number,
            priceMatch?: NewUmConditionalOrderPriceMatchEnum,
            selfTradePreventionMode?: NewUmConditionalOrderSelfTradePreventionModeEnum,
            goodTillDate?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newUmConditionalOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newUmConditionalOrder', 'side', side);
            // verify required parameter 'strategyType' is not null or undefined
            assertParamExists('newUmConditionalOrder', 'strategyType', strategyType);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }
            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }
            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }
            if (priceProtect !== undefined && priceProtect !== null) {
                localVarQueryParameter['priceProtect'] = priceProtect;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }
            if (activationPrice !== undefined && activationPrice !== null) {
                localVarQueryParameter['activationPrice'] = activationPrice;
            }
            if (callbackRate !== undefined && callbackRate !== null) {
                localVarQueryParameter['callbackRate'] = callbackRate;
            }
            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }
            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }
            if (goodTillDate !== undefined && goodTillDate !== null) {
                localVarQueryParameter['goodTillDate'] = goodTillDate;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/order',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place new UM order
         *
         * If `newOrderRespType` is sent as `RESULT` :
         * `MARKET` order: the final FILLED result of the order will be return directly.
         * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
         * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
         * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
         *
         * Weight: 1
         *
         * @summary New UM Order (TRADE)
         * @param {string} symbol
         * @param {NewUmOrderSideEnum} side
         * @param {NewUmOrderTypeEnum} type `LIMIT`, `MARKET`
         * @param {NewUmOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
         * @param {NewUmOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode .
         * @param {number} [price]
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {NewUmOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {NewUmOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {NewUmOrderSelfTradePreventionModeEnum} [selfTradePreventionMode] `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
         * @param {number | bigint} [goodTillDate] order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newUmOrder: async (
            symbol: string,
            side: NewUmOrderSideEnum,
            type: NewUmOrderTypeEnum,
            positionSide?: NewUmOrderPositionSideEnum,
            timeInForce?: NewUmOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            newClientOrderId?: string,
            newOrderRespType?: NewUmOrderNewOrderRespTypeEnum,
            priceMatch?: NewUmOrderPriceMatchEnum,
            selfTradePreventionMode?: NewUmOrderSelfTradePreventionModeEnum,
            goodTillDate?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newUmOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newUmOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newUmOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }
            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }
            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }
            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }
            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }
            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }
            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }
            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }
            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }
            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }
            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }
            if (goodTillDate !== undefined && goodTillDate !== null) {
                localVarQueryParameter['goodTillDate'] = goodTillDate;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/order',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query All CM Conditional Orders
         *
         * These orders will not be found:
         * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 7 days < current time
         * The query time period must be less than 7 days( default as the recent 7 days).
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         *
         * @summary Query All CM Conditional Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [strategyId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllCmConditionalOrders: async (
            symbol?: string,
            strategyId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/allOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all account CM orders; active, canceled, or filled.
         *
         * Either `symbol` or `pair` must be sent.
         * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 3 days < current time
         *
         * Weight: 20 with symbol, 40 with pair
         *
         * @summary Query All CM Orders (USER_DATA)
         * @param {string} symbol
         * @param {string} [pair]
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllCmOrders: async (
            symbol: string,
            pair?: string,
            orderId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryAllCmOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/allOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open conditional orders on a symbol. **Careful** when accessing this with no symbol.
         *
         * If the symbol is not sent, orders for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         *
         * @summary Query All Current CM Open Conditional Orders (USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllCurrentCmOpenConditionalOrders: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/openOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open orders on a symbol.
         *
         * If the symbol is not sent, orders for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         * Careful when accessing this with no symbol.
         *
         * @summary Query All Current CM Open Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {string} [pair]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllCurrentCmOpenOrders: async (
            symbol?: string,
            pair?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/openOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open conditional orders on a symbol.
         *
         * If the symbol is not sent, orders for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         * Careful when accessing this with no symbol.
         *
         * @summary Query All Current UM Open Conditional Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllCurrentUmOpenConditionalOrders: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/openOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open orders on a symbol.
         *
         *
         * If the symbol is not sent, orders for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         *
         * @summary Query All Current UM Open Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllCurrentUmOpenOrders: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/openOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query All Margin Account Orders
         *
         * Weight: 100
         *
         * @summary Query All Margin Account Orders (USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllMarginAccountOrders: async (
            symbol: string,
            orderId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryAllMarginAccountOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/allOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query All UM Conditional Orders
         *
         * These orders will not be found:
         * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 7 days < current time
         * The query time period must be less than 7 days( default as the recent 7 days).
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         *
         * @summary Query All UM Conditional Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [strategyId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllUmConditionalOrders: async (
            symbol?: string,
            strategyId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/allOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all account UM orders; active, canceled, or filled.
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 3 days < current time
         *
         * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
         * The query time period must be less then 7 days( default as the recent 7 days).
         *
         * Weight: 5
         *
         * @summary Query All UM Orders(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryAllUmOrders: async (
            symbol: string,
            orderId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryAllUmOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/allOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query CM Conditional Order History
         *
         *
         * Either `strategyId` or `newClientStrategyId` must be sent.
         * `NEW` orders will not be found.
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 7 days < current time
         *
         * Weight: 1
         *
         * @summary Query CM Conditional Order History(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [strategyId]
         * @param {string} [newClientStrategyId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCmConditionalOrderHistory: async (
            symbol: string,
            strategyId?: number | bigint,
            newClientStrategyId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCmConditionalOrderHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/orderHistory',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get order modification history
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         *
         * Weight: 1
         *
         * @summary Query CM Modify Order History(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCmModifyOrderHistory: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCmModifyOrderHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/orderAmendment',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an CM order's status.
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 3 days < current time
         *
         * Weight: 1
         *
         * @summary Query CM Order(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCmOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCmOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/order',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Current CM Open Conditional Order
         *
         * Either `strategyId` or `newClientStrategyId` must be sent.
         * If the queried order has been triggered, cancelled or expired, the error message "Order does not exist" will be returned.
         *
         * Weight: 1
         *
         * @summary Query Current CM Open Conditional Order(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [strategyId]
         * @param {string} [newClientStrategyId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentCmOpenConditionalOrder: async (
            symbol: string,
            strategyId?: number | bigint,
            newClientStrategyId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentCmOpenConditionalOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/conditional/openOrder',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query current CM open order
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
         *
         * Weight: 1
         *
         * @summary Query Current CM Open Order (USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentCmOpenOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentCmOpenOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/openOrder',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Current Margin Open Order
         *
         * Weight: 5
         *
         * @summary Query Current Margin Open Order (USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentMarginOpenOrder: async (
            symbol: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentMarginOpenOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/openOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Current UM Open Conditional Order
         *
         * Either `strategyId` or `newClientStrategyId` must be sent.
         * If the queried order has been `CANCELED`, `TRIGGERED``EXPIRED`, the error message "Order does not exist" will be returned.
         *
         * Weight: 1
         *
         * @summary Query Current UM Open Conditional Order(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [strategyId]
         * @param {string} [newClientStrategyId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentUmOpenConditionalOrder: async (
            symbol: string,
            strategyId?: number | bigint,
            newClientStrategyId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentUmOpenConditionalOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/openOrder',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query current UM open order
         *
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
         *
         * Weight: 1
         *
         * @summary Query Current UM Open Order(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentUmOpenOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentUmOpenOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/openOrder',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account Order
         *
         * Weight: 10
         *
         * @summary Query Margin Account Order (USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginAccountOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryMarginAccountOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/order',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query all OCO for a specific margin account based on provided optional parameters
         *
         * Weight: 100
         *
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {number | bigint} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsAllOco: async (
            fromId?: number | bigint,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/allOrderList',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         *
         * Weight: 5
         *
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {number | bigint} [orderListId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsOco: async (
            orderListId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/orderList',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account's Open OCO
         *
         * Weight: 5
         *
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsOpenOco: async (recvWindow?: number | bigint): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/openOrderList',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query UM Conditional Order History
         *
         * Either `strategyId` or `newClientStrategyId` must be sent.
         * `NEW` orders will not be found.
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 7 days < current time
         *
         * Weight: 1
         *
         * @summary Query UM Conditional Order History(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [strategyId]
         * @param {string} [newClientStrategyId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUmConditionalOrderHistory: async (
            symbol: string,
            strategyId?: number | bigint,
            newClientStrategyId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryUmConditionalOrderHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }
            if (newClientStrategyId !== undefined && newClientStrategyId !== null) {
                localVarQueryParameter['newClientStrategyId'] = newClientStrategyId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/conditional/orderHistory',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get order modification history
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         *
         * Weight: 1
         *
         * @summary Query UM Modify Order History(TRADE)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUmModifyOrderHistory: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryUmModifyOrderHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/orderAmendment',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an UM order's status.
         *
         * These orders will not be found:
         * Either `orderId` or `origClientOrderId` must be sent.
         * order status is `CANCELED` or `EXPIRED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 3 days < current time
         *
         * Weight: 1
         *
         * @summary Query UM Order (USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUmOrder: async (
            symbol: string,
            orderId?: number | bigint,
            origClientOrderId?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryUmOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/order',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query User's CM Force Orders
         *
         * If "autoCloseType" is not sent, orders with both of the types will be returned
         * If "startTime" is not sent, data within 7 days before "endTime" can be queried
         *
         * Weight: 20 with symbol, 50 without symbol
         *
         * @summary Query User\'s CM Force Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {QueryUsersCmForceOrdersAutoCloseTypeEnum} [autoCloseType] `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUsersCmForceOrders: async (
            symbol?: string,
            autoCloseType?: QueryUsersCmForceOrdersAutoCloseTypeEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (autoCloseType !== undefined && autoCloseType !== null) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/cm/forceOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query user's margin force orders
         *
         * Weight: 1
         *
         * @summary Query User\'s Margin Force Orders(USER_DATA)
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [current] Currently querying page. Start from 1. Default:1
         * @param {number | bigint} [size] Default:10 Max:100
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUsersMarginForceOrders: async (
            startTime?: number | bigint,
            endTime?: number | bigint,
            current?: number | bigint,
            size?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (current !== undefined && current !== null) {
                localVarQueryParameter['current'] = current;
            }
            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/margin/forceOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query User's UM Force Orders
         *
         * If `autoCloseType` is not sent, orders with both of the types will be returned
         * If `startTime` is not sent, data within 7 days before `endTime` can be queried
         *
         * Weight: 20 with symbol, 50 without symbol
         *
         * @summary Query User\'s UM Force Orders (USER_DATA)
         * @param {string} [symbol]
         * @param {QueryUsersUmForceOrdersAutoCloseTypeEnum} [autoCloseType] `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryUsersUmForceOrders: async (
            symbol?: string,
            autoCloseType?: QueryUsersUmForceOrdersAutoCloseTypeEnum,
            startTime?: number | bigint,
            endTime?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (autoCloseType !== undefined && autoCloseType !== null) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/forceOrders',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on ***EVERY symbol***
         *
         *
         * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
         *
         * Weight: 1
         *
         * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
         * @param {string} feeBurn "true": Fee Discount On; "false": Fee Discount Off
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        toggleBnbBurnOnUmFuturesTrade: async (
            feeBurn: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'feeBurn' is not null or undefined
            assertParamExists('toggleBnbBurnOnUmFuturesTrade', 'feeBurn', feeBurn);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (feeBurn !== undefined && feeBurn !== null) {
                localVarQueryParameter['feeBurn'] = feeBurn;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/feeBurn',
                method: 'POST',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get trades for a specific account and UM symbol.
         *
         *
         * If `startTime` and `endTime` are both not sent, then the last '7 days' data will be returned.
         * The time between `startTime` and `endTime` cannot be longer than 7 days.
         * The parameter `fromId` cannot be sent with `startTime` or `endTime`.
         *
         * Weight: 5
         *
         * @summary UM Account Trade List(USER_DATA)
         * @param {string} symbol
         * @param {number | bigint} [startTime] Timestamp in ms to get funding from INCLUSIVE.
         * @param {number | bigint} [endTime] Timestamp in ms to get funding until INCLUSIVE.
         * @param {number | bigint} [fromId] Trade id to fetch from. Default gets most recent trades.
         * @param {number | bigint} [limit] Default 100; max 1000
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        umAccountTradeList: async (
            symbol: string,
            startTime?: number | bigint,
            endTime?: number | bigint,
            fromId?: number | bigint,
            limit?: number | bigint,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('umAccountTradeList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }
            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }
            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/userTrades',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query UM Position ADL Quantile Estimation
         *
         * Values update every 30s.
         * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
         * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
         * If the positions of the symbol are crossed margined in Hedge Mode:
         * "HEDGE" as a sign will be returned instead of "BOTH";
         * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
         *
         * Weight: 5
         *
         * @summary UM Position ADL Quantile Estimation(USER_DATA)
         * @param {string} [symbol]
         * @param {number | bigint} [recvWindow]
         *
         * @throws {RequiredError}
         */
        umPositionAdlQuantileEstimation: async (
            symbol?: string,
            recvWindow?: number | bigint
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};
            const localVarBodyParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }
            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/papi/v1/um/adlQuantile',
                method: 'GET',
                queryParams: localVarQueryParameter,
                bodyParams: localVarBodyParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Cancel All CM Open Conditional Orders
     *
     * Weight: 1
     *
     * @summary Cancel All CM Open Conditional Orders(TRADE)
     * @param {CancelAllCmOpenConditionalOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllCmOpenConditionalOrders(
        requestParameters: CancelAllCmOpenConditionalOrdersRequest
    ): Promise<RestApiResponse<CancelAllCmOpenConditionalOrdersResponse>>;
    /**
     * Cancel all active LIMIT orders on specific symbol
     *
     * Weight: 1
     *
     * @summary Cancel All CM Open Orders(TRADE)
     * @param {CancelAllCmOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllCmOpenOrders(
        requestParameters: CancelAllCmOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllCmOpenOrdersResponse>>;
    /**
     * Cancel All UM Open Conditional Orders
     *
     * Weight: 1
     *
     * @summary Cancel All UM Open Conditional Orders (TRADE)
     * @param {CancelAllUmOpenConditionalOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllUmOpenConditionalOrders(
        requestParameters: CancelAllUmOpenConditionalOrdersRequest
    ): Promise<RestApiResponse<CancelAllUmOpenConditionalOrdersResponse>>;
    /**
     * Cancel all active LIMIT orders on specific symbol
     *
     * Weight: 1
     *
     * @summary Cancel All UM Open Orders(TRADE)
     * @param {CancelAllUmOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllUmOpenOrders(
        requestParameters: CancelAllUmOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllUmOpenOrdersResponse>>;
    /**
     * Cancel CM Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel CM Conditional Order(TRADE)
     * @param {CancelCmConditionalOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelCmConditionalOrder(
        requestParameters: CancelCmConditionalOrderRequest
    ): Promise<RestApiResponse<CancelCmConditionalOrderResponse>>;
    /**
     * Cancel an active LIMIT order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel CM Order(TRADE)
     * @param {CancelCmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelCmOrder(
        requestParameters: CancelCmOrderRequest
    ): Promise<RestApiResponse<CancelCmOrderResponse>>;
    /**
     * Cancel Margin Account All Open Orders on a Symbol
     *
     * Weight: 5
     *
     * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
     * @param {CancelMarginAccountAllOpenOrdersOnASymbolRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelMarginAccountAllOpenOrdersOnASymbol(
        requestParameters: CancelMarginAccountAllOpenOrdersOnASymbolRequest
    ): Promise<RestApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>>;
    /**
     * Cancel Margin Account OCO Orders
     *
     * Additional notes: Canceling an individual leg will cancel the entire OCO
     *
     * Weight: 2
     *
     * @summary Cancel Margin Account OCO Orders(TRADE)
     * @param {CancelMarginAccountOcoOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelMarginAccountOcoOrders(
        requestParameters: CancelMarginAccountOcoOrdersRequest
    ): Promise<RestApiResponse<CancelMarginAccountOcoOrdersResponse>>;
    /**
     * Cancel Margin Account Order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 2
     *
     * @summary Cancel Margin Account Order(TRADE)
     * @param {CancelMarginAccountOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelMarginAccountOrder(
        requestParameters: CancelMarginAccountOrderRequest
    ): Promise<RestApiResponse<CancelMarginAccountOrderResponse>>;
    /**
     * Cancel UM Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel UM Conditional Order(TRADE)
     * @param {CancelUmConditionalOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelUmConditionalOrder(
        requestParameters: CancelUmConditionalOrderRequest
    ): Promise<RestApiResponse<CancelUmConditionalOrderResponse>>;
    /**
     * Cancel an active UM LIMIT order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel UM Order(TRADE)
     * @param {CancelUmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelUmOrder(
        requestParameters: CancelUmOrderRequest
    ): Promise<RestApiResponse<CancelUmOrderResponse>>;
    /**
     * Get trades for a specific account and CM symbol.
     *
     * Either `symbol` or `pair` must be sent
     * `symbol` and `pair` cannot be sent together
     * `pair` and `fromId` cannot be sent together
     * `OrderId` can only be sent together with symbol
     * If a `pair` is sent, tickers for all symbols of the `pair` will be returned
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`
     * If `startTime` and `endTime` are both not sent, then the last '24 hours' data will be returned.
     * The time between `startTime` and `endTime` cannot be longer than 24 hours.
     *
     * Weight: 20 with symbol, 40 with pair
     *
     * @summary CM Account Trade List(USER_DATA)
     * @param {CmAccountTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cmAccountTradeList(
        requestParameters?: CmAccountTradeListRequest
    ): Promise<RestApiResponse<CmAccountTradeListResponse>>;
    /**
     * Query CM Position ADL Quantile Estimation
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary CM Position ADL Quantile Estimation(USER_DATA)
     * @param {CmPositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cmPositionAdlQuantileEstimation(
        requestParameters?: CmPositionAdlQuantileEstimationRequest
    ): Promise<RestApiResponse<CmPositionAdlQuantileEstimationResponse>>;
    /**
     * Get user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     *
     * Weight: 30
     *
     * @summary Get UM Futures BNB Burn Status (USER_DATA)
     * @param {GetUmFuturesBnbBurnStatusRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getUmFuturesBnbBurnStatus(
        requestParameters?: GetUmFuturesBnbBurnStatusRequest
    ): Promise<RestApiResponse<GetUmFuturesBnbBurnStatusResponse>>;
    /**
     * Apply for a margin loan.
     *
     * Weight: 100
     *
     * @summary Margin Account Borrow(MARGIN)
     * @param {MarginAccountBorrowRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountBorrow(
        requestParameters: MarginAccountBorrowRequest
    ): Promise<RestApiResponse<MarginAccountBorrowResponse>>;
    /**
     * Send in a new OCO for a margin account
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity
     * `ICEBERG` quantities however do not have to be the same.
     * Order Rate Limit
     * `OCO` counts as 2 orders against the order rate limit.
     *
     * Weight: 1
     *
     * @summary Margin Account New OCO(TRADE)
     * @param {MarginAccountNewOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountNewOco(
        requestParameters: MarginAccountNewOcoRequest
    ): Promise<RestApiResponse<MarginAccountNewOcoResponse>>;
    /**
     * Repay for a margin loan.
     *
     * Weight: 100
     *
     * @summary Margin Account Repay(MARGIN)
     * @param {MarginAccountRepayRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountRepay(
        requestParameters: MarginAccountRepayRequest
    ): Promise<RestApiResponse<MarginAccountRepayResponse>>;
    /**
     * Repay debt for a margin loan.
     *
     * The repay asset amount cannot exceed 50000 USD equivalent value for a single request.
     * If `amount` is not sent, all the asset loan will be repaid if having enough specific repay assets.
     * If `amount` is sent, only the certain amount of the asset loan will be repaid if having enough specific repay assets.
     * The system will use the same asset to repay the loan first (if have) no matter whether put the asset in `specifyRepayAssets`
     *
     * Weight: 3000
     *
     * @summary Margin Account Repay Debt(TRADE)
     * @param {MarginAccountRepayDebtRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountRepayDebt(
        requestParameters: MarginAccountRepayDebtRequest
    ): Promise<RestApiResponse<MarginAccountRepayDebtResponse>>;
    /**
     * Margin Account Trade List
     *
     * Weight: 5
     *
     * @summary Margin Account Trade List (USER_DATA)
     * @param {MarginAccountTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountTradeList(
        requestParameters: MarginAccountTradeListRequest
    ): Promise<RestApiResponse<MarginAccountTradeListResponse>>;
    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Both `quantity` and `price` must be sent
     * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new `quantity` <= `executedQty`
     * When the order is `GTX` and the new price will cause it to be executed immediately
     *
     * Weight: 1
     *
     * @summary Modify CM Order(TRADE)
     * @param {ModifyCmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyCmOrder(
        requestParameters: ModifyCmOrderRequest
    ): Promise<RestApiResponse<ModifyCmOrderResponse>>;
    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     * Either orderId or origClientOrderId must be sent, and the orderId will prevail if both are sent.
     * Both quantity and price must be sent
     * When the new quantity or price doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new quantity <= executedQty
     * When the order is GTX and the new price will cause it to be executed immediately
     *
     * Weight: 1
     *
     * @summary Modify UM Order(TRADE)
     * @param {ModifyUmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyUmOrder(
        requestParameters: ModifyUmOrderRequest
    ): Promise<RestApiResponse<ModifyUmOrderResponse>>;
    /**
     * New CM Conditional Order
     *
     * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     * `STOP`, `STOP_MARKET`:
     * BUY: "MARK_PRICE"  >= `stopPrice`
     * SELL: "MARK_PRICE" <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: "MARK_PRICE" <= `stopPrice`
     * SELL: "MARK_PRICE" >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
     * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
     * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest mark price.
     * SELL: `activationPrice` should be larger than latest mark price.
     * Condition orders will be triggered when:
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     *
     * Weight: 1
     *
     * @summary New CM Conditional Order(TRADE)
     * @param {NewCmConditionalOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newCmConditionalOrder(
        requestParameters: NewCmConditionalOrderRequest
    ): Promise<RestApiResponse<NewCmConditionalOrderResponse>>;
    /**
     * Place new CM order
     *
     * If `newOrderRespType` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * Weight: 1
     *
     * @summary New CM Order(TRADE)
     * @param {NewCmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newCmOrder(requestParameters: NewCmOrderRequest): Promise<RestApiResponse<NewCmOrderResponse>>;
    /**
     * New Margin Order
     *
     * Weight: 1
     *
     * @summary New Margin Order(TRADE)
     * @param {NewMarginOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newMarginOrder(
        requestParameters: NewMarginOrderRequest
    ): Promise<RestApiResponse<NewMarginOrderResponse>>;
    /**
     * Place new UM conditional order
     *
     * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     * `STOP`, `STOP_MARKET`:
     * BUY: "MARK_PRICE"  >= `stopPrice`
     * SELL: "MARK_PRICE" <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: "MARK_PRICE" <= `stopPrice`
     * SELL: "MARK_PRICE" >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
     * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
     * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest mark price.
     * SELL: `activationPrice` should be larger than latest mark price.
     * Condition orders will be triggered when:
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 1
     *
     * @summary New UM Conditional Order (TRADE)
     * @param {NewUmConditionalOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newUmConditionalOrder(
        requestParameters: NewUmConditionalOrderRequest
    ): Promise<RestApiResponse<NewUmConditionalOrderResponse>>;
    /**
     * Place new UM order
     *
     * If `newOrderRespType` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 1
     *
     * @summary New UM Order (TRADE)
     * @param {NewUmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newUmOrder(requestParameters: NewUmOrderRequest): Promise<RestApiResponse<NewUmOrderResponse>>;
    /**
     * Query All CM Conditional Orders
     *
     * These orders will not be found:
     * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     * The query time period must be less than 7 days( default as the recent 7 days).
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All CM Conditional Orders(USER_DATA)
     * @param {QueryAllCmConditionalOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllCmConditionalOrders(
        requestParameters?: QueryAllCmConditionalOrdersRequest
    ): Promise<RestApiResponse<QueryAllCmConditionalOrdersResponse>>;
    /**
     * Get all account CM orders; active, canceled, or filled.
     *
     * Either `symbol` or `pair` must be sent.
     * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * Weight: 20 with symbol, 40 with pair
     *
     * @summary Query All CM Orders (USER_DATA)
     * @param {QueryAllCmOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllCmOrders(
        requestParameters: QueryAllCmOrdersRequest
    ): Promise<RestApiResponse<QueryAllCmOrdersResponse>>;
    /**
     * Get all open conditional orders on a symbol. **Careful** when accessing this with no symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All Current CM Open Conditional Orders (USER_DATA)
     * @param {QueryAllCurrentCmOpenConditionalOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllCurrentCmOpenConditionalOrders(
        requestParameters?: QueryAllCurrentCmOpenConditionalOrdersRequest
    ): Promise<RestApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>>;
    /**
     * Get all open orders on a symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary Query All Current CM Open Orders(USER_DATA)
     * @param {QueryAllCurrentCmOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllCurrentCmOpenOrders(
        requestParameters?: QueryAllCurrentCmOpenOrdersRequest
    ): Promise<RestApiResponse<QueryAllCurrentCmOpenOrdersResponse>>;
    /**
     * Get all open conditional orders on a symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary Query All Current UM Open Conditional Orders(USER_DATA)
     * @param {QueryAllCurrentUmOpenConditionalOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllCurrentUmOpenConditionalOrders(
        requestParameters?: QueryAllCurrentUmOpenConditionalOrdersRequest
    ): Promise<RestApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>>;
    /**
     * Get all open orders on a symbol.
     *
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All Current UM Open Orders(USER_DATA)
     * @param {QueryAllCurrentUmOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllCurrentUmOpenOrders(
        requestParameters?: QueryAllCurrentUmOpenOrdersRequest
    ): Promise<RestApiResponse<QueryAllCurrentUmOpenOrdersResponse>>;
    /**
     * Query All Margin Account Orders
     *
     * Weight: 100
     *
     * @summary Query All Margin Account Orders (USER_DATA)
     * @param {QueryAllMarginAccountOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllMarginAccountOrders(
        requestParameters: QueryAllMarginAccountOrdersRequest
    ): Promise<RestApiResponse<QueryAllMarginAccountOrdersResponse>>;
    /**
     * Query All UM Conditional Orders
     *
     * These orders will not be found:
     * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     * The query time period must be less than 7 days( default as the recent 7 days).
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All UM Conditional Orders(USER_DATA)
     * @param {QueryAllUmConditionalOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllUmConditionalOrders(
        requestParameters?: QueryAllUmConditionalOrdersRequest
    ): Promise<RestApiResponse<QueryAllUmConditionalOrdersResponse>>;
    /**
     * Get all account UM orders; active, canceled, or filled.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
     * The query time period must be less then 7 days( default as the recent 7 days).
     *
     * Weight: 5
     *
     * @summary Query All UM Orders(USER_DATA)
     * @param {QueryAllUmOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryAllUmOrders(
        requestParameters: QueryAllUmOrdersRequest
    ): Promise<RestApiResponse<QueryAllUmOrdersResponse>>;
    /**
     * Query CM Conditional Order History
     *
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * `NEW` orders will not be found.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     *
     * Weight: 1
     *
     * @summary Query CM Conditional Order History(USER_DATA)
     * @param {QueryCmConditionalOrderHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCmConditionalOrderHistory(
        requestParameters: QueryCmConditionalOrderHistoryRequest
    ): Promise<RestApiResponse<QueryCmConditionalOrderHistoryResponse>>;
    /**
     * Get order modification history
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     *
     * Weight: 1
     *
     * @summary Query CM Modify Order History(TRADE)
     * @param {QueryCmModifyOrderHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCmModifyOrderHistory(
        requestParameters: QueryCmModifyOrderHistoryRequest
    ): Promise<RestApiResponse<QueryCmModifyOrderHistoryResponse>>;
    /**
     * Check an CM order's status.
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * Weight: 1
     *
     * @summary Query CM Order(USER_DATA)
     * @param {QueryCmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCmOrder(
        requestParameters: QueryCmOrderRequest
    ): Promise<RestApiResponse<QueryCmOrderResponse>>;
    /**
     * Query Current CM Open Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * If the queried order has been triggered, cancelled or expired, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current CM Open Conditional Order(USER_DATA)
     * @param {QueryCurrentCmOpenConditionalOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentCmOpenConditionalOrder(
        requestParameters: QueryCurrentCmOpenConditionalOrderRequest
    ): Promise<RestApiResponse<QueryCurrentCmOpenConditionalOrderResponse>>;
    /**
     * Query current CM open order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current CM Open Order (USER_DATA)
     * @param {QueryCurrentCmOpenOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentCmOpenOrder(
        requestParameters: QueryCurrentCmOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentCmOpenOrderResponse>>;
    /**
     * Query Current Margin Open Order
     *
     * Weight: 5
     *
     * @summary Query Current Margin Open Order (USER_DATA)
     * @param {QueryCurrentMarginOpenOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentMarginOpenOrder(
        requestParameters: QueryCurrentMarginOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentMarginOpenOrderResponse>>;
    /**
     * Query Current UM Open Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * If the queried order has been `CANCELED`, `TRIGGERED``EXPIRED`, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current UM Open Conditional Order(USER_DATA)
     * @param {QueryCurrentUmOpenConditionalOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentUmOpenConditionalOrder(
        requestParameters: QueryCurrentUmOpenConditionalOrderRequest
    ): Promise<RestApiResponse<QueryCurrentUmOpenConditionalOrderResponse>>;
    /**
     * Query current UM open order
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current UM Open Order(USER_DATA)
     * @param {QueryCurrentUmOpenOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentUmOpenOrder(
        requestParameters: QueryCurrentUmOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentUmOpenOrderResponse>>;
    /**
     * Query Margin Account Order
     *
     * Weight: 10
     *
     * @summary Query Margin Account Order (USER_DATA)
     * @param {QueryMarginAccountOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountOrder(
        requestParameters: QueryMarginAccountOrderRequest
    ): Promise<RestApiResponse<QueryMarginAccountOrderResponse>>;
    /**
     * Query all OCO for a specific margin account based on provided optional parameters
     *
     * Weight: 100
     *
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {QueryMarginAccountsAllOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsAllOco(
        requestParameters?: QueryMarginAccountsAllOcoRequest
    ): Promise<RestApiResponse<QueryMarginAccountsAllOcoResponse>>;
    /**
     * Retrieves a specific OCO based on provided optional parameters
     *
     * Weight: 5
     *
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {QueryMarginAccountsOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsOco(
        requestParameters?: QueryMarginAccountsOcoRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOcoResponse>>;
    /**
     * Query Margin Account's Open OCO
     *
     * Weight: 5
     *
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {QueryMarginAccountsOpenOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsOpenOco(
        requestParameters?: QueryMarginAccountsOpenOcoRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOpenOcoResponse>>;
    /**
     * Query UM Conditional Order History
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * `NEW` orders will not be found.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     *
     * Weight: 1
     *
     * @summary Query UM Conditional Order History(USER_DATA)
     * @param {QueryUmConditionalOrderHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryUmConditionalOrderHistory(
        requestParameters: QueryUmConditionalOrderHistoryRequest
    ): Promise<RestApiResponse<QueryUmConditionalOrderHistoryResponse>>;
    /**
     * Get order modification history
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     *
     * Weight: 1
     *
     * @summary Query UM Modify Order History(TRADE)
     * @param {QueryUmModifyOrderHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryUmModifyOrderHistory(
        requestParameters: QueryUmModifyOrderHistoryRequest
    ): Promise<RestApiResponse<QueryUmModifyOrderHistoryResponse>>;
    /**
     * Check an UM order's status.
     *
     * These orders will not be found:
     * Either `orderId` or `origClientOrderId` must be sent.
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * Weight: 1
     *
     * @summary Query UM Order (USER_DATA)
     * @param {QueryUmOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryUmOrder(
        requestParameters: QueryUmOrderRequest
    ): Promise<RestApiResponse<QueryUmOrderResponse>>;
    /**
     * Query User's CM Force Orders
     *
     * If "autoCloseType" is not sent, orders with both of the types will be returned
     * If "startTime" is not sent, data within 7 days before "endTime" can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary Query User\'s CM Force Orders(USER_DATA)
     * @param {QueryUsersCmForceOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryUsersCmForceOrders(
        requestParameters?: QueryUsersCmForceOrdersRequest
    ): Promise<RestApiResponse<QueryUsersCmForceOrdersResponse>>;
    /**
     * Query user's margin force orders
     *
     * Weight: 1
     *
     * @summary Query User\'s Margin Force Orders(USER_DATA)
     * @param {QueryUsersMarginForceOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryUsersMarginForceOrders(
        requestParameters?: QueryUsersMarginForceOrdersRequest
    ): Promise<RestApiResponse<QueryUsersMarginForceOrdersResponse>>;
    /**
     * Query User's UM Force Orders
     *
     * If `autoCloseType` is not sent, orders with both of the types will be returned
     * If `startTime` is not sent, data within 7 days before `endTime` can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary Query User\'s UM Force Orders (USER_DATA)
     * @param {QueryUsersUmForceOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryUsersUmForceOrders(
        requestParameters?: QueryUsersUmForceOrdersRequest
    ): Promise<RestApiResponse<QueryUsersUmForceOrdersResponse>>;
    /**
     * Change user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on ***EVERY symbol***
     *
     *
     * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
     *
     * Weight: 1
     *
     * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
     * @param {ToggleBnbBurnOnUmFuturesTradeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    toggleBnbBurnOnUmFuturesTrade(
        requestParameters: ToggleBnbBurnOnUmFuturesTradeRequest
    ): Promise<RestApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>>;
    /**
     * Get trades for a specific account and UM symbol.
     *
     *
     * If `startTime` and `endTime` are both not sent, then the last '7 days' data will be returned.
     * The time between `startTime` and `endTime` cannot be longer than 7 days.
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`.
     *
     * Weight: 5
     *
     * @summary UM Account Trade List(USER_DATA)
     * @param {UmAccountTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    umAccountTradeList(
        requestParameters: UmAccountTradeListRequest
    ): Promise<RestApiResponse<UmAccountTradeListResponse>>;
    /**
     * Query UM Position ADL Quantile Estimation
     *
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary UM Position ADL Quantile Estimation(USER_DATA)
     * @param {UmPositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    umPositionAdlQuantileEstimation(
        requestParameters?: UmPositionAdlQuantileEstimationRequest
    ): Promise<RestApiResponse<UmPositionAdlQuantileEstimationResponse>>;
}

/**
 * Request parameters for cancelAllCmOpenConditionalOrders operation in TradeApi.
 * @interface CancelAllCmOpenConditionalOrdersRequest
 */
export interface CancelAllCmOpenConditionalOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelAllCmOpenConditionalOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelAllCmOpenConditionalOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelAllCmOpenOrders operation in TradeApi.
 * @interface CancelAllCmOpenOrdersRequest
 */
export interface CancelAllCmOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelAllCmOpenOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelAllCmOpenOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelAllUmOpenConditionalOrders operation in TradeApi.
 * @interface CancelAllUmOpenConditionalOrdersRequest
 */
export interface CancelAllUmOpenConditionalOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelAllUmOpenConditionalOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelAllUmOpenConditionalOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelAllUmOpenOrders operation in TradeApi.
 * @interface CancelAllUmOpenOrdersRequest
 */
export interface CancelAllUmOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelAllUmOpenOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelAllUmOpenOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelCmConditionalOrder operation in TradeApi.
 * @interface CancelCmConditionalOrderRequest
 */
export interface CancelCmConditionalOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelCmConditionalOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelCmConditionalOrder
     */
    readonly strategyId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelCmConditionalOrder
     */
    readonly newClientStrategyId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelCmConditionalOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelCmOrder operation in TradeApi.
 * @interface CancelCmOrderRequest
 */
export interface CancelCmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelCmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelCmOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelCmOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelCmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelMarginAccountAllOpenOrdersOnASymbol operation in TradeApi.
 * @interface CancelMarginAccountAllOpenOrdersOnASymbolRequest
 */
export interface CancelMarginAccountAllOpenOrdersOnASymbolRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelMarginAccountAllOpenOrdersOnASymbol
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelMarginAccountAllOpenOrdersOnASymbol
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelMarginAccountOcoOrders operation in TradeApi.
 * @interface CancelMarginAccountOcoOrdersRequest
 */
export interface CancelMarginAccountOcoOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelMarginAccountOcoOrders
     */
    readonly symbol: string;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {number | bigint}
     * @memberof TradeApiCancelMarginAccountOcoOrders
     */
    readonly orderListId?: number | bigint;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {string}
     * @memberof TradeApiCancelMarginAccountOcoOrders
     */
    readonly listClientOrderId?: string;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiCancelMarginAccountOcoOrders
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelMarginAccountOcoOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelMarginAccountOrder operation in TradeApi.
 * @interface CancelMarginAccountOrderRequest
 */
export interface CancelMarginAccountOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelMarginAccountOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelMarginAccountOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelMarginAccountOrder
     */
    readonly origClientOrderId?: string;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiCancelMarginAccountOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelMarginAccountOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelUmConditionalOrder operation in TradeApi.
 * @interface CancelUmConditionalOrderRequest
 */
export interface CancelUmConditionalOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelUmConditionalOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelUmConditionalOrder
     */
    readonly strategyId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelUmConditionalOrder
     */
    readonly newClientStrategyId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelUmConditionalOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cancelUmOrder operation in TradeApi.
 * @interface CancelUmOrderRequest
 */
export interface CancelUmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelUmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelUmOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelUmOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCancelUmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cmAccountTradeList operation in TradeApi.
 * @interface CmAccountTradeListRequest
 */
export interface CmAccountTradeListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly pair?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly endTime?: number | bigint;

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number | bigint}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly fromId?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCmAccountTradeList
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for cmPositionAdlQuantileEstimation operation in TradeApi.
 * @interface CmPositionAdlQuantileEstimationRequest
 */
export interface CmPositionAdlQuantileEstimationRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCmPositionAdlQuantileEstimation
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiCmPositionAdlQuantileEstimation
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for getUmFuturesBnbBurnStatus operation in TradeApi.
 * @interface GetUmFuturesBnbBurnStatusRequest
 */
export interface GetUmFuturesBnbBurnStatusRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiGetUmFuturesBnbBurnStatus
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for marginAccountBorrow operation in TradeApi.
 * @interface MarginAccountBorrowRequest
 */
export interface MarginAccountBorrowRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountBorrow
     */
    readonly asset: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountBorrow
     */
    readonly amount: number;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountBorrow
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for marginAccountNewOco operation in TradeApi.
 * @interface MarginAccountNewOcoRequest
 */
export interface MarginAccountNewOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly side: MarginAccountNewOcoSideEnum;

    /**
     * Order quantity
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly price: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopPrice: number;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly listClientOrderId?: string;

    /**
     * A unique Id for the limit order
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly limitClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly limitIcebergQty?: number;

    /**
     * A unique Id for the stop loss/stop loss limit leg
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopClientOrderId?: string;

    /**
     * If provided, stopLimitTimeInForce is required.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopLimitPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopIcebergQty?: number;

    /**
     * Valid values are `GTC/FOK/IOC`
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopLimitTimeInForce?: MarginAccountNewOcoStopLimitTimeInForceEnum;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly newOrderRespType?: MarginAccountNewOcoNewOrderRespTypeEnum;

    /**
     * NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY; default NO_SIDE_EFFECT.
     * @type {'NO_SIDE_EFFECT' | 'MARGIN_BUY' | 'AUTO_REPAY'}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly sideEffectType?: MarginAccountNewOcoSideEffectTypeEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for marginAccountRepay operation in TradeApi.
 * @interface MarginAccountRepayRequest
 */
export interface MarginAccountRepayRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountRepay
     */
    readonly asset: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountRepay
     */
    readonly amount: number;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountRepay
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for marginAccountRepayDebt operation in TradeApi.
 * @interface MarginAccountRepayDebtRequest
 */
export interface MarginAccountRepayDebtRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountRepayDebt
     */
    readonly asset: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountRepayDebt
     */
    readonly amount?: string;

    /**
     * Specific asset list to repay debt; Can be added in batch, separated by commas
     * @type {string}
     * @memberof TradeApiMarginAccountRepayDebt
     */
    readonly specifyRepayAssets?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountRepayDebt
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for marginAccountTradeList operation in TradeApi.
 * @interface MarginAccountTradeListRequest
 */
export interface MarginAccountTradeListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly orderId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly endTime?: number | bigint;

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly fromId?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiMarginAccountTradeList
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for modifyCmOrder operation in TradeApi.
 * @interface ModifyCmOrderRequest
 */
export interface ModifyCmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiModifyCmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiModifyCmOrder
     */
    readonly side: ModifyCmOrderSideEnum;

    /**
     * Order quantity
     * @type {number}
     * @memberof TradeApiModifyCmOrder
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyCmOrder
     */
    readonly price: number;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiModifyCmOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiModifyCmOrder
     */
    readonly origClientOrderId?: string;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiModifyCmOrder
     */
    readonly priceMatch?: ModifyCmOrderPriceMatchEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiModifyCmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for modifyUmOrder operation in TradeApi.
 * @interface ModifyUmOrderRequest
 */
export interface ModifyUmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiModifyUmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiModifyUmOrder
     */
    readonly side: ModifyUmOrderSideEnum;

    /**
     * Order quantity
     * @type {number}
     * @memberof TradeApiModifyUmOrder
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyUmOrder
     */
    readonly price: number;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiModifyUmOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiModifyUmOrder
     */
    readonly origClientOrderId?: string;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiModifyUmOrder
     */
    readonly priceMatch?: ModifyUmOrderPriceMatchEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiModifyUmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for newCmConditionalOrder operation in TradeApi.
 * @interface NewCmConditionalOrderRequest
 */
export interface NewCmConditionalOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly side: NewCmConditionalOrderSideEnum;

    /**
     * "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
     * @type {'STOP' | 'STOP_MARKET' | 'TAKE_PROFIT' | 'TAKE_PROFIT_MARKET' | 'TRAILING_STOP_MARKET'}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly strategyType: NewCmConditionalOrderStrategyTypeEnum;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly positionSide?: NewCmConditionalOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX'}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly timeInForce?: NewCmConditionalOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode .
     * @type {string}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly price?: number;

    /**
     * stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
     * @type {'MARK_PRICE'}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly workingType?: NewCmConditionalOrderWorkingTypeEnum;

    /**
     * "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
     * @type {string}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly priceProtect?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly newClientStrategyId?: string;

    /**
     * Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {number}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly stopPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, default as the mark price
     * @type {number}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly activationPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
     * @type {number}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly callbackRate?: number;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiNewCmConditionalOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for newCmOrder operation in TradeApi.
 * @interface NewCmOrderRequest
 */
export interface NewCmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewCmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewCmOrder
     */
    readonly side: NewCmOrderSideEnum;

    /**
     * `LIMIT`, `MARKET`
     * @type {'LIMIT' | 'MARKET'}
     * @memberof TradeApiNewCmOrder
     */
    readonly type: NewCmOrderTypeEnum;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiNewCmOrder
     */
    readonly positionSide?: NewCmOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX'}
     * @memberof TradeApiNewCmOrder
     */
    readonly timeInForce?: NewCmOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewCmOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode .
     * @type {string}
     * @memberof TradeApiNewCmOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewCmOrder
     */
    readonly price?: number;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiNewCmOrder
     */
    readonly priceMatch?: NewCmOrderPriceMatchEnum;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiNewCmOrder
     */
    readonly newClientOrderId?: string;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiNewCmOrder
     */
    readonly newOrderRespType?: NewCmOrderNewOrderRespTypeEnum;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiNewCmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for newMarginOrder operation in TradeApi.
 * @interface NewMarginOrderRequest
 */
export interface NewMarginOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewMarginOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewMarginOrder
     */
    readonly side: NewMarginOrderSideEnum;

    /**
     * `LIMIT`, `MARKET`
     * @type {'LIMIT' | 'MARKET'}
     * @memberof TradeApiNewMarginOrder
     */
    readonly type: NewMarginOrderTypeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewMarginOrder
     */
    readonly quantity?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewMarginOrder
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewMarginOrder
     */
    readonly price?: number;

    /**
     * Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {number}
     * @memberof TradeApiNewMarginOrder
     */
    readonly stopPrice?: number;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiNewMarginOrder
     */
    readonly newClientOrderId?: string;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiNewMarginOrder
     */
    readonly newOrderRespType?: NewMarginOrderNewOrderRespTypeEnum;

    /**
     * Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order
     * @type {number}
     * @memberof TradeApiNewMarginOrder
     */
    readonly icebergQty?: number;

    /**
     * NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY; default NO_SIDE_EFFECT.
     * @type {'NO_SIDE_EFFECT' | 'MARGIN_BUY' | 'AUTO_REPAY'}
     * @memberof TradeApiNewMarginOrder
     */
    readonly sideEffectType?: NewMarginOrderSideEffectTypeEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX'}
     * @memberof TradeApiNewMarginOrder
     */
    readonly timeInForce?: NewMarginOrderTimeInForceEnum;

    /**
     * `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_BOTH' | 'EXPIRE_MAKER'}
     * @memberof TradeApiNewMarginOrder
     */
    readonly selfTradePreventionMode?: NewMarginOrderSelfTradePreventionModeEnum;

    /**
     * truetrue
     * @type {boolean}
     * @memberof TradeApiNewMarginOrder
     */
    readonly autoRepayAtCancel?: boolean;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiNewMarginOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for newUmConditionalOrder operation in TradeApi.
 * @interface NewUmConditionalOrderRequest
 */
export interface NewUmConditionalOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly side: NewUmConditionalOrderSideEnum;

    /**
     * "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
     * @type {'STOP' | 'STOP_MARKET' | 'TAKE_PROFIT' | 'TAKE_PROFIT_MARKET' | 'TRAILING_STOP_MARKET'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly strategyType: NewUmConditionalOrderStrategyTypeEnum;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly positionSide?: NewUmConditionalOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly timeInForce?: NewUmConditionalOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode .
     * @type {string}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly price?: number;

    /**
     * stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
     * @type {'MARK_PRICE'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly workingType?: NewUmConditionalOrderWorkingTypeEnum;

    /**
     * "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
     * @type {string}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly priceProtect?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly newClientStrategyId?: string;

    /**
     * Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {number}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly stopPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, default as the mark price
     * @type {number}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly activationPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
     * @type {number}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly callbackRate?: number;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly priceMatch?: NewUmConditionalOrderPriceMatchEnum;

    /**
     * `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_BOTH' | 'EXPIRE_MAKER'}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly selfTradePreventionMode?: NewUmConditionalOrderSelfTradePreventionModeEnum;

    /**
     * order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
     * @type {number | bigint}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly goodTillDate?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiNewUmConditionalOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for newUmOrder operation in TradeApi.
 * @interface NewUmOrderRequest
 */
export interface NewUmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewUmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewUmOrder
     */
    readonly side: NewUmOrderSideEnum;

    /**
     * `LIMIT`, `MARKET`
     * @type {'LIMIT' | 'MARKET'}
     * @memberof TradeApiNewUmOrder
     */
    readonly type: NewUmOrderTypeEnum;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiNewUmOrder
     */
    readonly positionSide?: NewUmOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX'}
     * @memberof TradeApiNewUmOrder
     */
    readonly timeInForce?: NewUmOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewUmOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode .
     * @type {string}
     * @memberof TradeApiNewUmOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewUmOrder
     */
    readonly price?: number;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiNewUmOrder
     */
    readonly newClientOrderId?: string;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiNewUmOrder
     */
    readonly newOrderRespType?: NewUmOrderNewOrderRespTypeEnum;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiNewUmOrder
     */
    readonly priceMatch?: NewUmOrderPriceMatchEnum;

    /**
     * `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_BOTH' | 'EXPIRE_MAKER'}
     * @memberof TradeApiNewUmOrder
     */
    readonly selfTradePreventionMode?: NewUmOrderSelfTradePreventionModeEnum;

    /**
     * order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
     * @type {number | bigint}
     * @memberof TradeApiNewUmOrder
     */
    readonly goodTillDate?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiNewUmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllCmConditionalOrders operation in TradeApi.
 * @interface QueryAllCmConditionalOrdersRequest
 */
export interface QueryAllCmConditionalOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCmConditionalOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmConditionalOrders
     */
    readonly strategyId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmConditionalOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmConditionalOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmConditionalOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmConditionalOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllCmOrders operation in TradeApi.
 * @interface QueryAllCmOrdersRequest
 */
export interface QueryAllCmOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly pair?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly orderId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCmOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllCurrentCmOpenConditionalOrders operation in TradeApi.
 * @interface QueryAllCurrentCmOpenConditionalOrdersRequest
 */
export interface QueryAllCurrentCmOpenConditionalOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCurrentCmOpenConditionalOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCurrentCmOpenConditionalOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllCurrentCmOpenOrders operation in TradeApi.
 * @interface QueryAllCurrentCmOpenOrdersRequest
 */
export interface QueryAllCurrentCmOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCurrentCmOpenOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCurrentCmOpenOrders
     */
    readonly pair?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCurrentCmOpenOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllCurrentUmOpenConditionalOrders operation in TradeApi.
 * @interface QueryAllCurrentUmOpenConditionalOrdersRequest
 */
export interface QueryAllCurrentUmOpenConditionalOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCurrentUmOpenConditionalOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCurrentUmOpenConditionalOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllCurrentUmOpenOrders operation in TradeApi.
 * @interface QueryAllCurrentUmOpenOrdersRequest
 */
export interface QueryAllCurrentUmOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllCurrentUmOpenOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllCurrentUmOpenOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllMarginAccountOrders operation in TradeApi.
 * @interface QueryAllMarginAccountOrdersRequest
 */
export interface QueryAllMarginAccountOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllMarginAccountOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllMarginAccountOrders
     */
    readonly orderId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllMarginAccountOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllMarginAccountOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryAllMarginAccountOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllMarginAccountOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllUmConditionalOrders operation in TradeApi.
 * @interface QueryAllUmConditionalOrdersRequest
 */
export interface QueryAllUmConditionalOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllUmConditionalOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmConditionalOrders
     */
    readonly strategyId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmConditionalOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmConditionalOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmConditionalOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmConditionalOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryAllUmOrders operation in TradeApi.
 * @interface QueryAllUmOrdersRequest
 */
export interface QueryAllUmOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryAllUmOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmOrders
     */
    readonly orderId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryAllUmOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCmConditionalOrderHistory operation in TradeApi.
 * @interface QueryCmConditionalOrderHistoryRequest
 */
export interface QueryCmConditionalOrderHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCmConditionalOrderHistory
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCmConditionalOrderHistory
     */
    readonly strategyId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCmConditionalOrderHistory
     */
    readonly newClientStrategyId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCmConditionalOrderHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCmModifyOrderHistory operation in TradeApi.
 * @interface QueryCmModifyOrderHistoryRequest
 */
export interface QueryCmModifyOrderHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly origClientOrderId?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCmModifyOrderHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCmOrder operation in TradeApi.
 * @interface QueryCmOrderRequest
 */
export interface QueryCmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCmOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCmOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCurrentCmOpenConditionalOrder operation in TradeApi.
 * @interface QueryCurrentCmOpenConditionalOrderRequest
 */
export interface QueryCurrentCmOpenConditionalOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentCmOpenConditionalOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentCmOpenConditionalOrder
     */
    readonly strategyId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentCmOpenConditionalOrder
     */
    readonly newClientStrategyId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentCmOpenConditionalOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCurrentCmOpenOrder operation in TradeApi.
 * @interface QueryCurrentCmOpenOrderRequest
 */
export interface QueryCurrentCmOpenOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentCmOpenOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentCmOpenOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentCmOpenOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentCmOpenOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCurrentMarginOpenOrder operation in TradeApi.
 * @interface QueryCurrentMarginOpenOrderRequest
 */
export interface QueryCurrentMarginOpenOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentMarginOpenOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentMarginOpenOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCurrentUmOpenConditionalOrder operation in TradeApi.
 * @interface QueryCurrentUmOpenConditionalOrderRequest
 */
export interface QueryCurrentUmOpenConditionalOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentUmOpenConditionalOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentUmOpenConditionalOrder
     */
    readonly strategyId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentUmOpenConditionalOrder
     */
    readonly newClientStrategyId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentUmOpenConditionalOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryCurrentUmOpenOrder operation in TradeApi.
 * @interface QueryCurrentUmOpenOrderRequest
 */
export interface QueryCurrentUmOpenOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentUmOpenOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentUmOpenOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentUmOpenOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryCurrentUmOpenOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginAccountOrder operation in TradeApi.
 * @interface QueryMarginAccountOrderRequest
 */
export interface QueryMarginAccountOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginAccountsAllOco operation in TradeApi.
 * @interface QueryMarginAccountsAllOcoRequest
 */
export interface QueryMarginAccountsAllOcoRequest {
    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly fromId?: number | bigint;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginAccountsOco operation in TradeApi.
 * @interface QueryMarginAccountsOcoRequest
 */
export interface QueryMarginAccountsOcoRequest {
    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly orderListId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryMarginAccountsOpenOco operation in TradeApi.
 * @interface QueryMarginAccountsOpenOcoRequest
 */
export interface QueryMarginAccountsOpenOcoRequest {
    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryMarginAccountsOpenOco
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUmConditionalOrderHistory operation in TradeApi.
 * @interface QueryUmConditionalOrderHistoryRequest
 */
export interface QueryUmConditionalOrderHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUmConditionalOrderHistory
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUmConditionalOrderHistory
     */
    readonly strategyId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUmConditionalOrderHistory
     */
    readonly newClientStrategyId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUmConditionalOrderHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUmModifyOrderHistory operation in TradeApi.
 * @interface QueryUmModifyOrderHistoryRequest
 */
export interface QueryUmModifyOrderHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly origClientOrderId?: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUmModifyOrderHistory
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUmOrder operation in TradeApi.
 * @interface QueryUmOrderRequest
 */
export interface QueryUmOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUmOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUmOrder
     */
    readonly orderId?: number | bigint;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUmOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUmOrder
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUsersCmForceOrders operation in TradeApi.
 * @interface QueryUsersCmForceOrdersRequest
 */
export interface QueryUsersCmForceOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUsersCmForceOrders
     */
    readonly symbol?: string;

    /**
     * `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
     * @type {'LIQUIDATION' | 'ADL'}
     * @memberof TradeApiQueryUsersCmForceOrders
     */
    readonly autoCloseType?: QueryUsersCmForceOrdersAutoCloseTypeEnum;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersCmForceOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersCmForceOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersCmForceOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersCmForceOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUsersMarginForceOrders operation in TradeApi.
 * @interface QueryUsersMarginForceOrdersRequest
 */
export interface QueryUsersMarginForceOrdersRequest {
    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersMarginForceOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersMarginForceOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersMarginForceOrders
     */
    readonly current?: number | bigint;

    /**
     * Default:10 Max:100
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersMarginForceOrders
     */
    readonly size?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersMarginForceOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for queryUsersUmForceOrders operation in TradeApi.
 * @interface QueryUsersUmForceOrdersRequest
 */
export interface QueryUsersUmForceOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryUsersUmForceOrders
     */
    readonly symbol?: string;

    /**
     * `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
     * @type {'LIQUIDATION' | 'ADL'}
     * @memberof TradeApiQueryUsersUmForceOrders
     */
    readonly autoCloseType?: QueryUsersUmForceOrdersAutoCloseTypeEnum;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersUmForceOrders
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersUmForceOrders
     */
    readonly endTime?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersUmForceOrders
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiQueryUsersUmForceOrders
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for toggleBnbBurnOnUmFuturesTrade operation in TradeApi.
 * @interface ToggleBnbBurnOnUmFuturesTradeRequest
 */
export interface ToggleBnbBurnOnUmFuturesTradeRequest {
    /**
     * "true": Fee Discount On; "false": Fee Discount Off
     * @type {string}
     * @memberof TradeApiToggleBnbBurnOnUmFuturesTrade
     */
    readonly feeBurn: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiToggleBnbBurnOnUmFuturesTrade
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for umAccountTradeList operation in TradeApi.
 * @interface UmAccountTradeListRequest
 */
export interface UmAccountTradeListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiUmAccountTradeList
     */
    readonly symbol: string;

    /**
     * Timestamp in ms to get funding from INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiUmAccountTradeList
     */
    readonly startTime?: number | bigint;

    /**
     * Timestamp in ms to get funding until INCLUSIVE.
     * @type {number | bigint}
     * @memberof TradeApiUmAccountTradeList
     */
    readonly endTime?: number | bigint;

    /**
     * Trade id to fetch from. Default gets most recent trades.
     * @type {number | bigint}
     * @memberof TradeApiUmAccountTradeList
     */
    readonly fromId?: number | bigint;

    /**
     * Default 100; max 1000
     * @type {number | bigint}
     * @memberof TradeApiUmAccountTradeList
     */
    readonly limit?: number | bigint;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiUmAccountTradeList
     */
    readonly recvWindow?: number | bigint;
}

/**
 * Request parameters for umPositionAdlQuantileEstimation operation in TradeApi.
 * @interface UmPositionAdlQuantileEstimationRequest
 */
export interface UmPositionAdlQuantileEstimationRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiUmPositionAdlQuantileEstimation
     */
    readonly symbol?: string;

    /**
     *
     * @type {number | bigint}
     * @memberof TradeApiUmPositionAdlQuantileEstimation
     */
    readonly recvWindow?: number | bigint;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * Cancel All CM Open Conditional Orders
     *
     * Weight: 1
     *
     * @summary Cancel All CM Open Conditional Orders(TRADE)
     * @param {CancelAllCmOpenConditionalOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllCmOpenConditionalOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-CM-Open-Conditional-Orders Binance API Documentation}
     */
    public async cancelAllCmOpenConditionalOrders(
        requestParameters: CancelAllCmOpenConditionalOrdersRequest
    ): Promise<RestApiResponse<CancelAllCmOpenConditionalOrdersResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cancelAllCmOpenConditionalOrders(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<CancelAllCmOpenConditionalOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel all active LIMIT orders on specific symbol
     *
     * Weight: 1
     *
     * @summary Cancel All CM Open Orders(TRADE)
     * @param {CancelAllCmOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllCmOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-CM-Open-Orders Binance API Documentation}
     */
    public async cancelAllCmOpenOrders(
        requestParameters: CancelAllCmOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllCmOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelAllCmOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelAllCmOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel All UM Open Conditional Orders
     *
     * Weight: 1
     *
     * @summary Cancel All UM Open Conditional Orders (TRADE)
     * @param {CancelAllUmOpenConditionalOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllUmOpenConditionalOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-UM-Open-Conditional-Orders Binance API Documentation}
     */
    public async cancelAllUmOpenConditionalOrders(
        requestParameters: CancelAllUmOpenConditionalOrdersRequest
    ): Promise<RestApiResponse<CancelAllUmOpenConditionalOrdersResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cancelAllUmOpenConditionalOrders(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<CancelAllUmOpenConditionalOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel all active LIMIT orders on specific symbol
     *
     * Weight: 1
     *
     * @summary Cancel All UM Open Orders(TRADE)
     * @param {CancelAllUmOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllUmOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-UM-Open-Orders Binance API Documentation}
     */
    public async cancelAllUmOpenOrders(
        requestParameters: CancelAllUmOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllUmOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelAllUmOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelAllUmOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel CM Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel CM Conditional Order(TRADE)
     * @param {CancelCmConditionalOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelCmConditionalOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-CM-Conditional-Order Binance API Documentation}
     */
    public async cancelCmConditionalOrder(
        requestParameters: CancelCmConditionalOrderRequest
    ): Promise<RestApiResponse<CancelCmConditionalOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelCmConditionalOrder(
            requestParameters?.symbol,
            requestParameters?.strategyId,
            requestParameters?.newClientStrategyId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelCmConditionalOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active LIMIT order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel CM Order(TRADE)
     * @param {CancelCmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelCmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-CM-Order Binance API Documentation}
     */
    public async cancelCmOrder(
        requestParameters: CancelCmOrderRequest
    ): Promise<RestApiResponse<CancelCmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelCmOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelCmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel Margin Account All Open Orders on a Symbol
     *
     * Weight: 5
     *
     * @summary Cancel Margin Account All Open Orders on a Symbol(TRADE)
     * @param {CancelMarginAccountAllOpenOrdersOnASymbolRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-All-Open-Orders-on-a-Symbol Binance API Documentation}
     */
    public async cancelMarginAccountAllOpenOrdersOnASymbol(
        requestParameters: CancelMarginAccountAllOpenOrdersOnASymbolRequest
    ): Promise<RestApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cancelMarginAccountAllOpenOrdersOnASymbol(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<CancelMarginAccountAllOpenOrdersOnASymbolResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel Margin Account OCO Orders
     *
     * Additional notes: Canceling an individual leg will cancel the entire OCO
     *
     * Weight: 2
     *
     * @summary Cancel Margin Account OCO Orders(TRADE)
     * @param {CancelMarginAccountOcoOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelMarginAccountOcoOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-OCO-Orders Binance API Documentation}
     */
    public async cancelMarginAccountOcoOrders(
        requestParameters: CancelMarginAccountOcoOrdersRequest
    ): Promise<RestApiResponse<CancelMarginAccountOcoOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelMarginAccountOcoOrders(
            requestParameters?.symbol,
            requestParameters?.orderListId,
            requestParameters?.listClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelMarginAccountOcoOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel Margin Account Order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 2
     *
     * @summary Cancel Margin Account Order(TRADE)
     * @param {CancelMarginAccountOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelMarginAccountOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-Order Binance API Documentation}
     */
    public async cancelMarginAccountOrder(
        requestParameters: CancelMarginAccountOrderRequest
    ): Promise<RestApiResponse<CancelMarginAccountOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelMarginAccountOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelMarginAccountOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel UM Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel UM Conditional Order(TRADE)
     * @param {CancelUmConditionalOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelUmConditionalOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-UM-Conditional-Order Binance API Documentation}
     */
    public async cancelUmConditionalOrder(
        requestParameters: CancelUmConditionalOrderRequest
    ): Promise<RestApiResponse<CancelUmConditionalOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelUmConditionalOrder(
            requestParameters?.symbol,
            requestParameters?.strategyId,
            requestParameters?.newClientStrategyId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelUmConditionalOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active UM LIMIT order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel UM Order(TRADE)
     * @param {CancelUmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelUmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-UM-Order Binance API Documentation}
     */
    public async cancelUmOrder(
        requestParameters: CancelUmOrderRequest
    ): Promise<RestApiResponse<CancelUmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelUmOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelUmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get trades for a specific account and CM symbol.
     *
     * Either `symbol` or `pair` must be sent
     * `symbol` and `pair` cannot be sent together
     * `pair` and `fromId` cannot be sent together
     * `OrderId` can only be sent together with symbol
     * If a `pair` is sent, tickers for all symbols of the `pair` will be returned
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`
     * If `startTime` and `endTime` are both not sent, then the last '24 hours' data will be returned.
     * The time between `startTime` and `endTime` cannot be longer than 24 hours.
     *
     * Weight: 20 with symbol, 40 with pair
     *
     * @summary CM Account Trade List(USER_DATA)
     * @param {CmAccountTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CmAccountTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/CM-Account-Trade-List Binance API Documentation}
     */
    public async cmAccountTradeList(
        requestParameters: CmAccountTradeListRequest = {}
    ): Promise<RestApiResponse<CmAccountTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cmAccountTradeList(
            requestParameters?.symbol,
            requestParameters?.pair,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<CmAccountTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query CM Position ADL Quantile Estimation
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary CM Position ADL Quantile Estimation(USER_DATA)
     * @param {CmPositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CmPositionAdlQuantileEstimationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/CM-Position-ADL-Quantile-Estimation Binance API Documentation}
     */
    public async cmPositionAdlQuantileEstimation(
        requestParameters: CmPositionAdlQuantileEstimationRequest = {}
    ): Promise<RestApiResponse<CmPositionAdlQuantileEstimationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cmPositionAdlQuantileEstimation(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<CmPositionAdlQuantileEstimationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     *
     * Weight: 30
     *
     * @summary Get UM Futures BNB Burn Status (USER_DATA)
     * @param {GetUmFuturesBnbBurnStatusRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetUmFuturesBnbBurnStatusResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Get-UM-Futures-BNB-Burn-Status Binance API Documentation}
     */
    public async getUmFuturesBnbBurnStatus(
        requestParameters: GetUmFuturesBnbBurnStatusRequest = {}
    ): Promise<RestApiResponse<GetUmFuturesBnbBurnStatusResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUmFuturesBnbBurnStatus(
            requestParameters?.recvWindow
        );
        return sendRequest<GetUmFuturesBnbBurnStatusResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Apply for a margin loan.
     *
     * Weight: 100
     *
     * @summary Margin Account Borrow(MARGIN)
     * @param {MarginAccountBorrowRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountBorrowResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Borrow Binance API Documentation}
     */
    public async marginAccountBorrow(
        requestParameters: MarginAccountBorrowRequest
    ): Promise<RestApiResponse<MarginAccountBorrowResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountBorrow(
            requestParameters?.asset,
            requestParameters?.amount,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountBorrowResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new OCO for a margin account
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity
     * `ICEBERG` quantities however do not have to be the same.
     * Order Rate Limit
     * `OCO` counts as 2 orders against the order rate limit.
     *
     * Weight: 1
     *
     * @summary Margin Account New OCO(TRADE)
     * @param {MarginAccountNewOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountNewOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-New-OCO Binance API Documentation}
     */
    public async marginAccountNewOco(
        requestParameters: MarginAccountNewOcoRequest
    ): Promise<RestApiResponse<MarginAccountNewOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountNewOco(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.stopPrice,
            requestParameters?.listClientOrderId,
            requestParameters?.limitClientOrderId,
            requestParameters?.limitIcebergQty,
            requestParameters?.stopClientOrderId,
            requestParameters?.stopLimitPrice,
            requestParameters?.stopIcebergQty,
            requestParameters?.stopLimitTimeInForce,
            requestParameters?.newOrderRespType,
            requestParameters?.sideEffectType,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountNewOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Repay for a margin loan.
     *
     * Weight: 100
     *
     * @summary Margin Account Repay(MARGIN)
     * @param {MarginAccountRepayRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountRepayResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Repay Binance API Documentation}
     */
    public async marginAccountRepay(
        requestParameters: MarginAccountRepayRequest
    ): Promise<RestApiResponse<MarginAccountRepayResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountRepay(
            requestParameters?.asset,
            requestParameters?.amount,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountRepayResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Repay debt for a margin loan.
     *
     * The repay asset amount cannot exceed 50000 USD equivalent value for a single request.
     * If `amount` is not sent, all the asset loan will be repaid if having enough specific repay assets.
     * If `amount` is sent, only the certain amount of the asset loan will be repaid if having enough specific repay assets.
     * The system will use the same asset to repay the loan first (if have) no matter whether put the asset in `specifyRepayAssets`
     *
     * Weight: 3000
     *
     * @summary Margin Account Repay Debt(TRADE)
     * @param {MarginAccountRepayDebtRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountRepayDebtResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Repay-Debt Binance API Documentation}
     */
    public async marginAccountRepayDebt(
        requestParameters: MarginAccountRepayDebtRequest
    ): Promise<RestApiResponse<MarginAccountRepayDebtResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountRepayDebt(
            requestParameters?.asset,
            requestParameters?.amount,
            requestParameters?.specifyRepayAssets,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountRepayDebtResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Margin Account Trade List
     *
     * Weight: 5
     *
     * @summary Margin Account Trade List (USER_DATA)
     * @param {MarginAccountTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Trade-List Binance API Documentation}
     */
    public async marginAccountTradeList(
        requestParameters: MarginAccountTradeListRequest
    ): Promise<RestApiResponse<MarginAccountTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountTradeList(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Both `quantity` and `price` must be sent
     * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new `quantity` <= `executedQty`
     * When the order is `GTX` and the new price will cause it to be executed immediately
     *
     * Weight: 1
     *
     * @summary Modify CM Order(TRADE)
     * @param {ModifyCmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyCmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Modify-CM-Order Binance API Documentation}
     */
    public async modifyCmOrder(
        requestParameters: ModifyCmOrderRequest
    ): Promise<RestApiResponse<ModifyCmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyCmOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.priceMatch,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyCmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     * Either orderId or origClientOrderId must be sent, and the orderId will prevail if both are sent.
     * Both quantity and price must be sent
     * When the new quantity or price doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new quantity <= executedQty
     * When the order is GTX and the new price will cause it to be executed immediately
     *
     * Weight: 1
     *
     * @summary Modify UM Order(TRADE)
     * @param {ModifyUmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyUmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Modify-UM-Order Binance API Documentation}
     */
    public async modifyUmOrder(
        requestParameters: ModifyUmOrderRequest
    ): Promise<RestApiResponse<ModifyUmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyUmOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.priceMatch,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyUmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * New CM Conditional Order
     *
     * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     * `STOP`, `STOP_MARKET`:
     * BUY: "MARK_PRICE"  >= `stopPrice`
     * SELL: "MARK_PRICE" <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: "MARK_PRICE" <= `stopPrice`
     * SELL: "MARK_PRICE" >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
     * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
     * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest mark price.
     * SELL: `activationPrice` should be larger than latest mark price.
     * Condition orders will be triggered when:
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     *
     * Weight: 1
     *
     * @summary New CM Conditional Order(TRADE)
     * @param {NewCmConditionalOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewCmConditionalOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-CM-Conditional-Order Binance API Documentation}
     */
    public async newCmConditionalOrder(
        requestParameters: NewCmConditionalOrderRequest
    ): Promise<RestApiResponse<NewCmConditionalOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newCmConditionalOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.strategyType,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.workingType,
            requestParameters?.priceProtect,
            requestParameters?.newClientStrategyId,
            requestParameters?.stopPrice,
            requestParameters?.activationPrice,
            requestParameters?.callbackRate,
            requestParameters?.recvWindow
        );
        return sendRequest<NewCmConditionalOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place new CM order
     *
     * If `newOrderRespType` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * Weight: 1
     *
     * @summary New CM Order(TRADE)
     * @param {NewCmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewCmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-CM-Order Binance API Documentation}
     */
    public async newCmOrder(
        requestParameters: NewCmOrderRequest
    ): Promise<RestApiResponse<NewCmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newCmOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.priceMatch,
            requestParameters?.newClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.recvWindow
        );
        return sendRequest<NewCmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * New Margin Order
     *
     * Weight: 1
     *
     * @summary New Margin Order(TRADE)
     * @param {NewMarginOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewMarginOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-Margin-Order Binance API Documentation}
     */
    public async newMarginOrder(
        requestParameters: NewMarginOrderRequest
    ): Promise<RestApiResponse<NewMarginOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newMarginOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.quantity,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.stopPrice,
            requestParameters?.newClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.icebergQty,
            requestParameters?.sideEffectType,
            requestParameters?.timeInForce,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.autoRepayAtCancel,
            requestParameters?.recvWindow
        );
        return sendRequest<NewMarginOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place new UM conditional order
     *
     * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     * `STOP`, `STOP_MARKET`:
     * BUY: "MARK_PRICE"  >= `stopPrice`
     * SELL: "MARK_PRICE" <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: "MARK_PRICE" <= `stopPrice`
     * SELL: "MARK_PRICE" >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
     * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
     * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest mark price.
     * SELL: `activationPrice` should be larger than latest mark price.
     * Condition orders will be triggered when:
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 1
     *
     * @summary New UM Conditional Order (TRADE)
     * @param {NewUmConditionalOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewUmConditionalOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-UM-Conditional-Order Binance API Documentation}
     */
    public async newUmConditionalOrder(
        requestParameters: NewUmConditionalOrderRequest
    ): Promise<RestApiResponse<NewUmConditionalOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newUmConditionalOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.strategyType,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.workingType,
            requestParameters?.priceProtect,
            requestParameters?.newClientStrategyId,
            requestParameters?.stopPrice,
            requestParameters?.activationPrice,
            requestParameters?.callbackRate,
            requestParameters?.priceMatch,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.goodTillDate,
            requestParameters?.recvWindow
        );
        return sendRequest<NewUmConditionalOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place new UM order
     *
     * If `newOrderRespType` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 1
     *
     * @summary New UM Order (TRADE)
     * @param {NewUmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewUmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-UM-Order Binance API Documentation}
     */
    public async newUmOrder(
        requestParameters: NewUmOrderRequest
    ): Promise<RestApiResponse<NewUmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newUmOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.priceMatch,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.goodTillDate,
            requestParameters?.recvWindow
        );
        return sendRequest<NewUmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query All CM Conditional Orders
     *
     * These orders will not be found:
     * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     * The query time period must be less than 7 days( default as the recent 7 days).
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All CM Conditional Orders(USER_DATA)
     * @param {QueryAllCmConditionalOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllCmConditionalOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders Binance API Documentation}
     */
    public async queryAllCmConditionalOrders(
        requestParameters: QueryAllCmConditionalOrdersRequest = {}
    ): Promise<RestApiResponse<QueryAllCmConditionalOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllCmConditionalOrders(
            requestParameters?.symbol,
            requestParameters?.strategyId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllCmConditionalOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all account CM orders; active, canceled, or filled.
     *
     * Either `symbol` or `pair` must be sent.
     * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * Weight: 20 with symbol, 40 with pair
     *
     * @summary Query All CM Orders (USER_DATA)
     * @param {QueryAllCmOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllCmOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders Binance API Documentation}
     */
    public async queryAllCmOrders(
        requestParameters: QueryAllCmOrdersRequest
    ): Promise<RestApiResponse<QueryAllCmOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllCmOrders(
            requestParameters?.symbol,
            requestParameters?.pair,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllCmOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open conditional orders on a symbol. **Careful** when accessing this with no symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All Current CM Open Conditional Orders (USER_DATA)
     * @param {QueryAllCurrentCmOpenConditionalOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-CM-Open-Conditional-Orders Binance API Documentation}
     */
    public async queryAllCurrentCmOpenConditionalOrders(
        requestParameters: QueryAllCurrentCmOpenConditionalOrdersRequest = {}
    ): Promise<RestApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryAllCurrentCmOpenConditionalOrders(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryAllCurrentCmOpenConditionalOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open orders on a symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary Query All Current CM Open Orders(USER_DATA)
     * @param {QueryAllCurrentCmOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllCurrentCmOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-CM-Open-Orders Binance API Documentation}
     */
    public async queryAllCurrentCmOpenOrders(
        requestParameters: QueryAllCurrentCmOpenOrdersRequest = {}
    ): Promise<RestApiResponse<QueryAllCurrentCmOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllCurrentCmOpenOrders(
            requestParameters?.symbol,
            requestParameters?.pair,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllCurrentCmOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open conditional orders on a symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary Query All Current UM Open Conditional Orders(USER_DATA)
     * @param {QueryAllCurrentUmOpenConditionalOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-UM-Open-Conditional-Orders Binance API Documentation}
     */
    public async queryAllCurrentUmOpenConditionalOrders(
        requestParameters: QueryAllCurrentUmOpenConditionalOrdersRequest = {}
    ): Promise<RestApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryAllCurrentUmOpenConditionalOrders(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryAllCurrentUmOpenConditionalOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open orders on a symbol.
     *
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All Current UM Open Orders(USER_DATA)
     * @param {QueryAllCurrentUmOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllCurrentUmOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-UM-Open-Orders Binance API Documentation}
     */
    public async queryAllCurrentUmOpenOrders(
        requestParameters: QueryAllCurrentUmOpenOrdersRequest = {}
    ): Promise<RestApiResponse<QueryAllCurrentUmOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllCurrentUmOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllCurrentUmOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query All Margin Account Orders
     *
     * Weight: 100
     *
     * @summary Query All Margin Account Orders (USER_DATA)
     * @param {QueryAllMarginAccountOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllMarginAccountOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Margin-Account-Orders Binance API Documentation}
     */
    public async queryAllMarginAccountOrders(
        requestParameters: QueryAllMarginAccountOrdersRequest
    ): Promise<RestApiResponse<QueryAllMarginAccountOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllMarginAccountOrders(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllMarginAccountOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query All UM Conditional Orders
     *
     * These orders will not be found:
     * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     * The query time period must be less than 7 days( default as the recent 7 days).
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query All UM Conditional Orders(USER_DATA)
     * @param {QueryAllUmConditionalOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllUmConditionalOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders Binance API Documentation}
     */
    public async queryAllUmConditionalOrders(
        requestParameters: QueryAllUmConditionalOrdersRequest = {}
    ): Promise<RestApiResponse<QueryAllUmConditionalOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllUmConditionalOrders(
            requestParameters?.symbol,
            requestParameters?.strategyId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllUmConditionalOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all account UM orders; active, canceled, or filled.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
     * The query time period must be less then 7 days( default as the recent 7 days).
     *
     * Weight: 5
     *
     * @summary Query All UM Orders(USER_DATA)
     * @param {QueryAllUmOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryAllUmOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders Binance API Documentation}
     */
    public async queryAllUmOrders(
        requestParameters: QueryAllUmOrdersRequest
    ): Promise<RestApiResponse<QueryAllUmOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryAllUmOrders(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryAllUmOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query CM Conditional Order History
     *
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * `NEW` orders will not be found.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     *
     * Weight: 1
     *
     * @summary Query CM Conditional Order History(USER_DATA)
     * @param {QueryCmConditionalOrderHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCmConditionalOrderHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-CM-Conditional-Order-History Binance API Documentation}
     */
    public async queryCmConditionalOrderHistory(
        requestParameters: QueryCmConditionalOrderHistoryRequest
    ): Promise<RestApiResponse<QueryCmConditionalOrderHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryCmConditionalOrderHistory(
                requestParameters?.symbol,
                requestParameters?.strategyId,
                requestParameters?.newClientStrategyId,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryCmConditionalOrderHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get order modification history
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     *
     * Weight: 1
     *
     * @summary Query CM Modify Order History(TRADE)
     * @param {QueryCmModifyOrderHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCmModifyOrderHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-CM-Modify-Order-History Binance API Documentation}
     */
    public async queryCmModifyOrderHistory(
        requestParameters: QueryCmModifyOrderHistoryRequest
    ): Promise<RestApiResponse<QueryCmModifyOrderHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCmModifyOrderHistory(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCmModifyOrderHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an CM order's status.
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * Weight: 1
     *
     * @summary Query CM Order(USER_DATA)
     * @param {QueryCmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-CM-Order Binance API Documentation}
     */
    public async queryCmOrder(
        requestParameters: QueryCmOrderRequest
    ): Promise<RestApiResponse<QueryCmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCmOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Current CM Open Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * If the queried order has been triggered, cancelled or expired, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current CM Open Conditional Order(USER_DATA)
     * @param {QueryCurrentCmOpenConditionalOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentCmOpenConditionalOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-CM-Open-Conditional-Order Binance API Documentation}
     */
    public async queryCurrentCmOpenConditionalOrder(
        requestParameters: QueryCurrentCmOpenConditionalOrderRequest
    ): Promise<RestApiResponse<QueryCurrentCmOpenConditionalOrderResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryCurrentCmOpenConditionalOrder(
                requestParameters?.symbol,
                requestParameters?.strategyId,
                requestParameters?.newClientStrategyId,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryCurrentCmOpenConditionalOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query current CM open order
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current CM Open Order (USER_DATA)
     * @param {QueryCurrentCmOpenOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentCmOpenOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-CM-Open-Order Binance API Documentation}
     */
    public async queryCurrentCmOpenOrder(
        requestParameters: QueryCurrentCmOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentCmOpenOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCurrentCmOpenOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCurrentCmOpenOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Current Margin Open Order
     *
     * Weight: 5
     *
     * @summary Query Current Margin Open Order (USER_DATA)
     * @param {QueryCurrentMarginOpenOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentMarginOpenOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-Margin-Open-Order Binance API Documentation}
     */
    public async queryCurrentMarginOpenOrder(
        requestParameters: QueryCurrentMarginOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentMarginOpenOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCurrentMarginOpenOrder(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCurrentMarginOpenOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Current UM Open Conditional Order
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * If the queried order has been `CANCELED`, `TRIGGERED``EXPIRED`, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current UM Open Conditional Order(USER_DATA)
     * @param {QueryCurrentUmOpenConditionalOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentUmOpenConditionalOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-UM-Open-Conditional-Order Binance API Documentation}
     */
    public async queryCurrentUmOpenConditionalOrder(
        requestParameters: QueryCurrentUmOpenConditionalOrderRequest
    ): Promise<RestApiResponse<QueryCurrentUmOpenConditionalOrderResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryCurrentUmOpenConditionalOrder(
                requestParameters?.symbol,
                requestParameters?.strategyId,
                requestParameters?.newClientStrategyId,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryCurrentUmOpenConditionalOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query current UM open order
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current UM Open Order(USER_DATA)
     * @param {QueryCurrentUmOpenOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentUmOpenOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-UM-Open-Order Binance API Documentation}
     */
    public async queryCurrentUmOpenOrder(
        requestParameters: QueryCurrentUmOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentUmOpenOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCurrentUmOpenOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCurrentUmOpenOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account Order
     *
     * Weight: 10
     *
     * @summary Query Margin Account Order (USER_DATA)
     * @param {QueryMarginAccountOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Margin-Account-Order Binance API Documentation}
     */
    public async queryMarginAccountOrder(
        requestParameters: QueryMarginAccountOrderRequest
    ): Promise<RestApiResponse<QueryMarginAccountOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query all OCO for a specific margin account based on provided optional parameters
     *
     * Weight: 100
     *
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {QueryMarginAccountsAllOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsAllOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Margin-Account-all-OCO Binance API Documentation}
     */
    public async queryMarginAccountsAllOco(
        requestParameters: QueryMarginAccountsAllOcoRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsAllOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsAllOco(
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsAllOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves a specific OCO based on provided optional parameters
     *
     * Weight: 5
     *
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {QueryMarginAccountsOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Margin-Account-OCO Binance API Documentation}
     */
    public async queryMarginAccountsOco(
        requestParameters: QueryMarginAccountsOcoRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsOco(
            requestParameters?.orderListId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account's Open OCO
     *
     * Weight: 5
     *
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {QueryMarginAccountsOpenOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsOpenOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Margin-Account-Open-OCO Binance API Documentation}
     */
    public async queryMarginAccountsOpenOco(
        requestParameters: QueryMarginAccountsOpenOcoRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsOpenOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsOpenOco(
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsOpenOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query UM Conditional Order History
     *
     * Either `strategyId` or `newClientStrategyId` must be sent.
     * `NEW` orders will not be found.
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 7 days < current time
     *
     * Weight: 1
     *
     * @summary Query UM Conditional Order History(USER_DATA)
     * @param {QueryUmConditionalOrderHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUmConditionalOrderHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-UM-Conditional-Order-History Binance API Documentation}
     */
    public async queryUmConditionalOrderHistory(
        requestParameters: QueryUmConditionalOrderHistoryRequest
    ): Promise<RestApiResponse<QueryUmConditionalOrderHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryUmConditionalOrderHistory(
                requestParameters?.symbol,
                requestParameters?.strategyId,
                requestParameters?.newClientStrategyId,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryUmConditionalOrderHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get order modification history
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     *
     * Weight: 1
     *
     * @summary Query UM Modify Order History(TRADE)
     * @param {QueryUmModifyOrderHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUmModifyOrderHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-UM-Modify-Order-History Binance API Documentation}
     */
    public async queryUmModifyOrderHistory(
        requestParameters: QueryUmModifyOrderHistoryRequest
    ): Promise<RestApiResponse<QueryUmModifyOrderHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUmModifyOrderHistory(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUmModifyOrderHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an UM order's status.
     *
     * These orders will not be found:
     * Either `orderId` or `origClientOrderId` must be sent.
     * order status is `CANCELED` or `EXPIRED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     * Weight: 1
     *
     * @summary Query UM Order (USER_DATA)
     * @param {QueryUmOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUmOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-UM-Order Binance API Documentation}
     */
    public async queryUmOrder(
        requestParameters: QueryUmOrderRequest
    ): Promise<RestApiResponse<QueryUmOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUmOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUmOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query User's CM Force Orders
     *
     * If "autoCloseType" is not sent, orders with both of the types will be returned
     * If "startTime" is not sent, data within 7 days before "endTime" can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary Query User\'s CM Force Orders(USER_DATA)
     * @param {QueryUsersCmForceOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUsersCmForceOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-CM-Force-Orders Binance API Documentation}
     */
    public async queryUsersCmForceOrders(
        requestParameters: QueryUsersCmForceOrdersRequest = {}
    ): Promise<RestApiResponse<QueryUsersCmForceOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUsersCmForceOrders(
            requestParameters?.symbol,
            requestParameters?.autoCloseType,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUsersCmForceOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query user's margin force orders
     *
     * Weight: 1
     *
     * @summary Query User\'s Margin Force Orders(USER_DATA)
     * @param {QueryUsersMarginForceOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUsersMarginForceOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-Margin-Force-Orders Binance API Documentation}
     */
    public async queryUsersMarginForceOrders(
        requestParameters: QueryUsersMarginForceOrdersRequest = {}
    ): Promise<RestApiResponse<QueryUsersMarginForceOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUsersMarginForceOrders(
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.current,
            requestParameters?.size,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUsersMarginForceOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query User's UM Force Orders
     *
     * If `autoCloseType` is not sent, orders with both of the types will be returned
     * If `startTime` is not sent, data within 7 days before `endTime` can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary Query User\'s UM Force Orders (USER_DATA)
     * @param {QueryUsersUmForceOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryUsersUmForceOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-UM-Force-Orders Binance API Documentation}
     */
    public async queryUsersUmForceOrders(
        requestParameters: QueryUsersUmForceOrdersRequest = {}
    ): Promise<RestApiResponse<QueryUsersUmForceOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryUsersUmForceOrders(
            requestParameters?.symbol,
            requestParameters?.autoCloseType,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryUsersUmForceOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on ***EVERY symbol***
     *
     *
     * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
     *
     * Weight: 1
     *
     * @summary Toggle BNB Burn On UM Futures Trade (TRADE)
     * @param {ToggleBnbBurnOnUmFuturesTradeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Toggle-BNB-Burn-On-UM-Futures-Trade Binance API Documentation}
     */
    public async toggleBnbBurnOnUmFuturesTrade(
        requestParameters: ToggleBnbBurnOnUmFuturesTradeRequest
    ): Promise<RestApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.toggleBnbBurnOnUmFuturesTrade(
                requestParameters?.feeBurn,
                requestParameters?.recvWindow
            );
        return sendRequest<ToggleBnbBurnOnUmFuturesTradeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get trades for a specific account and UM symbol.
     *
     *
     * If `startTime` and `endTime` are both not sent, then the last '7 days' data will be returned.
     * The time between `startTime` and `endTime` cannot be longer than 7 days.
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`.
     *
     * Weight: 5
     *
     * @summary UM Account Trade List(USER_DATA)
     * @param {UmAccountTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UmAccountTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/UM-Account-Trade-List Binance API Documentation}
     */
    public async umAccountTradeList(
        requestParameters: UmAccountTradeListRequest
    ): Promise<RestApiResponse<UmAccountTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.umAccountTradeList(
            requestParameters?.symbol,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<UmAccountTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query UM Position ADL Quantile Estimation
     *
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary UM Position ADL Quantile Estimation(USER_DATA)
     * @param {UmPositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UmPositionAdlQuantileEstimationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/portfolio-margin/trade/UM-Position-ADL-Quantile-Estimation Binance API Documentation}
     */
    public async umPositionAdlQuantileEstimation(
        requestParameters: UmPositionAdlQuantileEstimationRequest = {}
    ): Promise<RestApiResponse<UmPositionAdlQuantileEstimationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.umPositionAdlQuantileEstimation(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<UmPositionAdlQuantileEstimationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.queryParams,
            localVarAxiosArgs.bodyParams,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export enum MarginAccountNewOcoSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum MarginAccountNewOcoStopLimitTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
}

export enum MarginAccountNewOcoNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
}

export enum MarginAccountNewOcoSideEffectTypeEnum {
    NO_SIDE_EFFECT = 'NO_SIDE_EFFECT',
    MARGIN_BUY = 'MARGIN_BUY',
    AUTO_REPAY = 'AUTO_REPAY',
}

export enum ModifyCmOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum ModifyCmOrderPriceMatchEnum {
    NONE = 'NONE',
    OPPONENT = 'OPPONENT',
    OPPONENT_5 = 'OPPONENT_5',
    OPPONENT_10 = 'OPPONENT_10',
    OPPONENT_20 = 'OPPONENT_20',
    QUEUE = 'QUEUE',
    QUEUE_5 = 'QUEUE_5',
    QUEUE_10 = 'QUEUE_10',
    QUEUE_20 = 'QUEUE_20',
}

export enum ModifyUmOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum ModifyUmOrderPriceMatchEnum {
    NONE = 'NONE',
    OPPONENT = 'OPPONENT',
    OPPONENT_5 = 'OPPONENT_5',
    OPPONENT_10 = 'OPPONENT_10',
    OPPONENT_20 = 'OPPONENT_20',
    QUEUE = 'QUEUE',
    QUEUE_5 = 'QUEUE_5',
    QUEUE_10 = 'QUEUE_10',
    QUEUE_20 = 'QUEUE_20',
}

export enum NewCmConditionalOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum NewCmConditionalOrderStrategyTypeEnum {
    STOP = 'STOP',
    STOP_MARKET = 'STOP_MARKET',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_MARKET = 'TAKE_PROFIT_MARKET',
    TRAILING_STOP_MARKET = 'TRAILING_STOP_MARKET',
}

export enum NewCmConditionalOrderPositionSideEnum {
    BOTH = 'BOTH',
    LONG = 'LONG',
    SHORT = 'SHORT',
}

export enum NewCmConditionalOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    GTX = 'GTX',
}

export enum NewCmConditionalOrderWorkingTypeEnum {
    MARK_PRICE = 'MARK_PRICE',
}

export enum NewCmOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum NewCmOrderTypeEnum {
    LIMIT = 'LIMIT',
    MARKET = 'MARKET',
}

export enum NewCmOrderPositionSideEnum {
    BOTH = 'BOTH',
    LONG = 'LONG',
    SHORT = 'SHORT',
}

export enum NewCmOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    GTX = 'GTX',
}

export enum NewCmOrderPriceMatchEnum {
    NONE = 'NONE',
    OPPONENT = 'OPPONENT',
    OPPONENT_5 = 'OPPONENT_5',
    OPPONENT_10 = 'OPPONENT_10',
    OPPONENT_20 = 'OPPONENT_20',
    QUEUE = 'QUEUE',
    QUEUE_5 = 'QUEUE_5',
    QUEUE_10 = 'QUEUE_10',
    QUEUE_20 = 'QUEUE_20',
}

export enum NewCmOrderNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
}

export enum NewMarginOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum NewMarginOrderTypeEnum {
    LIMIT = 'LIMIT',
    MARKET = 'MARKET',
}

export enum NewMarginOrderNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
}

export enum NewMarginOrderSideEffectTypeEnum {
    NO_SIDE_EFFECT = 'NO_SIDE_EFFECT',
    MARGIN_BUY = 'MARGIN_BUY',
    AUTO_REPAY = 'AUTO_REPAY',
}

export enum NewMarginOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    GTX = 'GTX',
}

export enum NewMarginOrderSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
}

export enum NewUmConditionalOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum NewUmConditionalOrderStrategyTypeEnum {
    STOP = 'STOP',
    STOP_MARKET = 'STOP_MARKET',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_MARKET = 'TAKE_PROFIT_MARKET',
    TRAILING_STOP_MARKET = 'TRAILING_STOP_MARKET',
}

export enum NewUmConditionalOrderPositionSideEnum {
    BOTH = 'BOTH',
    LONG = 'LONG',
    SHORT = 'SHORT',
}

export enum NewUmConditionalOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    GTX = 'GTX',
}

export enum NewUmConditionalOrderWorkingTypeEnum {
    MARK_PRICE = 'MARK_PRICE',
}

export enum NewUmConditionalOrderPriceMatchEnum {
    NONE = 'NONE',
    OPPONENT = 'OPPONENT',
    OPPONENT_5 = 'OPPONENT_5',
    OPPONENT_10 = 'OPPONENT_10',
    OPPONENT_20 = 'OPPONENT_20',
    QUEUE = 'QUEUE',
    QUEUE_5 = 'QUEUE_5',
    QUEUE_10 = 'QUEUE_10',
    QUEUE_20 = 'QUEUE_20',
}

export enum NewUmConditionalOrderSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
}

export enum NewUmOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum NewUmOrderTypeEnum {
    LIMIT = 'LIMIT',
    MARKET = 'MARKET',
}

export enum NewUmOrderPositionSideEnum {
    BOTH = 'BOTH',
    LONG = 'LONG',
    SHORT = 'SHORT',
}

export enum NewUmOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    GTX = 'GTX',
}

export enum NewUmOrderNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
}

export enum NewUmOrderPriceMatchEnum {
    NONE = 'NONE',
    OPPONENT = 'OPPONENT',
    OPPONENT_5 = 'OPPONENT_5',
    OPPONENT_10 = 'OPPONENT_10',
    OPPONENT_20 = 'OPPONENT_20',
    QUEUE = 'QUEUE',
    QUEUE_5 = 'QUEUE_5',
    QUEUE_10 = 'QUEUE_10',
    QUEUE_20 = 'QUEUE_20',
}

export enum NewUmOrderSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
}

export enum QueryUsersCmForceOrdersAutoCloseTypeEnum {
    LIQUIDATION = 'LIQUIDATION',
    ADL = 'ADL',
}

export enum QueryUsersUmForceOrdersAutoCloseTypeEnum {
    LIQUIDATION = 'LIQUIDATION',
    ADL = 'ADL',
}
