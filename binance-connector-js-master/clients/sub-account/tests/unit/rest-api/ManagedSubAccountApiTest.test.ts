/**
 * Binance Sub Account REST API
 *
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { ManagedSubAccountApi } from '../../../src/rest-api';
import {
    DepositAssetsIntoTheManagedSubAccountRequest,
    GetManagedSubAccountDepositAddressRequest,
    QueryManagedSubAccountAssetDetailsRequest,
    QueryManagedSubAccountFuturesAssetDetailsRequest,
    QueryManagedSubAccountListRequest,
    QueryManagedSubAccountMarginAssetDetailsRequest,
    QueryManagedSubAccountSnapshotRequest,
    QueryManagedSubAccountTransferLogMasterAccountInvestorRequest,
    QueryManagedSubAccountTransferLogMasterAccountTradingRequest,
    QueryManagedSubAccountTransferLogSubAccountTradingRequest,
    WithdrawlAssetsFromTheManagedSubAccountRequest,
} from '../../../src/rest-api';
import type {
    DepositAssetsIntoTheManagedSubAccountResponse,
    GetManagedSubAccountDepositAddressResponse,
    QueryManagedSubAccountAssetDetailsResponse,
    QueryManagedSubAccountFuturesAssetDetailsResponse,
    QueryManagedSubAccountListResponse,
    QueryManagedSubAccountMarginAssetDetailsResponse,
    QueryManagedSubAccountSnapshotResponse,
    QueryManagedSubAccountTransferLogMasterAccountInvestorResponse,
    QueryManagedSubAccountTransferLogMasterAccountTradingResponse,
    QueryManagedSubAccountTransferLogSubAccountTradingResponse,
    WithdrawlAssetsFromTheManagedSubAccountResponse,
} from '../../../src/rest-api/types';

describe('ManagedSubAccountApi', () => {
    let client: ManagedSubAccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new ManagedSubAccountApi(config);
    });

    describe('depositAssetsIntoTheManagedSubAccount()', () => {
        it('should execute depositAssetsIntoTheManagedSubAccount() successfully with required parameters only', async () => {
            const params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 66157362489 }));

            const spy = jest.spyOn(client, 'depositAssetsIntoTheManagedSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAssetsIntoTheManagedSubAccountResponse>)
            );
            const response = await client.depositAssetsIntoTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositAssetsIntoTheManagedSubAccount() successfully with optional parameters', async () => {
            const params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 66157362489 }));

            const spy = jest.spyOn(client, 'depositAssetsIntoTheManagedSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAssetsIntoTheManagedSubAccountResponse>)
            );
            const response = await client.depositAssetsIntoTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when toEmail is missing', async () => {
            const _params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.toEmail;

            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter toEmail was null or undefined when calling depositAssetsIntoTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling depositAssetsIntoTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling depositAssetsIntoTheManagedSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'depositAssetsIntoTheManagedSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getManagedSubAccountDepositAddress()', () => {
        it('should execute getManagedSubAccountDepositAddress() successfully with required parameters only', async () => {
            const params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    coin: 'USDT',
                    address: '0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
                    tag: '',
                    url: 'https://etherscan.io/address/0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
                })
            );

            const spy = jest.spyOn(client, 'getManagedSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetManagedSubAccountDepositAddressResponse>)
            );
            const response = await client.getManagedSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getManagedSubAccountDepositAddress() successfully with optional parameters', async () => {
            const params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
                network: 'network_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    coin: 'USDT',
                    address: '0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
                    tag: '',
                    url: 'https://etherscan.io/address/0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
                })
            );

            const spy = jest.spyOn(client, 'getManagedSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetManagedSubAccountDepositAddressResponse>)
            );
            const response = await client.getManagedSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getManagedSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getManagedSubAccountDepositAddress.'
            );
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.getManagedSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling getManagedSubAccountDepositAddress.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getManagedSubAccountDepositAddress')
                .mockRejectedValueOnce(mockError);
            await expect(client.getManagedSubAccountDepositAddress(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountAssetDetails()', () => {
        it('should execute queryManagedSubAccountAssetDetails() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        coin: 'INJ',
                        name: 'Injective Protocol',
                        totalBalance: '0',
                        availableBalance: '0',
                        inOrder: '0',
                        btcValue: '0',
                    },
                    {
                        coin: 'FILDOWN',
                        name: 'FILDOWN',
                        totalBalance: '0',
                        availableBalance: '0',
                        inOrder: '0',
                        btcValue: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryManagedSubAccountAssetDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountAssetDetailsResponse>)
            );
            const response = await client.queryManagedSubAccountAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountAssetDetails() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        coin: 'INJ',
                        name: 'Injective Protocol',
                        totalBalance: '0',
                        availableBalance: '0',
                        inOrder: '0',
                        btcValue: '0',
                    },
                    {
                        coin: 'FILDOWN',
                        name: 'FILDOWN',
                        totalBalance: '0',
                        availableBalance: '0',
                        inOrder: '0',
                        btcValue: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryManagedSubAccountAssetDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountAssetDetailsResponse>)
            );
            const response = await client.queryManagedSubAccountAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountAssetDetails(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountAssetDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountAssetDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountAssetDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountFuturesAssetDetails()', () => {
        it('should execute queryManagedSubAccountFuturesAssetDetails() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '200',
                    message: 'OK',
                    snapshotVos: [
                        {
                            type: 'FUTURES',
                            updateTime: 1672893855394,
                            data: {
                                assets: [{ asset: 'USDT', marginBalance: 100, walletBalance: 120 }],
                                position: [
                                    {
                                        symbol: 'BTCUSDT',
                                        entryPrice: 17000,
                                        markPrice: 17000,
                                        positionAmt: 1.0e-4,
                                    },
                                ],
                            },
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountFuturesAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountFuturesAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountFuturesAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountFuturesAssetDetails() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
                accountType: 'accountType_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '200',
                    message: 'OK',
                    snapshotVos: [
                        {
                            type: 'FUTURES',
                            updateTime: 1672893855394,
                            data: {
                                assets: [{ asset: 'USDT', marginBalance: 100, walletBalance: 120 }],
                                position: [
                                    {
                                        symbol: 'BTCUSDT',
                                        entryPrice: 17000,
                                        markPrice: 17000,
                                        positionAmt: 1.0e-4,
                                    },
                                ],
                            },
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountFuturesAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountFuturesAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountFuturesAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountFuturesAssetDetails(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountFuturesAssetDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountFuturesAssetDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountFuturesAssetDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountList()', () => {
        it('should execute queryManagedSubAccountList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    total: 3,
                    managerSubUserInfoVoList: [
                        {
                            rootUserId: 1000138475670,
                            managersubUserId: 1000137842513,
                            bindParentUserId: 1000138475669,
                            email: 'test_0_virtual@kq3kno9imanagedsub.com',
                            insertTimeStamp: 1678435149000,
                            bindParentEmail: 'wdyw8xsh8pey@test.com',
                            isSubUserEnabled: true,
                            isUserActive: true,
                            isMarginEnabled: false,
                            isFutureEnabled: false,
                            isSignedLVTRiskAgreement: false,
                        },
                        {
                            rootUserId: 1000138475670,
                            managersubUserId: 1000137842514,
                            bindParentUserId: 1000138475669,
                            email: 'test_1_virtual@4qd2u7zxmanagedsub.com',
                            insertTimeStamp: 1678435152000,
                            bindParentEmail: 'wdyw8xsh8pey@test.com',
                            isSubUserEnabled: true,
                            isUserActive: true,
                            isMarginEnabled: false,
                            isFutureEnabled: false,
                            isSignedLVTRiskAgreement: false,
                        },
                        {
                            rootUserId: 1000138475670,
                            managersubUserId: 1000137842515,
                            bindParentUserId: 1000138475669,
                            email: 'test_2_virtual@akc05o8hmanagedsub.com',
                            insertTimeStamp: 1678435153000,
                            bindParentEmail: 'wdyw8xsh8pey@test.com',
                            isSubUserEnabled: true,
                            isUserActive: true,
                            isMarginEnabled: false,
                            isFutureEnabled: false,
                            isSignedLVTRiskAgreement: false,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryManagedSubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountListResponse>)
            );
            const response = await client.queryManagedSubAccountList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountList() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountListRequest = {
                email: 'email_example',
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 3,
                    managerSubUserInfoVoList: [
                        {
                            rootUserId: 1000138475670,
                            managersubUserId: 1000137842513,
                            bindParentUserId: 1000138475669,
                            email: 'test_0_virtual@kq3kno9imanagedsub.com',
                            insertTimeStamp: 1678435149000,
                            bindParentEmail: 'wdyw8xsh8pey@test.com',
                            isSubUserEnabled: true,
                            isUserActive: true,
                            isMarginEnabled: false,
                            isFutureEnabled: false,
                            isSignedLVTRiskAgreement: false,
                        },
                        {
                            rootUserId: 1000138475670,
                            managersubUserId: 1000137842514,
                            bindParentUserId: 1000138475669,
                            email: 'test_1_virtual@4qd2u7zxmanagedsub.com',
                            insertTimeStamp: 1678435152000,
                            bindParentEmail: 'wdyw8xsh8pey@test.com',
                            isSubUserEnabled: true,
                            isUserActive: true,
                            isMarginEnabled: false,
                            isFutureEnabled: false,
                            isSignedLVTRiskAgreement: false,
                        },
                        {
                            rootUserId: 1000138475670,
                            managersubUserId: 1000137842515,
                            bindParentUserId: 1000138475669,
                            email: 'test_2_virtual@akc05o8hmanagedsub.com',
                            insertTimeStamp: 1678435153000,
                            bindParentEmail: 'wdyw8xsh8pey@test.com',
                            isSubUserEnabled: true,
                            isUserActive: true,
                            isMarginEnabled: false,
                            isFutureEnabled: false,
                            isSignedLVTRiskAgreement: false,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryManagedSubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountListResponse>)
            );
            const response = await client.queryManagedSubAccountList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountList')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountMarginAssetDetails()', () => {
        it('should execute queryManagedSubAccountMarginAssetDetails() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    marginLevel: '999',
                    totalAssetOfBtc: '0',
                    totalLiabilityOfBtc: '0',
                    totalNetAssetOfBtc: '0',
                    userAssets: [
                        {
                            asset: 'MATIC',
                            borrowed: '0',
                            free: '0',
                            interest: '0',
                            locked: '0',
                            netAsset: '0',
                        },
                        {
                            asset: 'VET',
                            borrowed: '0',
                            free: '0',
                            interest: '0',
                            locked: '0',
                            netAsset: '0',
                        },
                        {
                            asset: 'BAKE',
                            borrowed: '0',
                            free: '0',
                            interest: '0',
                            locked: '0',
                            netAsset: '0',
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountMarginAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountMarginAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountMarginAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountMarginAssetDetails() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
                accountType: 'accountType_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    marginLevel: '999',
                    totalAssetOfBtc: '0',
                    totalLiabilityOfBtc: '0',
                    totalNetAssetOfBtc: '0',
                    userAssets: [
                        {
                            asset: 'MATIC',
                            borrowed: '0',
                            free: '0',
                            interest: '0',
                            locked: '0',
                            netAsset: '0',
                        },
                        {
                            asset: 'VET',
                            borrowed: '0',
                            free: '0',
                            interest: '0',
                            locked: '0',
                            netAsset: '0',
                        },
                        {
                            asset: 'BAKE',
                            borrowed: '0',
                            free: '0',
                            interest: '0',
                            locked: '0',
                            netAsset: '0',
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountMarginAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountMarginAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountMarginAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountMarginAssetDetails(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountMarginAssetDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountMarginAssetDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountMarginAssetDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountSnapshot()', () => {
        it('should execute queryManagedSubAccountSnapshot() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: 200,
                    msg: '',
                    snapshotVos: [
                        {
                            data: {
                                balances: [
                                    { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                    { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                                ],
                                totalAssetOfBtc: '0.09942700',
                            },
                            type: 'spot',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                marginLevel: '2748.02909813',
                                totalAssetOfBtc: '0.00274803',
                                totalLiabilityOfBtc: '0.00000100',
                                totalNetAssetOfBtc: '0.00274750',
                                userAssets: [
                                    {
                                        asset: 'XRP',
                                        borrowed: '0.00000000',
                                        free: '1.00000000',
                                        interest: '0.00000000',
                                        locked: '0.00000000',
                                        netAsset: '1.00000000',
                                    },
                                ],
                            },
                            type: 'margin',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                assets: [
                                    {
                                        asset: 'USDT',
                                        marginBalance: '118.99782335',
                                        walletBalance: '120.23811389',
                                    },
                                ],
                                position: [
                                    {
                                        entryPrice: '7130.41000000',
                                        markPrice: '7257.66239673',
                                        positionAmt: '0.01000000',
                                        symbol: 'BTCUSDT',
                                        unRealizedProfit: '1.24029054',
                                    },
                                ],
                            },
                            type: 'futures',
                            updateTime: 1576281599000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryManagedSubAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountSnapshotResponse>)
            );
            const response = await client.queryManagedSubAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountSnapshot() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: 200,
                    msg: '',
                    snapshotVos: [
                        {
                            data: {
                                balances: [
                                    { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                    { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                                ],
                                totalAssetOfBtc: '0.09942700',
                            },
                            type: 'spot',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                marginLevel: '2748.02909813',
                                totalAssetOfBtc: '0.00274803',
                                totalLiabilityOfBtc: '0.00000100',
                                totalNetAssetOfBtc: '0.00274750',
                                userAssets: [
                                    {
                                        asset: 'XRP',
                                        borrowed: '0.00000000',
                                        free: '1.00000000',
                                        interest: '0.00000000',
                                        locked: '0.00000000',
                                        netAsset: '1.00000000',
                                    },
                                ],
                            },
                            type: 'margin',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                assets: [
                                    {
                                        asset: 'USDT',
                                        marginBalance: '118.99782335',
                                        walletBalance: '120.23811389',
                                    },
                                ],
                                position: [
                                    {
                                        entryPrice: '7130.41000000',
                                        markPrice: '7257.66239673',
                                        positionAmt: '0.01000000',
                                        symbol: 'BTCUSDT',
                                        unRealizedProfit: '1.24029054',
                                    },
                                ],
                            },
                            type: 'futures',
                            updateTime: 1576281599000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryManagedSubAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountSnapshotResponse>)
            );
            const response = await client.queryManagedSubAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountSnapshot(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountSnapshot.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.queryManagedSubAccountSnapshot(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling queryManagedSubAccountSnapshot.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountSnapshot')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountSnapshot(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountTransferLogMasterAccountInvestor()', () => {
        it('should execute queryManagedSubAccountTransferLogMasterAccountInvestor() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    managerSubTransferHistoryVos: [
                        {
                            fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'wdywl0lddakh@test.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '0.01',
                            scheduledData: 1679416673000,
                            createTime: 1679416673000,
                            status: 'SUCCESS',
                            tranId: 91077779,
                        },
                        {
                            fromEmail: 'wdywl0lddakh@test.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '1',
                            scheduledData: 1679416616000,
                            createTime: 1679416616000,
                            status: 'SUCCESS',
                            tranId: 91077676,
                        },
                    ],
                    count: 2,
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountInvestor')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountInvestorResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountInvestor(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountTransferLogMasterAccountInvestor() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
                transfers: 'transfers_example',
                transferFunctionAccountType: 'transferFunctionAccountType_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    managerSubTransferHistoryVos: [
                        {
                            fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'wdywl0lddakh@test.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '0.01',
                            scheduledData: 1679416673000,
                            createTime: 1679416673000,
                            status: 'SUCCESS',
                            tranId: 91077779,
                        },
                        {
                            fromEmail: 'wdywl0lddakh@test.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '1',
                            scheduledData: 1679416616000,
                            createTime: 1679416616000,
                            status: 'SUCCESS',
                            tranId: 91077676,
                        },
                    ],
                    count: 2,
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountInvestor')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountInvestorResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountInvestor(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter page was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter limit was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountInvestor')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountTransferLogMasterAccountTrading()', () => {
        it('should execute queryManagedSubAccountTransferLogMasterAccountTrading() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    managerSubTransferHistoryVos: [
                        {
                            fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'wdywl0lddakh@test.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '0.01',
                            scheduledData: 1679416673000,
                            createTime: 1679416673000,
                            status: 'SUCCESS',
                            tranId: 91077779,
                        },
                        {
                            fromEmail: 'wdywl0lddakh@test.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '1',
                            scheduledData: 1679416616000,
                            createTime: 1679416616000,
                            status: 'SUCCESS',
                            tranId: 91077676,
                        },
                    ],
                    count: 2,
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountTransferLogMasterAccountTrading() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
                transfers: 'transfers_example',
                transferFunctionAccountType: 'transferFunctionAccountType_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    managerSubTransferHistoryVos: [
                        {
                            fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'wdywl0lddakh@test.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '0.01',
                            scheduledData: 1679416673000,
                            createTime: 1679416673000,
                            status: 'SUCCESS',
                            tranId: 91077779,
                        },
                        {
                            fromEmail: 'wdywl0lddakh@test.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '1',
                            scheduledData: 1679416616000,
                            createTime: 1679416616000,
                            status: 'SUCCESS',
                            tranId: 91077676,
                        },
                    ],
                    count: 2,
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter page was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter limit was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountTrading')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountTransferLogSubAccountTrading()', () => {
        it('should execute queryManagedSubAccountTransferLogSubAccountTrading() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    managerSubTransferHistoryVos: [
                        {
                            fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'wdywl0lddakh@test.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '0.01',
                            scheduledData: 1679416673000,
                            createTime: 1679416673000,
                            status: 'SUCCESS',
                            tranId: 91077779,
                        },
                        {
                            fromEmail: 'wdywl0lddakh@test.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '1',
                            scheduledData: 1679416616000,
                            createTime: 1679416616000,
                            status: 'SUCCESS',
                            tranId: 91077676,
                        },
                    ],
                    count: 2,
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogSubAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogSubAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogSubAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountTransferLogSubAccountTrading() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
                transfers: 'transfers_example',
                transferFunctionAccountType: 'transferFunctionAccountType_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    managerSubTransferHistoryVos: [
                        {
                            fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'wdywl0lddakh@test.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '0.01',
                            scheduledData: 1679416673000,
                            createTime: 1679416673000,
                            status: 'SUCCESS',
                            tranId: 91077779,
                        },
                        {
                            fromEmail: 'wdywl0lddakh@test.com',
                            fromAccountType: 'SPOT',
                            toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                            toAccountType: 'SPOT',
                            asset: 'BNB',
                            amount: '1',
                            scheduledData: 1679416616000,
                            createTime: 1679416616000,
                            status: 'SUCCESS',
                            tranId: 91077676,
                        },
                    ],
                    count: 2,
                })
            );

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogSubAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogSubAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogSubAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter page was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter limit was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogSubAccountTrading')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawlAssetsFromTheManagedSubAccount()', () => {
        it('should execute withdrawlAssetsFromTheManagedSubAccount() successfully with required parameters only', async () => {
            const params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 66157362489 }));

            const spy = jest
                .spyOn(client, 'withdrawlAssetsFromTheManagedSubAccount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<WithdrawlAssetsFromTheManagedSubAccountResponse>)
                );
            const response = await client.withdrawlAssetsFromTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawlAssetsFromTheManagedSubAccount() successfully with optional parameters', async () => {
            const params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1.0,
                transferDate: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 66157362489 }));

            const spy = jest
                .spyOn(client, 'withdrawlAssetsFromTheManagedSubAccount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<WithdrawlAssetsFromTheManagedSubAccountResponse>)
                );
            const response = await client.withdrawlAssetsFromTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromEmail is missing', async () => {
            const _params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromEmail;

            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter fromEmail was null or undefined when calling withdrawlAssetsFromTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling withdrawlAssetsFromTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling withdrawlAssetsFromTheManagedSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'withdrawlAssetsFromTheManagedSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
