/**
 * Binance Sub Account REST API
 *
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AssetManagementApi } from '../../../src/rest-api';
import {
    FuturesTransferForSubAccountRequest,
    GetDetailOnSubAccountsFuturesAccountRequest,
    GetDetailOnSubAccountsFuturesAccountV2Request,
    GetDetailOnSubAccountsMarginAccountRequest,
    GetMovePositionHistoryForSubAccountRequest,
    GetSubAccountDepositAddressRequest,
    GetSubAccountDepositHistoryRequest,
    GetSummaryOfSubAccountsFuturesAccountRequest,
    GetSummaryOfSubAccountsFuturesAccountV2Request,
    GetSummaryOfSubAccountsMarginAccountRequest,
    MarginTransferForSubAccountRequest,
    MovePositionForSubAccountRequest,
    QuerySubAccountAssetsRequest,
    QuerySubAccountAssetsAssetManagementRequest,
    QuerySubAccountFuturesAssetTransferHistoryRequest,
    QuerySubAccountSpotAssetTransferHistoryRequest,
    QuerySubAccountSpotAssetsSummaryRequest,
    QueryUniversalTransferHistoryRequest,
    SubAccountFuturesAssetTransferRequest,
    SubAccountTransferHistoryRequest,
    TransferToMasterRequest,
    TransferToSubAccountOfSameMasterRequest,
    UniversalTransferRequest,
} from '../../../src/rest-api';
import type {
    FuturesTransferForSubAccountResponse,
    GetDetailOnSubAccountsFuturesAccountResponse,
    GetDetailOnSubAccountsFuturesAccountV2Response,
    GetDetailOnSubAccountsMarginAccountResponse,
    GetMovePositionHistoryForSubAccountResponse,
    GetSubAccountDepositAddressResponse,
    GetSubAccountDepositHistoryResponse,
    GetSummaryOfSubAccountsFuturesAccountResponse,
    GetSummaryOfSubAccountsFuturesAccountV2Response,
    GetSummaryOfSubAccountsMarginAccountResponse,
    MarginTransferForSubAccountResponse,
    MovePositionForSubAccountResponse,
    QuerySubAccountAssetsAssetManagementResponse,
    QuerySubAccountAssetsResponse,
    QuerySubAccountFuturesAssetTransferHistoryResponse,
    QuerySubAccountSpotAssetTransferHistoryResponse,
    QuerySubAccountSpotAssetsSummaryResponse,
    QueryUniversalTransferHistoryResponse,
    SubAccountFuturesAssetTransferResponse,
    SubAccountTransferHistoryResponse,
    TransferToMasterResponse,
    TransferToSubAccountOfSameMasterResponse,
    UniversalTransferResponse,
} from '../../../src/rest-api/types';

describe('AssetManagementApi', () => {
    let client: AssetManagementApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AssetManagementApi(config);
    });

    describe('futuresTransferForSubAccount()', () => {
        it('should execute futuresTransferForSubAccount() successfully with required parameters only', async () => {
            const params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'futuresTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesTransferForSubAccountResponse>)
            );
            const response = await client.futuresTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresTransferForSubAccount() successfully with optional parameters', async () => {
            const params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'futuresTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesTransferForSubAccountResponse>)
            );
            const response = await client.futuresTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresTransferForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDetailOnSubAccountsFuturesAccount()', () => {
        it('should execute getDetailOnSubAccountsFuturesAccount() successfully with required parameters only', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    email: 'abc@test.com',
                    asset: 'USDT',
                    assets: [
                        {
                            asset: 'USDT',
                            initialMargin: '0.00000000',
                            maintenanceMargin: '0.00000000',
                            marginBalance: '0.88308000',
                            maxWithdrawAmount: '0.88308000',
                            openOrderInitialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            unrealizedProfit: '0.00000000',
                            walletBalance: '0.88308000',
                        },
                    ],
                    canDeposit: true,
                    canTrade: true,
                    canWithdraw: true,
                    feeTier: 2,
                    maxWithdrawAmount: '0.88308000',
                    totalInitialMargin: '0.00000000',
                    totalMaintenanceMargin: '0.00000000',
                    totalMarginBalance: '0.88308000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalPositionInitialMargin: '0.00000000',
                    totalUnrealizedProfit: '0.00000000',
                    totalWalletBalance: '0.88308000',
                    updateTime: 1576756674610,
                })
            );

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsFuturesAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDetailOnSubAccountsFuturesAccount() successfully with optional parameters', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    email: 'abc@test.com',
                    asset: 'USDT',
                    assets: [
                        {
                            asset: 'USDT',
                            initialMargin: '0.00000000',
                            maintenanceMargin: '0.00000000',
                            marginBalance: '0.88308000',
                            maxWithdrawAmount: '0.88308000',
                            openOrderInitialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            unrealizedProfit: '0.00000000',
                            walletBalance: '0.88308000',
                        },
                    ],
                    canDeposit: true,
                    canTrade: true,
                    canWithdraw: true,
                    feeTier: 2,
                    maxWithdrawAmount: '0.88308000',
                    totalInitialMargin: '0.00000000',
                    totalMaintenanceMargin: '0.00000000',
                    totalMarginBalance: '0.88308000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalPositionInitialMargin: '0.00000000',
                    totalUnrealizedProfit: '0.00000000',
                    totalWalletBalance: '0.88308000',
                    updateTime: 1576756674610,
                })
            );

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsFuturesAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getDetailOnSubAccountsFuturesAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getDetailOnSubAccountsFuturesAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDetailOnSubAccountsFuturesAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDetailOnSubAccountsFuturesAccountV2()', () => {
        it('should execute getDetailOnSubAccountsFuturesAccountV2() successfully with required parameters only', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    futureAccountResp: {
                        email: 'abc@test.com',
                        assets: [
                            {
                                asset: 'USDT',
                                initialMargin: '0.00000000',
                                maintenanceMargin: '0.00000000',
                                marginBalance: '0.88308000',
                                maxWithdrawAmount: '0.88308000',
                                openOrderInitialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                unrealizedProfit: '0.00000000',
                                walletBalance: '0.88308000',
                            },
                        ],
                        canDeposit: true,
                        canTrade: true,
                        canWithdraw: true,
                        feeTier: 2,
                        maxWithdrawAmount: '0.88308000',
                        totalInitialMargin: '0.00000000',
                        totalMaintenanceMargin: '0.00000000',
                        totalMarginBalance: '0.88308000',
                        totalOpenOrderInitialMargin: '0.00000000',
                        totalPositionInitialMargin: '0.00000000',
                        totalUnrealizedProfit: '0.00000000',
                        totalWalletBalance: '0.88308000',
                        updateTime: 1576756674610,
                    },
                    deliveryAccountResp: {
                        email: 'abc@test.com',
                        assets: [
                            {
                                asset: 'BTC',
                                initialMargin: '0.00000000',
                                maintenanceMargin: '0.00000000',
                                marginBalance: '0.88308000',
                                maxWithdrawAmount: '0.88308000',
                                openOrderInitialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                unrealizedProfit: '0.00000000',
                                walletBalance: '0.88308000',
                            },
                        ],
                        canDeposit: true,
                        canTrade: true,
                        canWithdraw: true,
                        feeTier: 2,
                        updateTime: 1598959682001,
                    },
                })
            );

            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getDetailOnSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDetailOnSubAccountsFuturesAccountV2() successfully with optional parameters', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    futureAccountResp: {
                        email: 'abc@test.com',
                        assets: [
                            {
                                asset: 'USDT',
                                initialMargin: '0.00000000',
                                maintenanceMargin: '0.00000000',
                                marginBalance: '0.88308000',
                                maxWithdrawAmount: '0.88308000',
                                openOrderInitialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                unrealizedProfit: '0.00000000',
                                walletBalance: '0.88308000',
                            },
                        ],
                        canDeposit: true,
                        canTrade: true,
                        canWithdraw: true,
                        feeTier: 2,
                        maxWithdrawAmount: '0.88308000',
                        totalInitialMargin: '0.00000000',
                        totalMaintenanceMargin: '0.00000000',
                        totalMarginBalance: '0.88308000',
                        totalOpenOrderInitialMargin: '0.00000000',
                        totalPositionInitialMargin: '0.00000000',
                        totalUnrealizedProfit: '0.00000000',
                        totalWalletBalance: '0.88308000',
                        updateTime: 1576756674610,
                    },
                    deliveryAccountResp: {
                        email: 'abc@test.com',
                        assets: [
                            {
                                asset: 'BTC',
                                initialMargin: '0.00000000',
                                maintenanceMargin: '0.00000000',
                                marginBalance: '0.88308000',
                                maxWithdrawAmount: '0.88308000',
                                openOrderInitialMargin: '0.00000000',
                                positionInitialMargin: '0.00000000',
                                unrealizedProfit: '0.00000000',
                                walletBalance: '0.88308000',
                            },
                        ],
                        canDeposit: true,
                        canTrade: true,
                        canWithdraw: true,
                        feeTier: 2,
                        updateTime: 1598959682001,
                    },
                })
            );

            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getDetailOnSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getDetailOnSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getDetailOnSubAccountsFuturesAccountV2.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.getDetailOnSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling getDetailOnSubAccountsFuturesAccountV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccountV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDetailOnSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDetailOnSubAccountsMarginAccount()', () => {
        it('should execute getDetailOnSubAccountsMarginAccount() successfully with required parameters only', async () => {
            const params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    email: '123@test.com',
                    marginLevel: '11.64405625',
                    totalAssetOfBtc: '6.82728457',
                    totalLiabilityOfBtc: '0.58633215',
                    totalNetAssetOfBtc: '6.24095242',
                    marginTradeCoeffVo: {
                        forceLiquidationBar: '1.10000000',
                        marginCallBar: '1.50000000',
                        normalBar: '2.00000000',
                    },
                    marginUserAssetVoList: [
                        {
                            asset: 'BTC',
                            borrowed: '0.00000000',
                            free: '0.00499500',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00499500',
                        },
                        {
                            asset: 'BNB',
                            borrowed: '201.66666672',
                            free: '2346.50000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '2144.83333328',
                        },
                        {
                            asset: 'ETH',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                        {
                            asset: 'USDT',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsMarginAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDetailOnSubAccountsMarginAccount() successfully with optional parameters', async () => {
            const params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    email: '123@test.com',
                    marginLevel: '11.64405625',
                    totalAssetOfBtc: '6.82728457',
                    totalLiabilityOfBtc: '0.58633215',
                    totalNetAssetOfBtc: '6.24095242',
                    marginTradeCoeffVo: {
                        forceLiquidationBar: '1.10000000',
                        marginCallBar: '1.50000000',
                        normalBar: '2.00000000',
                    },
                    marginUserAssetVoList: [
                        {
                            asset: 'BTC',
                            borrowed: '0.00000000',
                            free: '0.00499500',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00499500',
                        },
                        {
                            asset: 'BNB',
                            borrowed: '201.66666672',
                            free: '2346.50000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '2144.83333328',
                        },
                        {
                            asset: 'ETH',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                        {
                            asset: 'USDT',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsMarginAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getDetailOnSubAccountsMarginAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getDetailOnSubAccountsMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDetailOnSubAccountsMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getMovePositionHistoryForSubAccount()', () => {
        it('should execute getMovePositionHistoryForSubAccount() successfully with required parameters only', async () => {
            const params: GetMovePositionHistoryForSubAccountRequest = {
                symbol: 'symbol_example',
                page: 789,
                row: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 3,
                    futureMovePositionOrderVoList: [
                        {
                            fromUserEmail: 'testFrom@google.com',
                            toUserEmail: 'testTo@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            price: '105025.50981609',
                            quantity: '0.00100000',
                            positionSide: 'BOTH',
                            side: 'SELL',
                            timeStamp: 1737544712000,
                        },
                        {
                            fromUserEmail: 'testFrom1@google.com',
                            toUserEmail: 'testTo1@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            price: '97100.00000000',
                            quantity: '0.00100000',
                            positionSide: 'BOTH',
                            side: 'SELL',
                            timeStamp: 1740041627000,
                        },
                        {
                            fromUserEmail: 'testFrom2@google.com',
                            toUserEmail: 'testTo2@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            price: '97108.62068889',
                            quantity: '0.00100000',
                            positionSide: 'BOTH',
                            side: 'SELL',
                            timeStamp: 1740041959000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getMovePositionHistoryForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetMovePositionHistoryForSubAccountResponse>)
            );
            const response = await client.getMovePositionHistoryForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getMovePositionHistoryForSubAccount() successfully with optional parameters', async () => {
            const params: GetMovePositionHistoryForSubAccountRequest = {
                symbol: 'symbol_example',
                page: 789,
                row: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 3,
                    futureMovePositionOrderVoList: [
                        {
                            fromUserEmail: 'testFrom@google.com',
                            toUserEmail: 'testTo@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            price: '105025.50981609',
                            quantity: '0.00100000',
                            positionSide: 'BOTH',
                            side: 'SELL',
                            timeStamp: 1737544712000,
                        },
                        {
                            fromUserEmail: 'testFrom1@google.com',
                            toUserEmail: 'testTo1@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            price: '97100.00000000',
                            quantity: '0.00100000',
                            positionSide: 'BOTH',
                            side: 'SELL',
                            timeStamp: 1740041627000,
                        },
                        {
                            fromUserEmail: 'testFrom2@google.com',
                            toUserEmail: 'testTo2@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            price: '97108.62068889',
                            quantity: '0.00100000',
                            positionSide: 'BOTH',
                            side: 'SELL',
                            timeStamp: 1740041959000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getMovePositionHistoryForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetMovePositionHistoryForSubAccountResponse>)
            );
            const response = await client.getMovePositionHistoryForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetMovePositionHistoryForSubAccountRequest = {
                symbol: 'symbol_example',
                page: 789,
                row: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getMovePositionHistoryForSubAccount(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getMovePositionHistoryForSubAccount.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: GetMovePositionHistoryForSubAccountRequest = {
                symbol: 'symbol_example',
                page: 789,
                row: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(client.getMovePositionHistoryForSubAccount(params)).rejects.toThrow(
                'Required parameter page was null or undefined when calling getMovePositionHistoryForSubAccount.'
            );
        });

        it('should throw RequiredError when row is missing', async () => {
            const _params: GetMovePositionHistoryForSubAccountRequest = {
                symbol: 'symbol_example',
                page: 789,
                row: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.row;

            await expect(client.getMovePositionHistoryForSubAccount(params)).rejects.toThrow(
                'Required parameter row was null or undefined when calling getMovePositionHistoryForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetMovePositionHistoryForSubAccountRequest = {
                symbol: 'symbol_example',
                page: 789,
                row: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getMovePositionHistoryForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getMovePositionHistoryForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSubAccountDepositAddress()', () => {
        it('should execute getSubAccountDepositAddress() successfully with required parameters only', async () => {
            const params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    address: 'TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
                    coin: 'USDT',
                    tag: '',
                    url: 'https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
                })
            );

            const spy = jest.spyOn(client, 'getSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositAddressResponse>)
            );
            const response = await client.getSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSubAccountDepositAddress() successfully with optional parameters', async () => {
            const params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
                network: 'network_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    address: 'TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
                    coin: 'USDT',
                    tag: '',
                    url: 'https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
                })
            );

            const spy = jest.spyOn(client, 'getSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositAddressResponse>)
            );
            const response = await client.getSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getSubAccountDepositAddress.'
            );
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.getSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling getSubAccountDepositAddress.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSubAccountDepositAddress')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSubAccountDepositAddress(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSubAccountDepositHistory()', () => {
        it('should execute getSubAccountDepositHistory() successfully with required parameters only', async () => {
            const params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: '769800519366885376',
                        amount: '0.001',
                        coin: 'BNB',
                        network: 'BNB',
                        status: 0,
                        address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                        addressTag: '101764890',
                        txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                        insertTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                    },
                    {
                        id: '769754833590042625',
                        amount: '0.50000000',
                        coin: 'IOTA',
                        network: 'IOTA',
                        status: 1,
                        address:
                            'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                        addressTag: '',
                        txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                        insertTime: 1599620082000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getSubAccountDepositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositHistoryResponse>)
            );
            const response = await client.getSubAccountDepositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSubAccountDepositHistory() successfully with optional parameters', async () => {
            const params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
                status: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 1,
                offset: 0,
                recvWindow: 5000,
                txId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: '769800519366885376',
                        amount: '0.001',
                        coin: 'BNB',
                        network: 'BNB',
                        status: 0,
                        address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                        addressTag: '101764890',
                        txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                        insertTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                    },
                    {
                        id: '769754833590042625',
                        amount: '0.50000000',
                        coin: 'IOTA',
                        network: 'IOTA',
                        status: 1,
                        address:
                            'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                        addressTag: '',
                        txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                        insertTime: 1599620082000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getSubAccountDepositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositHistoryResponse>)
            );
            const response = await client.getSubAccountDepositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getSubAccountDepositHistory(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getSubAccountDepositHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSubAccountDepositHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSubAccountDepositHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSummaryOfSubAccountsFuturesAccount()', () => {
        it('should execute getSummaryOfSubAccountsFuturesAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    totalInitialMargin: '9.83137400',
                    totalMaintenanceMargin: '0.41568700',
                    totalMarginBalance: '23.03235621',
                    totalOpenOrderInitialMargin: '9.00000000',
                    totalPositionInitialMargin: '0.83137400',
                    totalUnrealizedProfit: '0.03219710',
                    totalWalletBalance: '22.15879444',
                    asset: 'USD',
                    subAccountList: [
                        {
                            email: '123@test.com',
                            totalInitialMargin: '9.00000000',
                            totalMaintenanceMargin: '0.00000000',
                            totalMarginBalance: '22.12659734',
                            totalOpenOrderInitialMargin: '9.00000000',
                            totalPositionInitialMargin: '0.00000000',
                            totalUnrealizedProfit: '0.00000000',
                            totalWalletBalance: '22.12659734',
                            asset: 'USD',
                        },
                        {
                            email: '345@test.com',
                            totalInitialMargin: '0.83137400',
                            totalMaintenanceMargin: '0.41568700',
                            totalMarginBalance: '0.90575887',
                            totalOpenOrderInitialMargin: '0.00000000',
                            totalPositionInitialMargin: '0.83137400',
                            totalUnrealizedProfit: '0.03219710',
                            totalWalletBalance: '0.87356177',
                            asset: 'USD',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsFuturesAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfSubAccountsFuturesAccount() successfully with optional parameters', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalInitialMargin: '9.83137400',
                    totalMaintenanceMargin: '0.41568700',
                    totalMarginBalance: '23.03235621',
                    totalOpenOrderInitialMargin: '9.00000000',
                    totalPositionInitialMargin: '0.83137400',
                    totalUnrealizedProfit: '0.03219710',
                    totalWalletBalance: '22.15879444',
                    asset: 'USD',
                    subAccountList: [
                        {
                            email: '123@test.com',
                            totalInitialMargin: '9.00000000',
                            totalMaintenanceMargin: '0.00000000',
                            totalMarginBalance: '22.12659734',
                            totalOpenOrderInitialMargin: '9.00000000',
                            totalPositionInitialMargin: '0.00000000',
                            totalUnrealizedProfit: '0.00000000',
                            totalWalletBalance: '22.12659734',
                            asset: 'USD',
                        },
                        {
                            email: '345@test.com',
                            totalInitialMargin: '0.83137400',
                            totalMaintenanceMargin: '0.41568700',
                            totalMarginBalance: '0.90575887',
                            totalOpenOrderInitialMargin: '0.00000000',
                            totalPositionInitialMargin: '0.83137400',
                            totalUnrealizedProfit: '0.03219710',
                            totalWalletBalance: '0.87356177',
                            asset: 'USD',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsFuturesAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfSubAccountsFuturesAccount()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSummaryOfSubAccountsFuturesAccountV2()', () => {
        it('should execute getSummaryOfSubAccountsFuturesAccountV2() successfully with required parameters only', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    futureAccountSummaryResp: {
                        totalInitialMargin: '9.83137400',
                        totalMaintenanceMargin: '0.41568700',
                        totalMarginBalance: '23.03235621',
                        totalOpenOrderInitialMargin: '9.00000000',
                        totalPositionInitialMargin: '0.83137400',
                        totalUnrealizedProfit: '0.03219710',
                        totalWalletBalance: '22.15879444',
                        asset: 'USD',
                        subAccountList: [
                            {
                                email: '123@test.com',
                                totalInitialMargin: '9.00000000',
                                totalMaintenanceMargin: '0.00000000',
                                totalMarginBalance: '22.12659734',
                                totalOpenOrderInitialMargin: '9.00000000',
                                totalPositionInitialMargin: '0.00000000',
                                totalUnrealizedProfit: '0.00000000',
                                totalWalletBalance: '22.12659734',
                                asset: 'USD',
                            },
                            {
                                email: '345@test.com',
                                totalInitialMargin: '0.83137400',
                                totalMaintenanceMargin: '0.41568700',
                                totalMarginBalance: '0.90575887',
                                totalOpenOrderInitialMargin: '0.00000000',
                                totalPositionInitialMargin: '0.83137400',
                                totalUnrealizedProfit: '0.03219710',
                                totalWalletBalance: '0.87356177',
                                asset: 'USD',
                            },
                        ],
                    },
                    deliveryAccountSummaryResp: {
                        totalMarginBalanceOfBTC: '25.03221121',
                        totalUnrealizedProfitOfBTC: '0.12233410',
                        totalWalletBalanceOfBTC: '22.15879444',
                        asset: 'BTC',
                        subAccountList: [
                            {
                                email: '123@test.com',
                                totalMarginBalance: '22.12659734',
                                totalUnrealizedProfit: '0.00000000',
                                totalWalletBalance: '22.12659734',
                                asset: 'BTC',
                            },
                            {
                                email: '345@test.com',
                                totalMarginBalance: '0.90575887',
                                totalUnrealizedProfit: '0.03219710',
                                totalWalletBalance: '0.87356177',
                                asset: 'BTC',
                            },
                        ],
                    },
                })
            );

            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getSummaryOfSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfSubAccountsFuturesAccountV2() successfully with optional parameters', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    futureAccountSummaryResp: {
                        totalInitialMargin: '9.83137400',
                        totalMaintenanceMargin: '0.41568700',
                        totalMarginBalance: '23.03235621',
                        totalOpenOrderInitialMargin: '9.00000000',
                        totalPositionInitialMargin: '0.83137400',
                        totalUnrealizedProfit: '0.03219710',
                        totalWalletBalance: '22.15879444',
                        asset: 'USD',
                        subAccountList: [
                            {
                                email: '123@test.com',
                                totalInitialMargin: '9.00000000',
                                totalMaintenanceMargin: '0.00000000',
                                totalMarginBalance: '22.12659734',
                                totalOpenOrderInitialMargin: '9.00000000',
                                totalPositionInitialMargin: '0.00000000',
                                totalUnrealizedProfit: '0.00000000',
                                totalWalletBalance: '22.12659734',
                                asset: 'USD',
                            },
                            {
                                email: '345@test.com',
                                totalInitialMargin: '0.83137400',
                                totalMaintenanceMargin: '0.41568700',
                                totalMarginBalance: '0.90575887',
                                totalOpenOrderInitialMargin: '0.00000000',
                                totalPositionInitialMargin: '0.83137400',
                                totalUnrealizedProfit: '0.03219710',
                                totalWalletBalance: '0.87356177',
                                asset: 'USD',
                            },
                        ],
                    },
                    deliveryAccountSummaryResp: {
                        totalMarginBalanceOfBTC: '25.03221121',
                        totalUnrealizedProfitOfBTC: '0.12233410',
                        totalWalletBalanceOfBTC: '22.15879444',
                        asset: 'BTC',
                        subAccountList: [
                            {
                                email: '123@test.com',
                                totalMarginBalance: '22.12659734',
                                totalUnrealizedProfit: '0.00000000',
                                totalWalletBalance: '22.12659734',
                                asset: 'BTC',
                            },
                            {
                                email: '345@test.com',
                                totalMarginBalance: '0.90575887',
                                totalUnrealizedProfit: '0.03219710',
                                totalWalletBalance: '0.87356177',
                                asset: 'BTC',
                            },
                        ],
                    },
                })
            );

            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getSummaryOfSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.getSummaryOfSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling getSummaryOfSubAccountsFuturesAccountV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccountV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSummaryOfSubAccountsMarginAccount()', () => {
        it('should execute getSummaryOfSubAccountsMarginAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    totalAssetOfBtc: '4.33333333',
                    totalLiabilityOfBtc: '2.11111112',
                    totalNetAssetOfBtc: '2.22222221',
                    subAccountList: [
                        {
                            email: '123@test.com',
                            totalAssetOfBtc: '2.11111111',
                            totalLiabilityOfBtc: '1.11111111',
                            totalNetAssetOfBtc: '1.00000000',
                        },
                        {
                            email: '345@test.com',
                            totalAssetOfBtc: '2.22222222',
                            totalLiabilityOfBtc: '1.00000001',
                            totalNetAssetOfBtc: '1.22222221',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsMarginAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsMarginAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfSubAccountsMarginAccount() successfully with optional parameters', async () => {
            const params: GetSummaryOfSubAccountsMarginAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalAssetOfBtc: '4.33333333',
                    totalLiabilityOfBtc: '2.11111112',
                    totalNetAssetOfBtc: '2.22222221',
                    subAccountList: [
                        {
                            email: '123@test.com',
                            totalAssetOfBtc: '2.11111111',
                            totalLiabilityOfBtc: '1.11111111',
                            totalNetAssetOfBtc: '1.00000000',
                        },
                        {
                            email: '345@test.com',
                            totalAssetOfBtc: '2.22222222',
                            totalLiabilityOfBtc: '1.00000001',
                            totalNetAssetOfBtc: '1.22222221',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsMarginAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfSubAccountsMarginAccount()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('marginTransferForSubAccount()', () => {
        it('should execute marginTransferForSubAccount() successfully with required parameters only', async () => {
            const params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'marginTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginTransferForSubAccountResponse>)
            );
            const response = await client.marginTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginTransferForSubAccount() successfully with optional parameters', async () => {
            const params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'marginTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginTransferForSubAccountResponse>)
            );
            const response = await client.marginTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1.0,
                type: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginTransferForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('movePositionForSubAccount()', () => {
        it('should execute movePositionForSubAccount() successfully with required parameters only', async () => {
            const params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
            };

            mockResponse = JSONParse(
                JSONStringify({
                    movePositionOrders: [
                        {
                            fromUserEmail: 'testFrom@google.com',
                            toUserEmail: 'testTo@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            priceType: 'MARK_PRICE',
                            price: '97139.00000000',
                            quantity: '0.001',
                            positionSide: 'BOTH',
                            side: 'BUY',
                            success: true,
                        },
                        {
                            fromUserEmail: 'testFrom1@google.com',
                            toUserEmail: '1testTo@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            priceType: 'MARK_PRICE',
                            price: '97139.00000000',
                            quantity: '0.0011',
                            positionSide: 'BOTH',
                            side: 'BUY',
                            success: true,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'movePositionForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MovePositionForSubAccountResponse>)
            );
            const response = await client.movePositionForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute movePositionForSubAccount() successfully with optional parameters', async () => {
            const params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    movePositionOrders: [
                        {
                            fromUserEmail: 'testFrom@google.com',
                            toUserEmail: 'testTo@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            priceType: 'MARK_PRICE',
                            price: '97139.00000000',
                            quantity: '0.001',
                            positionSide: 'BOTH',
                            side: 'BUY',
                            success: true,
                        },
                        {
                            fromUserEmail: 'testFrom1@google.com',
                            toUserEmail: '1testTo@google.com',
                            productType: 'UM',
                            symbol: 'BTCUSDT',
                            priceType: 'MARK_PRICE',
                            price: '97139.00000000',
                            quantity: '0.0011',
                            positionSide: 'BOTH',
                            side: 'BUY',
                            success: true,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'movePositionForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MovePositionForSubAccountResponse>)
            );
            const response = await client.movePositionForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromUserEmail is missing', async () => {
            const _params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.fromUserEmail;

            await expect(client.movePositionForSubAccount(params)).rejects.toThrow(
                'Required parameter fromUserEmail was null or undefined when calling movePositionForSubAccount.'
            );
        });

        it('should throw RequiredError when toUserEmail is missing', async () => {
            const _params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.toUserEmail;

            await expect(client.movePositionForSubAccount(params)).rejects.toThrow(
                'Required parameter toUserEmail was null or undefined when calling movePositionForSubAccount.'
            );
        });

        it('should throw RequiredError when productType is missing', async () => {
            const _params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.productType;

            await expect(client.movePositionForSubAccount(params)).rejects.toThrow(
                'Required parameter productType was null or undefined when calling movePositionForSubAccount.'
            );
        });

        it('should throw RequiredError when orderArgs is missing', async () => {
            const _params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.orderArgs;

            await expect(client.movePositionForSubAccount(params)).rejects.toThrow(
                'Required parameter orderArgs was null or undefined when calling movePositionForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MovePositionForSubAccountRequest = {
                fromUserEmail: 'fromUserEmail_example',
                toUserEmail: 'toUserEmail_example',
                productType: 'productType_example',
                orderArgs: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'movePositionForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.movePositionForSubAccount(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySubAccountAssets()', () => {
        it('should execute querySubAccountAssets() successfully with required parameters only', async () => {
            const params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    balances: [
                        { freeze: 0, withdrawing: 0, asset: 'ADA', free: 10000, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'BNB', free: 10003, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'BTC', free: 11467.6399, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'ETH', free: 10004.995, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'USDT', free: 11652.14213, locked: 0 },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountAssets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsResponse>)
            );
            const response = await client.querySubAccountAssets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountAssets() successfully with optional parameters', async () => {
            const params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    balances: [
                        { freeze: 0, withdrawing: 0, asset: 'ADA', free: 10000, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'BNB', free: 10003, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'BTC', free: 11467.6399, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'ETH', free: 10004.995, locked: 0 },
                        { freeze: 0, withdrawing: 0, asset: 'USDT', free: 11652.14213, locked: 0 },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountAssets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsResponse>)
            );
            const response = await client.querySubAccountAssets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountAssets(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountAssets.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountAssets')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountAssets(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySubAccountAssetsAssetManagement()', () => {
        it('should execute querySubAccountAssetsAssetManagement() successfully with required parameters only', async () => {
            const params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    balances: [
                        { freeze: '0', withdrawing: '0', asset: 'ADA', free: '10000', locked: '0' },
                        { freeze: '0', withdrawing: '0', asset: 'BNB', free: '10003', locked: '0' },
                        {
                            freeze: '0',
                            withdrawing: '0',
                            asset: 'BTC',
                            free: '11467.6399',
                            locked: '0',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountAssetsAssetManagement').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsAssetManagementResponse>)
            );
            const response = await client.querySubAccountAssetsAssetManagement(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountAssetsAssetManagement() successfully with optional parameters', async () => {
            const params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    balances: [
                        { freeze: '0', withdrawing: '0', asset: 'ADA', free: '10000', locked: '0' },
                        { freeze: '0', withdrawing: '0', asset: 'BNB', free: '10003', locked: '0' },
                        {
                            freeze: '0',
                            withdrawing: '0',
                            asset: 'BTC',
                            free: '11467.6399',
                            locked: '0',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountAssetsAssetManagement').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsAssetManagementResponse>)
            );
            const response = await client.querySubAccountAssetsAssetManagement(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountAssetsAssetManagement(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountAssetsAssetManagement.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountAssetsAssetManagement')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountAssetsAssetManagement(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountFuturesAssetTransferHistory()', () => {
        it('should execute querySubAccountFuturesAssetTransferHistory() successfully with required parameters only', async () => {
            const params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    futuresType: 2,
                    transfers: [
                        {
                            from: 'aaa@test.com',
                            to: 'bbb@test.com',
                            asset: 'BTC',
                            qty: '1',
                            tranId: 11897001102,
                            time: 1544433328000,
                        },
                        {
                            from: 'bbb@test.com',
                            to: 'ccc@test.com',
                            asset: 'ETH',
                            qty: '2',
                            tranId: 11631474902,
                            time: 1544433328000,
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'querySubAccountFuturesAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountFuturesAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountFuturesAssetTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountFuturesAssetTransferHistory() successfully with optional parameters', async () => {
            const params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    futuresType: 2,
                    transfers: [
                        {
                            from: 'aaa@test.com',
                            to: 'bbb@test.com',
                            asset: 'BTC',
                            qty: '1',
                            tranId: 11897001102,
                            time: 1544433328000,
                        },
                        {
                            from: 'bbb@test.com',
                            to: 'ccc@test.com',
                            asset: 'ETH',
                            qty: '2',
                            tranId: 11631474902,
                            time: 1544433328000,
                        },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'querySubAccountFuturesAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountFuturesAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountFuturesAssetTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountFuturesAssetTransferHistory(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountFuturesAssetTransferHistory.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.querySubAccountFuturesAssetTransferHistory(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling querySubAccountFuturesAssetTransferHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountFuturesAssetTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountFuturesAssetTransferHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountSpotAssetTransferHistory()', () => {
        it('should execute querySubAccountSpotAssetTransferHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        from: 'aaa@test.com',
                        to: 'bbb@test.com',
                        asset: 'BTC',
                        qty: '10',
                        status: 'SUCCESS',
                        tranId: 6489943656,
                        time: 1544433328000,
                    },
                    {
                        from: 'bbb@test.com',
                        to: 'ccc@test.com',
                        asset: 'ETH',
                        qty: '2',
                        status: 'SUCCESS',
                        tranId: 6489938713,
                        time: 1544433328000,
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountSpotAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountSpotAssetTransferHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountSpotAssetTransferHistory() successfully with optional parameters', async () => {
            const params: QuerySubAccountSpotAssetTransferHistoryRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        from: 'aaa@test.com',
                        to: 'bbb@test.com',
                        asset: 'BTC',
                        qty: '10',
                        status: 'SUCCESS',
                        tranId: 6489943656,
                        time: 1544433328000,
                    },
                    {
                        from: 'bbb@test.com',
                        to: 'ccc@test.com',
                        asset: 'ETH',
                        qty: '2',
                        status: 'SUCCESS',
                        tranId: 6489938713,
                        time: 1544433328000,
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountSpotAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountSpotAssetTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountSpotAssetTransferHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountSpotAssetsSummary()', () => {
        it('should execute querySubAccountSpotAssetsSummary() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    totalCount: 2,
                    masterAccountTotalAsset: '0.23231201',
                    spotSubUserAssetBtcVoList: [
                        { email: 'sub123@test.com', totalAsset: '9999.00000000' },
                        { email: 'test456@test.com', totalAsset: '0.00000000' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountSpotAssetsSummary').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountSpotAssetsSummaryResponse>)
            );
            const response = await client.querySubAccountSpotAssetsSummary();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountSpotAssetsSummary() successfully with optional parameters', async () => {
            const params: QuerySubAccountSpotAssetsSummaryRequest = {
                email: 'email_example',
                page: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalCount: 2,
                    masterAccountTotalAsset: '0.23231201',
                    spotSubUserAssetBtcVoList: [
                        { email: 'sub123@test.com', totalAsset: '9999.00000000' },
                        { email: 'test456@test.com', totalAsset: '0.00000000' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountSpotAssetsSummary').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountSpotAssetsSummaryResponse>)
            );
            const response = await client.querySubAccountSpotAssetsSummary(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetsSummary')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountSpotAssetsSummary()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUniversalTransferHistory()', () => {
        it('should execute queryUniversalTransferHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    result: [
                        {
                            tranId: 92275823339,
                            fromEmail: 'abctest@gmail.com',
                            toEmail: 'deftest@gmail.com',
                            asset: 'BNB',
                            amount: '0.01',
                            createTimeStamp: 1640317374000,
                            fromAccountType: 'USDT_FUTURE',
                            toAccountType: 'SPOT',
                            status: 'SUCCESS',
                            clientTranId: 'test',
                        },
                    ],
                    totalCount: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUniversalTransferHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUniversalTransferHistory() successfully with optional parameters', async () => {
            const params: QueryUniversalTransferHistoryRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                clientTranId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    result: [
                        {
                            tranId: 92275823339,
                            fromEmail: 'abctest@gmail.com',
                            toEmail: 'deftest@gmail.com',
                            asset: 'BNB',
                            amount: '0.01',
                            createTimeStamp: 1640317374000,
                            fromAccountType: 'USDT_FUTURE',
                            toAccountType: 'SPOT',
                            status: 'SUCCESS',
                            clientTranId: 'test',
                        },
                    ],
                    totalCount: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUniversalTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUniversalTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUniversalTransferHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subAccountFuturesAssetTransfer()', () => {
        it('should execute subAccountFuturesAssetTransfer() successfully with required parameters only', async () => {
            const params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ success: true, txnId: '2934662589' }));

            const spy = jest.spyOn(client, 'subAccountFuturesAssetTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountFuturesAssetTransferResponse>)
            );
            const response = await client.subAccountFuturesAssetTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subAccountFuturesAssetTransfer() successfully with optional parameters', async () => {
            const params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true, txnId: '2934662589' }));

            const spy = jest.spyOn(client, 'subAccountFuturesAssetTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountFuturesAssetTransferResponse>)
            );
            const response = await client.subAccountFuturesAssetTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromEmail is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromEmail;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter fromEmail was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when toEmail is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.toEmail;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter toEmail was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subAccountFuturesAssetTransfer')
                .mockRejectedValueOnce(mockError);
            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('subAccountTransferHistory()', () => {
        it('should execute subAccountTransferHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        counterParty: 'master',
                        email: 'master@test.com',
                        type: 1,
                        asset: 'BTC',
                        qty: '1',
                        fromAccountType: 'SPOT',
                        toAccountType: 'SPOT',
                        status: 'SUCCESS',
                        tranId: 11798835829,
                        time: 1544433325000,
                    },
                    {
                        counterParty: 'subAccount',
                        email: 'sub2@test.com',
                        type: 1,
                        asset: 'ETH',
                        qty: '2',
                        fromAccountType: 'SPOT',
                        toAccountType: 'COIN_FUTURE',
                        status: 'SUCCESS',
                        tranId: 11798829519,
                        time: 1544433326000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'subAccountTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountTransferHistoryResponse>)
            );
            const response = await client.subAccountTransferHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subAccountTransferHistory() successfully with optional parameters', async () => {
            const params: SubAccountTransferHistoryRequest = {
                asset: 'asset_example',
                type: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 1,
                returnFailHistory: false,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        counterParty: 'master',
                        email: 'master@test.com',
                        type: 1,
                        asset: 'BTC',
                        qty: '1',
                        fromAccountType: 'SPOT',
                        toAccountType: 'SPOT',
                        status: 'SUCCESS',
                        tranId: 11798835829,
                        time: 1544433325000,
                    },
                    {
                        counterParty: 'subAccount',
                        email: 'sub2@test.com',
                        type: 1,
                        asset: 'ETH',
                        qty: '2',
                        fromAccountType: 'SPOT',
                        toAccountType: 'COIN_FUTURE',
                        status: 'SUCCESS',
                        tranId: 11798829519,
                        time: 1544433326000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'subAccountTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountTransferHistoryResponse>)
            );
            const response = await client.subAccountTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subAccountTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.subAccountTransferHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('transferToMaster()', () => {
        it('should execute transferToMaster() successfully with required parameters only', async () => {
            const params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'transferToMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToMasterResponse>)
            );
            const response = await client.transferToMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute transferToMaster() successfully with optional parameters', async () => {
            const params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'transferToMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToMasterResponse>)
            );
            const response = await client.transferToMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.transferToMaster(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling transferToMaster.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.transferToMaster(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling transferToMaster.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'transferToMaster').mockRejectedValueOnce(mockError);
            await expect(client.transferToMaster(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('transferToSubAccountOfSameMaster()', () => {
        it('should execute transferToSubAccountOfSameMaster() successfully with required parameters only', async () => {
            const params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'transferToSubAccountOfSameMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToSubAccountOfSameMasterResponse>)
            );
            const response = await client.transferToSubAccountOfSameMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute transferToSubAccountOfSameMaster() successfully with optional parameters', async () => {
            const params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ txnId: '2966662589' }));

            const spy = jest.spyOn(client, 'transferToSubAccountOfSameMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToSubAccountOfSameMasterResponse>)
            );
            const response = await client.transferToSubAccountOfSameMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when toEmail is missing', async () => {
            const _params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.toEmail;

            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'Required parameter toEmail was null or undefined when calling transferToSubAccountOfSameMaster.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling transferToSubAccountOfSameMaster.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling transferToSubAccountOfSameMaster.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'transferToSubAccountOfSameMaster')
                .mockRejectedValueOnce(mockError);
            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('universalTransfer()', () => {
        it('should execute universalTransfer() successfully with required parameters only', async () => {
            const params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 11945860693, clientTranId: 'test' }));

            const spy = jest.spyOn(client, 'universalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UniversalTransferResponse>)
            );
            const response = await client.universalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute universalTransfer() successfully with optional parameters', async () => {
            const params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                clientTranId: '1',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 11945860693, clientTranId: 'test' }));

            const spy = jest.spyOn(client, 'universalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UniversalTransferResponse>)
            );
            const response = await client.universalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromAccountType is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromAccountType;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter fromAccountType was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw RequiredError when toAccountType is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.toAccountType;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter toAccountType was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'universalTransfer').mockRejectedValueOnce(mockError);
            await expect(client.universalTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
