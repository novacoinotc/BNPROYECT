/**
 * Binance Sub Account REST API
 *
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountManagementApi } from '../../../src/rest-api';
import {
    CreateAVirtualSubAccountRequest,
    EnableFuturesForSubAccountRequest,
    EnableOptionsForSubAccountRequest,
    GetFuturesPositionRiskOfSubAccountRequest,
    GetFuturesPositionRiskOfSubAccountV2Request,
    GetSubAccountsStatusOnMarginOrFuturesRequest,
    QuerySubAccountListRequest,
    QuerySubAccountTransactionStatisticsRequest,
} from '../../../src/rest-api';
import type {
    CreateAVirtualSubAccountResponse,
    EnableFuturesForSubAccountResponse,
    EnableOptionsForSubAccountResponse,
    GetFuturesPositionRiskOfSubAccountResponse,
    GetFuturesPositionRiskOfSubAccountV2Response,
    GetSubAccountsStatusOnMarginOrFuturesResponse,
    QuerySubAccountListResponse,
    QuerySubAccountTransactionStatisticsResponse,
} from '../../../src/rest-api/types';

describe('AccountManagementApi', () => {
    let client: AccountManagementApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountManagementApi(config);
    });

    describe('createAVirtualSubAccount()', () => {
        it('should execute createAVirtualSubAccount() successfully with required parameters only', async () => {
            const params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ email: 'addsdd_virtual@aasaixwqnoemail.com' })
            );

            const spy = jest.spyOn(client, 'createAVirtualSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateAVirtualSubAccountResponse>)
            );
            const response = await client.createAVirtualSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute createAVirtualSubAccount() successfully with optional parameters', async () => {
            const params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ email: 'addsdd_virtual@aasaixwqnoemail.com' })
            );

            const spy = jest.spyOn(client, 'createAVirtualSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateAVirtualSubAccountResponse>)
            );
            const response = await client.createAVirtualSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when subAccountString is missing', async () => {
            const _params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.subAccountString;

            await expect(client.createAVirtualSubAccount(params)).rejects.toThrow(
                'Required parameter subAccountString was null or undefined when calling createAVirtualSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'createAVirtualSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.createAVirtualSubAccount(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('enableFuturesForSubAccount()', () => {
        it('should execute enableFuturesForSubAccount() successfully with required parameters only', async () => {
            const params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({ email: '123@test.com', isFuturesEnabled: true })
            );

            const spy = jest.spyOn(client, 'enableFuturesForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableFuturesForSubAccountResponse>)
            );
            const response = await client.enableFuturesForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableFuturesForSubAccount() successfully with optional parameters', async () => {
            const params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ email: '123@test.com', isFuturesEnabled: true })
            );

            const spy = jest.spyOn(client, 'enableFuturesForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableFuturesForSubAccountResponse>)
            );
            const response = await client.enableFuturesForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.enableFuturesForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling enableFuturesForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableFuturesForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableFuturesForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('enableOptionsForSubAccount()', () => {
        it('should execute enableOptionsForSubAccount() successfully with required parameters only', async () => {
            const params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify({ email: '123@test.com', isEOptionsEnabled: true })
            );

            const spy = jest.spyOn(client, 'enableOptionsForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableOptionsForSubAccountResponse>)
            );
            const response = await client.enableOptionsForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableOptionsForSubAccount() successfully with optional parameters', async () => {
            const params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ email: '123@test.com', isEOptionsEnabled: true })
            );

            const spy = jest.spyOn(client, 'enableOptionsForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableOptionsForSubAccountResponse>)
            );
            const response = await client.enableOptionsForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.enableOptionsForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling enableOptionsForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableOptionsForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableOptionsForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesPositionRiskOfSubAccount()', () => {
        it('should execute getFuturesPositionRiskOfSubAccount() successfully with required parameters only', async () => {
            const params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '9975.12000',
                        leverage: '50',
                        maxNotional: '1000000',
                        liquidationPrice: '7963.54',
                        markPrice: '9973.50770517',
                        positionAmount: '0.010',
                        symbol: 'BTCUSDT',
                        unrealizedProfit: '-0.01612295',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountResponse>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesPositionRiskOfSubAccount() successfully with optional parameters', async () => {
            const params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '9975.12000',
                        leverage: '50',
                        maxNotional: '1000000',
                        liquidationPrice: '7963.54',
                        markPrice: '9973.50770517',
                        positionAmount: '0.010',
                        symbol: 'BTCUSDT',
                        unrealizedProfit: '-0.01612295',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountResponse>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getFuturesPositionRiskOfSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getFuturesPositionRiskOfSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesPositionRiskOfSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesPositionRiskOfSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesPositionRiskOfSubAccountV2()', () => {
        it('should execute getFuturesPositionRiskOfSubAccountV2() successfully with required parameters only', async () => {
            const params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    futurePositionRiskVos: [
                        {
                            entryPrice: '9975.12000',
                            leverage: '50',
                            maxNotional: '1000000',
                            liquidationPrice: '7963.54',
                            markPrice: '9973.50770517',
                            positionAmount: '0.010',
                            symbol: 'BTCUSDT',
                            unrealizedProfit: '-0.01612295',
                        },
                    ],
                    deliveryPositionRiskVos: [
                        {
                            entryPrice: '9975.12000',
                            markPrice: '9973.50770517',
                            leverage: '20',
                            isolated: 'false',
                            isolatedWallet: '9973.50770517',
                            isolatedMargin: '0.00000000',
                            isAutoAddMargin: 'false',
                            positionSide: 'BOTH',
                            positionAmount: '1.230',
                            symbol: 'BTCUSD_201225',
                            unrealizedProfit: '-0.01612295',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccountV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountV2Response>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesPositionRiskOfSubAccountV2() successfully with optional parameters', async () => {
            const params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    futurePositionRiskVos: [
                        {
                            entryPrice: '9975.12000',
                            leverage: '50',
                            maxNotional: '1000000',
                            liquidationPrice: '7963.54',
                            markPrice: '9973.50770517',
                            positionAmount: '0.010',
                            symbol: 'BTCUSDT',
                            unrealizedProfit: '-0.01612295',
                        },
                    ],
                    deliveryPositionRiskVos: [
                        {
                            entryPrice: '9975.12000',
                            markPrice: '9973.50770517',
                            leverage: '20',
                            isolated: 'false',
                            isolatedWallet: '9973.50770517',
                            isolatedMargin: '0.00000000',
                            isAutoAddMargin: 'false',
                            positionSide: 'BOTH',
                            positionAmount: '1.230',
                            symbol: 'BTCUSD_201225',
                            unrealizedProfit: '-0.01612295',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccountV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountV2Response>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getFuturesPositionRiskOfSubAccountV2(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getFuturesPositionRiskOfSubAccountV2.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.getFuturesPositionRiskOfSubAccountV2(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling getFuturesPositionRiskOfSubAccountV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesPositionRiskOfSubAccountV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesPositionRiskOfSubAccountV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSubAccountsStatusOnMarginOrFutures()', () => {
        it('should execute getSubAccountsStatusOnMarginOrFutures() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        email: '123@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        insertTime: 1570791523523,
                        isMarginEnabled: true,
                        isFutureEnabled: true,
                        mobile: 1570791523523,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getSubAccountsStatusOnMarginOrFutures').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountsStatusOnMarginOrFuturesResponse>)
            );
            const response = await client.getSubAccountsStatusOnMarginOrFutures();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSubAccountsStatusOnMarginOrFutures() successfully with optional parameters', async () => {
            const params: GetSubAccountsStatusOnMarginOrFuturesRequest = {
                email: 'email_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        email: '123@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        insertTime: 1570791523523,
                        isMarginEnabled: true,
                        isFutureEnabled: true,
                        mobile: 1570791523523,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getSubAccountsStatusOnMarginOrFutures').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountsStatusOnMarginOrFuturesResponse>)
            );
            const response = await client.getSubAccountsStatusOnMarginOrFutures(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSubAccountsStatusOnMarginOrFutures')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSubAccountsStatusOnMarginOrFutures()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountList()', () => {
        it('should execute querySubAccountList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    subAccounts: [
                        {
                            subUserId: 123456,
                            email: 'testsub@gmail.com',
                            remark: 'remark',
                            isFreeze: false,
                            createTime: 1544433328000,
                            isManagedSubAccount: false,
                            isAssetManagementSubAccount: false,
                        },
                        {
                            subUserId: 1234567,
                            email: 'virtual@oxebmvfonoemail.com',
                            remark: 'remarks',
                            isFreeze: false,
                            createTime: 1544433328000,
                            isManagedSubAccount: false,
                            isAssetManagementSubAccount: false,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountListResponse>)
            );
            const response = await client.querySubAccountList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountList() successfully with optional parameters', async () => {
            const params: QuerySubAccountListRequest = {
                email: 'email_example',
                isFreeze: 'isFreeze_example',
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    subAccounts: [
                        {
                            subUserId: 123456,
                            email: 'testsub@gmail.com',
                            remark: 'remark',
                            isFreeze: false,
                            createTime: 1544433328000,
                            isManagedSubAccount: false,
                            isAssetManagementSubAccount: false,
                        },
                        {
                            subUserId: 1234567,
                            email: 'virtual@oxebmvfonoemail.com',
                            remark: 'remarks',
                            isFreeze: false,
                            createTime: 1544433328000,
                            isManagedSubAccount: false,
                            isAssetManagementSubAccount: false,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountListResponse>)
            );
            const response = await client.querySubAccountList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'querySubAccountList').mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySubAccountTransactionStatistics()', () => {
        it('should execute querySubAccountTransactionStatistics() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    recent30BtcTotal: '0',
                    recent30BtcFuturesTotal: '0',
                    recent30BtcMarginTotal: '0',
                    recent30BusdTotal: '0',
                    recent30BusdFuturesTotal: '0',
                    recent30BusdMarginTotal: '0',
                    tradeInfoVos: [
                        {
                            userId: 1000138138384,
                            btc: 0,
                            btcFutures: 0,
                            btcMargin: 0,
                            busd: 0,
                            busdFutures: 0,
                            busdMargin: 0,
                            date: 1676851200000,
                        },
                        {
                            userId: 1000138138384,
                            btc: 0,
                            btcFutures: 0,
                            btcMargin: 0,
                            busd: 0,
                            busdFutures: 0,
                            busdMargin: 0,
                            date: 1677110400000,
                        },
                        {
                            userId: 1000138138384,
                            btc: 0,
                            btcFutures: 0,
                            btcMargin: 0,
                            busd: 0,
                            busdFutures: 0,
                            busdMargin: 0,
                            date: 1677369600000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountTransactionStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountTransactionStatisticsResponse>)
            );
            const response = await client.querySubAccountTransactionStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountTransactionStatistics() successfully with optional parameters', async () => {
            const params: QuerySubAccountTransactionStatisticsRequest = {
                email: 'email_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    recent30BtcTotal: '0',
                    recent30BtcFuturesTotal: '0',
                    recent30BtcMarginTotal: '0',
                    recent30BusdTotal: '0',
                    recent30BusdFuturesTotal: '0',
                    recent30BusdMarginTotal: '0',
                    tradeInfoVos: [
                        {
                            userId: 1000138138384,
                            btc: 0,
                            btcFutures: 0,
                            btcMargin: 0,
                            busd: 0,
                            busdFutures: 0,
                            busdMargin: 0,
                            date: 1676851200000,
                        },
                        {
                            userId: 1000138138384,
                            btc: 0,
                            btcFutures: 0,
                            btcMargin: 0,
                            busd: 0,
                            busdFutures: 0,
                            busdMargin: 0,
                            date: 1677110400000,
                        },
                        {
                            userId: 1000138138384,
                            btc: 0,
                            btcFutures: 0,
                            btcMargin: 0,
                            busd: 0,
                            busdFutures: 0,
                            busdMargin: 0,
                            date: 1677369600000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'querySubAccountTransactionStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountTransactionStatisticsResponse>)
            );
            const response = await client.querySubAccountTransactionStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountTransactionStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountTransactionStatistics()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
