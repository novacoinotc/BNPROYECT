/**
 * Binance Derivatives Trading Options REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    NewOrderSideEnum,
    NewOrderTypeEnum,
    NewOrderTimeInForceEnum,
    NewOrderNewOrderRespTypeEnum,
} from '../../../src/rest-api';
import {
    AccountTradeListRequest,
    CancelAllOptionOrdersByUnderlyingRequest,
    CancelAllOptionOrdersOnSpecificSymbolRequest,
    CancelMultipleOptionOrdersRequest,
    CancelOptionOrderRequest,
    NewOrderRequest,
    OptionPositionInformationRequest,
    PlaceMultipleOrdersRequest,
    QueryCurrentOpenOptionOrdersRequest,
    QueryOptionOrderHistoryRequest,
    QuerySingleOrderRequest,
    UserCommissionRequest,
    UserExerciseRecordRequest,
} from '../../../src/rest-api';
import type {
    AccountTradeListResponse,
    CancelAllOptionOrdersByUnderlyingResponse,
    CancelAllOptionOrdersOnSpecificSymbolResponse,
    CancelMultipleOptionOrdersResponse,
    CancelOptionOrderResponse,
    NewOrderResponse,
    OptionPositionInformationResponse,
    PlaceMultipleOrdersResponse,
    QueryCurrentOpenOptionOrdersResponse,
    QueryOptionOrderHistoryResponse,
    QuerySingleOrderResponse,
    UserCommissionResponse,
    UserExerciseRecordResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('accountTradeList()', () => {
        it('should execute accountTradeList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 4611875134427365000,
                        tradeId: 239,
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        fee: '0',
                        realizedProfit: '0.00000000',
                        side: 'BUY',
                        type: 'LIMIT',
                        liquidity: 'TAKER',
                        time: 1592465880683,
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountTradeList() successfully with optional parameters', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 4611875134427365000,
                        tradeId: 239,
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        fee: '0',
                        realizedProfit: '0.00000000',
                        side: 'BUY',
                        type: 'LIMIT',
                        liquidity: 'TAKER',
                        time: 1592465880683,
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountTradeList').mockRejectedValueOnce(mockError);
            await expect(client.accountTradeList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAllOptionOrdersByUnderlying()', () => {
        it('should execute cancelAllOptionOrdersByUnderlying() successfully with required parameters only', async () => {
            const params: CancelAllOptionOrdersByUnderlyingRequest = {
                underlying: 'underlying_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 0, msg: 'success' }));

            const spy = jest.spyOn(client, 'cancelAllOptionOrdersByUnderlying').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOptionOrdersByUnderlyingResponse>)
            );
            const response = await client.cancelAllOptionOrdersByUnderlying(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllOptionOrdersByUnderlying() successfully with optional parameters', async () => {
            const params: CancelAllOptionOrdersByUnderlyingRequest = {
                underlying: 'underlying_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 0, msg: 'success' }));

            const spy = jest.spyOn(client, 'cancelAllOptionOrdersByUnderlying').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOptionOrdersByUnderlyingResponse>)
            );
            const response = await client.cancelAllOptionOrdersByUnderlying(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when underlying is missing', async () => {
            const _params: CancelAllOptionOrdersByUnderlyingRequest = {
                underlying: 'underlying_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.underlying;

            await expect(client.cancelAllOptionOrdersByUnderlying(params)).rejects.toThrow(
                'Required parameter underlying was null or undefined when calling cancelAllOptionOrdersByUnderlying.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllOptionOrdersByUnderlyingRequest = {
                underlying: 'underlying_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllOptionOrdersByUnderlying')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllOptionOrdersByUnderlying(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelAllOptionOrdersOnSpecificSymbol()', () => {
        it('should execute cancelAllOptionOrdersOnSpecificSymbol() successfully with required parameters only', async () => {
            const params: CancelAllOptionOrdersOnSpecificSymbolRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(JSONStringify({ code: 0, msg: 'success' }));

            const spy = jest.spyOn(client, 'cancelAllOptionOrdersOnSpecificSymbol').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOptionOrdersOnSpecificSymbolResponse>)
            );
            const response = await client.cancelAllOptionOrdersOnSpecificSymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllOptionOrdersOnSpecificSymbol() successfully with optional parameters', async () => {
            const params: CancelAllOptionOrdersOnSpecificSymbolRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ code: 0, msg: 'success' }));

            const spy = jest.spyOn(client, 'cancelAllOptionOrdersOnSpecificSymbol').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOptionOrdersOnSpecificSymbolResponse>)
            );
            const response = await client.cancelAllOptionOrdersOnSpecificSymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllOptionOrdersOnSpecificSymbolRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllOptionOrdersOnSpecificSymbol(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllOptionOrdersOnSpecificSymbol.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllOptionOrdersOnSpecificSymbolRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllOptionOrdersOnSpecificSymbol')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllOptionOrdersOnSpecificSymbol(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelMultipleOptionOrders()', () => {
        it('should execute cancelMultipleOptionOrders() successfully with required parameters only', async () => {
            const params: CancelMultipleOptionOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        executedQty: '0',
                        side: 'BUY',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1592465880683,
                        updateTime: 1566818724722,
                        status: 'NEW',
                        avgPrice: '0',
                        source: 'API',
                        clientOrderId: '',
                        priceScale: 3,
                        quantityScale: 4,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'cancelMultipleOptionOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOptionOrdersResponse>)
            );
            const response = await client.cancelMultipleOptionOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMultipleOptionOrders() successfully with optional parameters', async () => {
            const params: CancelMultipleOptionOrdersRequest = {
                symbol: 'symbol_example',
                orderIds: [4611875134427365000],
                clientOrderIds: ['my_id_1'],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        executedQty: '0',
                        side: 'BUY',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1592465880683,
                        updateTime: 1566818724722,
                        status: 'NEW',
                        avgPrice: '0',
                        source: 'API',
                        clientOrderId: '',
                        priceScale: 3,
                        quantityScale: 4,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'cancelMultipleOptionOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOptionOrdersResponse>)
            );
            const response = await client.cancelMultipleOptionOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMultipleOptionOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMultipleOptionOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMultipleOptionOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMultipleOptionOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelMultipleOptionOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelMultipleOptionOrders(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelOptionOrder()', () => {
        it('should execute cancelOptionOrder() successfully with required parameters only', async () => {
            const params: CancelOptionOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 4611875134427365000,
                    symbol: 'BTC-200730-9000-C',
                    price: '100',
                    quantity: '1',
                    executedQty: '0',
                    side: 'BUY',
                    type: 'LIMIT',
                    timeInForce: 'GTC',
                    reduceOnly: false,
                    createDate: 1592465880683,
                    updateTime: 1566818724722,
                    status: 'ACCEPTED',
                    avgPrice: '0',
                    source: 'API',
                    clientOrderId: '',
                    priceScale: 4,
                    quantityScale: 4,
                    optionSide: 'CALL',
                    quoteAsset: 'USDT',
                    mmp: false,
                })
            );

            const spy = jest.spyOn(client, 'cancelOptionOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOptionOrderResponse>)
            );
            const response = await client.cancelOptionOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelOptionOrder() successfully with optional parameters', async () => {
            const params: CancelOptionOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                clientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 4611875134427365000,
                    symbol: 'BTC-200730-9000-C',
                    price: '100',
                    quantity: '1',
                    executedQty: '0',
                    side: 'BUY',
                    type: 'LIMIT',
                    timeInForce: 'GTC',
                    reduceOnly: false,
                    createDate: 1592465880683,
                    updateTime: 1566818724722,
                    status: 'ACCEPTED',
                    avgPrice: '0',
                    source: 'API',
                    clientOrderId: '',
                    priceScale: 4,
                    quantityScale: 4,
                    optionSide: 'CALL',
                    quoteAsset: 'USDT',
                    mmp: false,
                })
            );

            const spy = jest.spyOn(client, 'cancelOptionOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOptionOrderResponse>)
            );
            const response = await client.cancelOptionOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelOptionOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelOptionOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelOptionOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelOptionOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelOptionOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelOptionOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 4611875134427365000,
                    symbol: 'BTC-200730-9000-C',
                    price: '100',
                    quantity: '1',
                    executedQty: '0',
                    side: 'BUY',
                    type: 'LIMIT',
                    timeInForce: 'GTC',
                    reduceOnly: false,
                    createTime: 1592465880683,
                    updateTime: 1566818724722,
                    status: 'NEW',
                    avgPrice: '0',
                    source: 'API',
                    clientOrderId: '',
                    priceScale: 2,
                    quantityScale: 2,
                    optionSide: 'CALL',
                    quoteAsset: 'USDT',
                    mmp: false,
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
                price: 1.0,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                reduceOnly: false,
                postOnly: false,
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                clientOrderId: '1',
                isMmp: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 4611875134427365000,
                    symbol: 'BTC-200730-9000-C',
                    price: '100',
                    quantity: '1',
                    executedQty: '0',
                    side: 'BUY',
                    type: 'LIMIT',
                    timeInForce: 'GTC',
                    reduceOnly: false,
                    createTime: 1592465880683,
                    updateTime: 1566818724722,
                    status: 'NEW',
                    avgPrice: '0',
                    source: 'API',
                    clientOrderId: '',
                    priceScale: 2,
                    quantityScale: 2,
                    optionSide: 'CALL',
                    quoteAsset: 'USDT',
                    mmp: false,
                })
            );

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.LIMIT,
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('optionPositionInformation()', () => {
        it('should execute optionPositionInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '1000',
                        symbol: 'BTC-200730-9000-C',
                        side: 'SHORT',
                        quantity: '-0.1',
                        markValue: '105.00138',
                        unrealizedPNL: '-5.00138',
                        markPrice: '1050.0138',
                        strikePrice: '9000',
                        expiryDate: 1593511200000,
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        time: 1762872654561,
                        bidQuantity: '0.0000',
                        askQuantity: '0.0000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'optionPositionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OptionPositionInformationResponse>)
            );
            const response = await client.optionPositionInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute optionPositionInformation() successfully with optional parameters', async () => {
            const params: OptionPositionInformationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        entryPrice: '1000',
                        symbol: 'BTC-200730-9000-C',
                        side: 'SHORT',
                        quantity: '-0.1',
                        markValue: '105.00138',
                        unrealizedPNL: '-5.00138',
                        markPrice: '1050.0138',
                        strikePrice: '9000',
                        expiryDate: 1593511200000,
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        time: 1762872654561,
                        bidQuantity: '0.0000',
                        askQuantity: '0.0000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'optionPositionInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OptionPositionInformationResponse>)
            );
            const response = await client.optionPositionInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'optionPositionInformation')
                .mockRejectedValueOnce(mockError);
            await expect(client.optionPositionInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('placeMultipleOrders()', () => {
        it('should execute placeMultipleOrders() successfully with required parameters only', async () => {
            const params: PlaceMultipleOrdersRequest = {
                orders: [],
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        executedQty: '0',
                        side: 'BUY',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1592465880683,
                        updateTime: 1566818724722,
                        status: 'NEW',
                        avgPrice: '0',
                        source: 'API',
                        clientOrderId: '',
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute placeMultipleOrders() successfully with optional parameters', async () => {
            const params: PlaceMultipleOrdersRequest = {
                orders: [],
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        executedQty: '0',
                        side: 'BUY',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1592465880683,
                        updateTime: 1566818724722,
                        status: 'NEW',
                        avgPrice: '0',
                        source: 'API',
                        clientOrderId: '',
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when orders is missing', async () => {
            const _params: PlaceMultipleOrdersRequest = {
                orders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.orders;

            await expect(client.placeMultipleOrders(params)).rejects.toThrow(
                'Required parameter orders was null or undefined when calling placeMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PlaceMultipleOrdersRequest = {
                orders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'placeMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.placeMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentOpenOptionOrders()', () => {
        it('should execute queryCurrentOpenOptionOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        executedQty: '0',
                        side: 'BUY',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1592465880683,
                        updateTime: 1592465880683,
                        status: 'NEW',
                        avgPrice: '0',
                        clientOrderId: '',
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCurrentOpenOptionOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOptionOrdersResponse>)
            );
            const response = await client.queryCurrentOpenOptionOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentOpenOptionOrders() successfully with optional parameters', async () => {
            const params: QueryCurrentOpenOptionOrdersRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611875134427365000,
                        symbol: 'BTC-200730-9000-C',
                        price: '100',
                        quantity: '1',
                        executedQty: '0',
                        side: 'BUY',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1592465880683,
                        updateTime: 1592465880683,
                        status: 'NEW',
                        avgPrice: '0',
                        clientOrderId: '',
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCurrentOpenOptionOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOptionOrdersResponse>)
            );
            const response = await client.queryCurrentOpenOptionOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentOpenOptionOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentOpenOptionOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryOptionOrderHistory()', () => {
        it('should execute queryOptionOrderHistory() successfully with required parameters only', async () => {
            const params: QueryOptionOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611922413427360000,
                        symbol: 'BTC-220715-2000-C',
                        price: '18000.00000000',
                        quantity: '-0.50000000',
                        executedQty: '-0.50000000',
                        side: 'SELL',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1657867694244,
                        updateTime: 1657867888216,
                        status: 'FILLED',
                        avgPrice: '18000.00000000',
                        clientOrderId: '',
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryOptionOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOptionOrderHistoryResponse>)
            );
            const response = await client.queryOptionOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryOptionOrderHistory() successfully with optional parameters', async () => {
            const params: QueryOptionOrderHistoryRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        orderId: 4611922413427360000,
                        symbol: 'BTC-220715-2000-C',
                        price: '18000.00000000',
                        quantity: '-0.50000000',
                        executedQty: '-0.50000000',
                        side: 'SELL',
                        type: 'LIMIT',
                        timeInForce: 'GTC',
                        reduceOnly: false,
                        createTime: 1657867694244,
                        updateTime: 1657867888216,
                        status: 'FILLED',
                        avgPrice: '18000.00000000',
                        clientOrderId: '',
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        quoteAsset: 'USDT',
                        mmp: false,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryOptionOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOptionOrderHistoryResponse>)
            );
            const response = await client.queryOptionOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryOptionOrderHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryOptionOrderHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryOptionOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryOptionOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryOptionOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryOptionOrderHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySingleOrder()', () => {
        it('should execute querySingleOrder() successfully with required parameters only', async () => {
            const params: QuerySingleOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 4611875134427365000,
                    symbol: 'BTC-200730-9000-C',
                    price: '100',
                    quantity: '1',
                    executedQty: '0',
                    side: 'BUY',
                    type: 'LIMIT',
                    timeInForce: 'GTC',
                    reduceOnly: false,
                    createTime: 1592465880683,
                    updateTime: 1566818724722,
                    status: 'NEW',
                    avgPrice: '0',
                    clientOrderId: '',
                    priceScale: 2,
                    quantityScale: 2,
                    optionSide: 'CALL',
                    quoteAsset: 'USDT',
                    mmp: false,
                })
            );

            const spy = jest.spyOn(client, 'querySingleOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySingleOrderResponse>)
            );
            const response = await client.querySingleOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySingleOrder() successfully with optional parameters', async () => {
            const params: QuerySingleOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                clientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    orderId: 4611875134427365000,
                    symbol: 'BTC-200730-9000-C',
                    price: '100',
                    quantity: '1',
                    executedQty: '0',
                    side: 'BUY',
                    type: 'LIMIT',
                    timeInForce: 'GTC',
                    reduceOnly: false,
                    createTime: 1592465880683,
                    updateTime: 1566818724722,
                    status: 'NEW',
                    avgPrice: '0',
                    clientOrderId: '',
                    priceScale: 2,
                    quantityScale: 2,
                    optionSide: 'CALL',
                    quoteAsset: 'USDT',
                    mmp: false,
                })
            );

            const spy = jest.spyOn(client, 'querySingleOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySingleOrderResponse>)
            );
            const response = await client.querySingleOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QuerySingleOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.querySingleOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling querySingleOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySingleOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'querySingleOrder').mockRejectedValueOnce(mockError);
            await expect(client.querySingleOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userCommission()', () => {
        it('should execute userCommission() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    commissions: [
                        { underlying: 'BTCUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'ETHUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'BNBUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'SOLUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'XRPUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'DOGEUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'userCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionResponse>)
            );
            const response = await client.userCommission();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userCommission() successfully with optional parameters', async () => {
            const params: UserCommissionRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    commissions: [
                        { underlying: 'BTCUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'ETHUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'BNBUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'SOLUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'XRPUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                        { underlying: 'DOGEUSDT', makerFee: '0.000240', takerFee: '0.000240' },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'userCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionResponse>)
            );
            const response = await client.userCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userCommission').mockRejectedValueOnce(mockError);
            await expect(client.userCommission()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userExerciseRecord()', () => {
        it('should execute userExerciseRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: '1125899906842624042',
                        currency: 'USDT',
                        symbol: 'BTC-220721-25000-C',
                        exercisePrice: '25000.00000000',
                        quantity: '1.00000000',
                        amount: '0.00000000',
                        fee: '0.00000000',
                        createDate: 1658361600000,
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        positionSide: 'LONG',
                        quoteAsset: 'USDT',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'userExerciseRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserExerciseRecordResponse>)
            );
            const response = await client.userExerciseRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userExerciseRecord() successfully with optional parameters', async () => {
            const params: UserExerciseRecordRequest = {
                symbol: 'symbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: '1125899906842624042',
                        currency: 'USDT',
                        symbol: 'BTC-220721-25000-C',
                        exercisePrice: '25000.00000000',
                        quantity: '1.00000000',
                        amount: '0.00000000',
                        fee: '0.00000000',
                        createDate: 1658361600000,
                        priceScale: 2,
                        quantityScale: 2,
                        optionSide: 'CALL',
                        positionSide: 'LONG',
                        quoteAsset: 'USDT',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'userExerciseRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserExerciseRecordResponse>)
            );
            const response = await client.userExerciseRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userExerciseRecord').mockRejectedValueOnce(mockError);
            await expect(client.userExerciseRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
