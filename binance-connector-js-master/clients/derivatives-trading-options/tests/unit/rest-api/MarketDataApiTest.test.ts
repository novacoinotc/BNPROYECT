/**
 * Binance Derivatives Trading Options REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { MarketDataApi } from '../../../src/rest-api';
import {
    HistoricalExerciseRecordsRequest,
    IndexPriceRequest,
    KlineCandlestickDataRequest,
    OpenInterestRequest,
    OptionMarkPriceRequest,
    OrderBookRequest,
    RecentBlockTradesListRequest,
    RecentTradesListRequest,
    Ticker24hrPriceChangeStatisticsRequest,
} from '../../../src/rest-api';
import type {
    CheckServerTimeResponse,
    ExchangeInformationResponse,
    HistoricalExerciseRecordsResponse,
    IndexPriceResponse,
    KlineCandlestickDataResponse,
    OpenInterestResponse,
    OptionMarkPriceResponse,
    OrderBookResponse,
    RecentBlockTradesListResponse,
    RecentTradesListResponse,
    Ticker24hrPriceChangeStatisticsResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('checkServerTime()', () => {
        it('should execute checkServerTime() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ serverTime: 1499827319559 }));

            const spy = jest.spyOn(client, 'checkServerTime').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckServerTimeResponse>)
            );
            const response = await client.checkServerTime();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'checkServerTime').mockRejectedValueOnce(mockError);
            await expect(client.checkServerTime()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('exchangeInformation()', () => {
        it('should execute exchangeInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    timezone: 'UTC',
                    serverTime: 1592387337630,
                    optionContracts: [
                        {
                            baseAsset: 'BTC',
                            quoteAsset: 'USDT',
                            underlying: 'BTCUSDT',
                            settleAsset: 'USDT',
                        },
                    ],
                    optionAssets: [{ name: 'USDT' }],
                    optionSymbols: [
                        {
                            expiryDate: 1660521600000,
                            filters: [
                                {
                                    filterType: 'PRICE_FILTER',
                                    minPrice: '0.02',
                                    maxPrice: '80000.01',
                                    tickSize: '0.01',
                                },
                                {
                                    filterType: 'LOT_SIZE',
                                    minQty: '0.01',
                                    maxQty: '100',
                                    stepSize: '0.01',
                                },
                            ],
                            symbol: 'BTC-220815-50000-C',
                            side: 'CALL',
                            strikePrice: '50000',
                            underlying: 'BTCUSDT',
                            unit: 1,
                            liquidationFeeRate: '0.0019000',
                            minQty: '0.01',
                            maxQty: '100',
                            initialMargin: '0.15',
                            maintenanceMargin: '0.075',
                            minInitialMargin: '0.1',
                            minMaintenanceMargin: '0.05',
                            priceScale: 2,
                            quantityScale: 2,
                            quoteAsset: 'USDT',
                            status: 'TRADING',
                        },
                    ],
                    rateLimits: [
                        {
                            rateLimitType: 'REQUEST_WEIGHT',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 2400,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'MINUTE',
                            intervalNum: 1,
                            limit: 1200,
                        },
                        {
                            rateLimitType: 'ORDERS',
                            interval: 'SECOND',
                            intervalNum: 10,
                            limit: 300,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'exchangeInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInformationResponse>)
            );
            const response = await client.exchangeInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInformation').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('historicalExerciseRecords()', () => {
        it('should execute historicalExerciseRecords() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTC-220121-60000-P',
                        strikePrice: '60000',
                        realStrikePrice: '38844.69652571',
                        expiryDate: 1642752000000,
                        strikeResult: 'REALISTIC_VALUE_STRICKEN',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'historicalExerciseRecords').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalExerciseRecordsResponse>)
            );
            const response = await client.historicalExerciseRecords();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute historicalExerciseRecords() successfully with optional parameters', async () => {
            const params: HistoricalExerciseRecordsRequest = {
                underlying: 'underlying_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTC-220121-60000-P',
                        strikePrice: '60000',
                        realStrikePrice: '38844.69652571',
                        expiryDate: 1642752000000,
                        strikeResult: 'REALISTIC_VALUE_STRICKEN',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'historicalExerciseRecords').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalExerciseRecordsResponse>)
            );
            const response = await client.historicalExerciseRecords(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'historicalExerciseRecords')
                .mockRejectedValueOnce(mockError);
            await expect(client.historicalExerciseRecords()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexPrice()', () => {
        it('should execute indexPrice() successfully with required parameters only', async () => {
            const params: IndexPriceRequest = {
                underlying: 'underlying_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ time: 1656647305000, indexPrice: '105917.75' })
            );

            const spy = jest.spyOn(client, 'indexPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceResponse>)
            );
            const response = await client.indexPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPrice() successfully with optional parameters', async () => {
            const params: IndexPriceRequest = {
                underlying: 'underlying_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ time: 1656647305000, indexPrice: '105917.75' })
            );

            const spy = jest.spyOn(client, 'indexPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceResponse>)
            );
            const response = await client.indexPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when underlying is missing', async () => {
            const _params: IndexPriceRequest = {
                underlying: 'underlying_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.underlying;

            await expect(client.indexPrice(params)).rejects.toThrow(
                'Required parameter underlying was null or undefined when calling indexPrice.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexPriceRequest = {
                underlying: 'underlying_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'indexPrice').mockRejectedValueOnce(mockError);
            await expect(client.indexPrice(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('klineCandlestickData()', () => {
        it('should execute klineCandlestickData() successfully with required parameters only', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1762779600000,
                        '1300.000',
                        '1300.000',
                        '1300.000',
                        '1300.000',
                        '0.1000',
                        1762780499999,
                        '130.0000000',
                        1,
                        '0.1000',
                        '130.0000000',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klineCandlestickData() successfully with optional parameters', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    [
                        1762779600000,
                        '1300.000',
                        '1300.000',
                        '1300.000',
                        '1300.000',
                        '0.1000',
                        1762780499999,
                        '130.0000000',
                        1,
                        '0.1000',
                        '130.0000000',
                        '0',
                    ],
                ])
            );

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klineCandlestickData').mockRejectedValueOnce(mockError);
            await expect(client.klineCandlestickData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterest()', () => {
        it('should execute openInterest() successfully with required parameters only', async () => {
            const params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ETH-221119-1175-P',
                        sumOpenInterest: '4.01',
                        sumOpenInterestUsd: '4880.2985615624',
                        timestamp: '1668754020000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterest() successfully with optional parameters', async () => {
            const params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'ETH-221119-1175-P',
                        sumOpenInterest: '4.01',
                        sumOpenInterestUsd: '4880.2985615624',
                        timestamp: '1668754020000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when underlyingAsset is missing', async () => {
            const _params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.underlyingAsset;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter underlyingAsset was null or undefined when calling openInterest.'
            );
        });

        it('should throw RequiredError when expiration is missing', async () => {
            const _params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.expiration;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter expiration was null or undefined when calling openInterest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openInterest').mockRejectedValueOnce(mockError);
            await expect(client.openInterest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('optionMarkPrice()', () => {
        it('should execute optionMarkPrice() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTC-200730-9000-C',
                        markPrice: '1343.2883',
                        bidIV: '1.40000077',
                        askIV: '1.50000153',
                        markIV: '1.45000000',
                        delta: '0.55937056',
                        theta: '3739.82509871',
                        gamma: '0.00010969',
                        vega: '978.58874732',
                        highPriceLimit: '1618.241',
                        lowPriceLimit: '1068.3356',
                        riskFreeInterest: '0.1',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'optionMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OptionMarkPriceResponse>)
            );
            const response = await client.optionMarkPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute optionMarkPrice() successfully with optional parameters', async () => {
            const params: OptionMarkPriceRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTC-200730-9000-C',
                        markPrice: '1343.2883',
                        bidIV: '1.40000077',
                        askIV: '1.50000153',
                        markIV: '1.45000000',
                        delta: '0.55937056',
                        theta: '3739.82509871',
                        gamma: '0.00010969',
                        vega: '978.58874732',
                        highPriceLimit: '1618.241',
                        lowPriceLimit: '1068.3356',
                        riskFreeInterest: '0.1',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'optionMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OptionMarkPriceResponse>)
            );
            const response = await client.optionMarkPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'optionMarkPrice').mockRejectedValueOnce(mockError);
            await expect(client.optionMarkPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderBook()', () => {
        it('should execute orderBook() successfully with required parameters only', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    bids: [['1000.000', '0.1000']],
                    asks: [['1900.000', '0.1000']],
                    T: 1762780909676,
                    lastUpdateId: 361,
                })
            );

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderBook() successfully with optional parameters', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    bids: [['1000.000', '0.1000']],
                    asks: [['1900.000', '0.1000']],
                    T: 1762780909676,
                    lastUpdateId: 361,
                })
            );

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderBook').mockRejectedValueOnce(mockError);
            await expect(client.orderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('recentBlockTradesList()', () => {
        it('should execute recentBlockTradesList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 1125899906901081100,
                        tradeId: 389,
                        symbol: 'ETH-250725-1200-P',
                        price: '342.40',
                        qty: '-2167.20',
                        quoteQty: '-4.90',
                        side: -1,
                        time: 1733950676483,
                    },
                    {
                        id: 1125899906901081000,
                        tradeId: 161,
                        symbol: 'XRP-250904-0.086-P',
                        price: '3.0',
                        qty: '-6.0',
                        quoteQty: '-2.02',
                        side: -1,
                        time: 1733950488444,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentBlockTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentBlockTradesListResponse>)
            );
            const response = await client.recentBlockTradesList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentBlockTradesList() successfully with optional parameters', async () => {
            const params: RecentBlockTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 1125899906901081100,
                        tradeId: 389,
                        symbol: 'ETH-250725-1200-P',
                        price: '342.40',
                        qty: '-2167.20',
                        quoteQty: '-4.90',
                        side: -1,
                        time: 1733950676483,
                    },
                    {
                        id: 1125899906901081000,
                        tradeId: 161,
                        symbol: 'XRP-250904-0.086-P',
                        price: '3.0',
                        qty: '-6.0',
                        quoteQty: '-2.02',
                        side: -1,
                        time: 1733950488444,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentBlockTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentBlockTradesListResponse>)
            );
            const response = await client.recentBlockTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'recentBlockTradesList')
                .mockRejectedValueOnce(mockError);
            await expect(client.recentBlockTradesList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('recentTradesList()', () => {
        it('should execute recentTradesList() successfully with required parameters only', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 2323857420768529000,
                        tradeId: 1,
                        symbol: 'BTC-251123-126000-C',
                        price: '1300',
                        qty: '0.1',
                        quoteQty: '130',
                        side: -1,
                        time: 1762780453623,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentTradesList() successfully with optional parameters', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 2323857420768529000,
                        tradeId: 1,
                        symbol: 'BTC-251123-126000-C',
                        price: '1300',
                        qty: '0.1',
                        quoteQty: '130',
                        side: -1,
                        time: 1762780453623,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.recentTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling recentTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'recentTradesList').mockRejectedValueOnce(mockError);
            await expect(client.recentTradesList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testConnectivity()', () => {
        it('should execute testConnectivity() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'testConnectivity').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.testConnectivity();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testConnectivity').mockRejectedValueOnce(mockError);
            await expect(client.testConnectivity()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hrPriceChangeStatistics()', () => {
        it('should execute ticker24hrPriceChangeStatistics() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTC-200730-9000-C',
                        priceChange: '-16.2038',
                        priceChangePercent: '-0.0162',
                        lastPrice: '1000',
                        lastQty: '1000',
                        open: '1016.2038',
                        high: '1016.2038',
                        low: '0',
                        volume: '5',
                        amount: '1',
                        bidPrice: '999.34',
                        askPrice: '1000.23',
                        openTime: 1592317127349,
                        closeTime: 1592380593516,
                        firstTradeId: 1,
                        tradeCount: 5,
                        strikePrice: '9000',
                        exercisePrice: '3000.3356',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hrPriceChangeStatistics() successfully with optional parameters', async () => {
            const params: Ticker24hrPriceChangeStatisticsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        symbol: 'BTC-200730-9000-C',
                        priceChange: '-16.2038',
                        priceChangePercent: '-0.0162',
                        lastPrice: '1000',
                        lastQty: '1000',
                        open: '1016.2038',
                        high: '1016.2038',
                        low: '0',
                        volume: '5',
                        amount: '1',
                        bidPrice: '999.34',
                        askPrice: '1000.23',
                        openTime: 1592317127349,
                        closeTime: 1592380593516,
                        firstTradeId: 1,
                        tradeCount: 5,
                        strikePrice: '9000',
                        exercisePrice: '3000.3356',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'ticker24hrPriceChangeStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.ticker24hrPriceChangeStatistics()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
