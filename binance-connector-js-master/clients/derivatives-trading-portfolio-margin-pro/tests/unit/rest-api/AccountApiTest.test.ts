/**
 * Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    BnbTransferRequest,
    ChangeAutoRepayFuturesStatusRequest,
    FundAutoCollectionRequest,
    FundCollectionByAssetRequest,
    GetAutoRepayFuturesStatusRequest,
    GetDeltaModeStatusRequest,
    GetPortfolioMarginProAccountBalanceRequest,
    GetPortfolioMarginProAccountInfoRequest,
    GetPortfolioMarginProSpanAccountInfoRequest,
    GetTransferableEarnAssetBalanceForPortfolioMarginRequest,
    PortfolioMarginProBankruptcyLoanRepayRequest,
    QueryPortfolioMarginProBankruptcyLoanAmountRequest,
    QueryPortfolioMarginProBankruptcyLoanRepayHistoryRequest,
    QueryPortfolioMarginProNegativeBalanceInterestHistoryRequest,
    RepayFuturesNegativeBalanceRequest,
    SwitchDeltaModeRequest,
    TransferLdusdtRwusdForPortfolioMarginRequest,
} from '../../../src/rest-api';
import type {
    BnbTransferResponse,
    ChangeAutoRepayFuturesStatusResponse,
    FundAutoCollectionResponse,
    FundCollectionByAssetResponse,
    GetAutoRepayFuturesStatusResponse,
    GetDeltaModeStatusResponse,
    GetPortfolioMarginProAccountBalanceResponse,
    GetPortfolioMarginProAccountInfoResponse,
    GetPortfolioMarginProSpanAccountInfoResponse,
    GetTransferableEarnAssetBalanceForPortfolioMarginResponse,
    PortfolioMarginProBankruptcyLoanRepayResponse,
    QueryPortfolioMarginProBankruptcyLoanAmountResponse,
    QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse,
    QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse,
    RepayFuturesNegativeBalanceResponse,
    SwitchDeltaModeResponse,
    TransferLdusdtRwusdForPortfolioMarginResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('bnbTransfer()', () => {
        it('should execute bnbTransfer() successfully with required parameters only', async () => {
            const params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 100000001 }));

            const spy = jest.spyOn(client, 'bnbTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BnbTransferResponse>)
            );
            const response = await client.bnbTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute bnbTransfer() successfully with optional parameters', async () => {
            const params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 100000001 }));

            const spy = jest.spyOn(client, 'bnbTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BnbTransferResponse>)
            );
            const response = await client.bnbTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.bnbTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling bnbTransfer.'
            );
        });

        it('should throw RequiredError when transferSide is missing', async () => {
            const _params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.transferSide;

            await expect(client.bnbTransfer(params)).rejects.toThrow(
                'Required parameter transferSide was null or undefined when calling bnbTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BnbTransferRequest = {
                amount: 1.0,
                transferSide: 'transferSide_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'bnbTransfer').mockRejectedValueOnce(mockError);
            await expect(client.bnbTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeAutoRepayFuturesStatus()', () => {
        it('should execute changeAutoRepayFuturesStatus() successfully with required parameters only', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'changeAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeAutoRepayFuturesStatusResponse>)
            );
            const response = await client.changeAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeAutoRepayFuturesStatus() successfully with optional parameters', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'changeAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeAutoRepayFuturesStatusResponse>)
            );
            const response = await client.changeAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when autoRepay is missing', async () => {
            const _params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
            };
            const params = Object.assign({ ..._params });
            delete params?.autoRepay;

            await expect(client.changeAutoRepayFuturesStatus(params)).rejects.toThrow(
                'Required parameter autoRepay was null or undefined when calling changeAutoRepayFuturesStatus.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: 'true',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeAutoRepayFuturesStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeAutoRepayFuturesStatus(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('fundAutoCollection()', () => {
        it('should execute fundAutoCollection() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundAutoCollection').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundAutoCollectionResponse>)
            );
            const response = await client.fundAutoCollection();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundAutoCollection() successfully with optional parameters', async () => {
            const params: FundAutoCollectionRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundAutoCollection').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundAutoCollectionResponse>)
            );
            const response = await client.fundAutoCollection(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fundAutoCollection').mockRejectedValueOnce(mockError);
            await expect(client.fundAutoCollection()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fundCollectionByAsset()', () => {
        it('should execute fundCollectionByAsset() successfully with required parameters only', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundCollectionByAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundCollectionByAssetResponse>)
            );
            const response = await client.fundCollectionByAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundCollectionByAsset() successfully with optional parameters', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'fundCollectionByAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundCollectionByAssetResponse>)
            );
            const response = await client.fundCollectionByAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.fundCollectionByAsset(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling fundCollectionByAsset.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fundCollectionByAsset')
                .mockRejectedValueOnce(mockError);
            await expect(client.fundCollectionByAsset(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAutoRepayFuturesStatus()', () => {
        it('should execute getAutoRepayFuturesStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ autoRepay: true }));

            const spy = jest.spyOn(client, 'getAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAutoRepayFuturesStatusResponse>)
            );
            const response = await client.getAutoRepayFuturesStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAutoRepayFuturesStatus() successfully with optional parameters', async () => {
            const params: GetAutoRepayFuturesStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ autoRepay: true }));

            const spy = jest.spyOn(client, 'getAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAutoRepayFuturesStatusResponse>)
            );
            const response = await client.getAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getAutoRepayFuturesStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.getAutoRepayFuturesStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getDeltaModeStatus()', () => {
        it('should execute getDeltaModeStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ deltaEnabled: false }));

            const spy = jest.spyOn(client, 'getDeltaModeStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDeltaModeStatusResponse>)
            );
            const response = await client.getDeltaModeStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDeltaModeStatus() successfully with optional parameters', async () => {
            const params: GetDeltaModeStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ deltaEnabled: false }));

            const spy = jest.spyOn(client, 'getDeltaModeStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDeltaModeStatusResponse>)
            );
            const response = await client.getDeltaModeStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getDeltaModeStatus').mockRejectedValueOnce(mockError);
            await expect(client.getDeltaModeStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getPortfolioMarginProAccountBalance()', () => {
        it('should execute getPortfolioMarginProAccountBalance() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'BTC',
                        totalWalletBalance: '100',
                        crossMarginAsset: '100',
                        crossMarginBorrowed: '0',
                        crossMarginFree: '100',
                        crossMarginInterest: '0',
                        crossMarginLocked: '0',
                        umWalletBalance: '0',
                        umUnrealizedPNL: '0',
                        cmWalletBalance: '0',
                        cmUnrealizedPNL: '0',
                        updateTime: 0,
                        negativeBalance: '0',
                        optionWalletBalance: '0',
                        optionEquity: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountBalanceResponse>)
            );
            const response = await client.getPortfolioMarginProAccountBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPortfolioMarginProAccountBalance() successfully with optional parameters', async () => {
            const params: GetPortfolioMarginProAccountBalanceRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'BTC',
                        totalWalletBalance: '100',
                        crossMarginAsset: '100',
                        crossMarginBorrowed: '0',
                        crossMarginFree: '100',
                        crossMarginInterest: '0',
                        crossMarginLocked: '0',
                        umWalletBalance: '0',
                        umUnrealizedPNL: '0',
                        cmWalletBalance: '0',
                        cmUnrealizedPNL: '0',
                        updateTime: 0,
                        negativeBalance: '0',
                        optionWalletBalance: '0',
                        optionEquity: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountBalanceResponse>)
            );
            const response = await client.getPortfolioMarginProAccountBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginProAccountBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginProAccountBalance()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getPortfolioMarginProAccountInfo()', () => {
        it('should execute getPortfolioMarginProAccountInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    uniMMR: '5167.92171923',
                    accountEquity: '122607.35137903',
                    actualEquity: '142607.35137903',
                    accountMaintMargin: '23.72469206',
                    accountInitialMargin: '47.44938412',
                    totalAvailableBalance: '122,559.90199491',
                    accountStatus: 'NORMAL',
                    accountType: 'PM_1',
                })
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProAccountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPortfolioMarginProAccountInfo() successfully with optional parameters', async () => {
            const params: GetPortfolioMarginProAccountInfoRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    uniMMR: '5167.92171923',
                    accountEquity: '122607.35137903',
                    actualEquity: '142607.35137903',
                    accountMaintMargin: '23.72469206',
                    accountInitialMargin: '47.44938412',
                    totalAvailableBalance: '122,559.90199491',
                    accountStatus: 'NORMAL',
                    accountType: 'PM_1',
                })
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProAccountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginProAccountInfo')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginProAccountInfo()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getPortfolioMarginProSpanAccountInfo()', () => {
        it('should execute getPortfolioMarginProSpanAccountInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    uniMMR: '5167.92171923',
                    accountEquity: '122607.35137903',
                    actualEquity: '142607.35137903',
                    accountMaintMargin: '23.72469206',
                    riskUnitMMList: [{ asset: 'BTC', uniMaintainUsd: '23.72469206' }],
                    marginMM: '0.00000000',
                    otherMM: '0.00000000',
                    accountStatus: 'NORMAL',
                    accountType: 'PM_3',
                })
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginProSpanAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProSpanAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProSpanAccountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPortfolioMarginProSpanAccountInfo() successfully with optional parameters', async () => {
            const params: GetPortfolioMarginProSpanAccountInfoRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    uniMMR: '5167.92171923',
                    accountEquity: '122607.35137903',
                    actualEquity: '142607.35137903',
                    accountMaintMargin: '23.72469206',
                    riskUnitMMList: [{ asset: 'BTC', uniMaintainUsd: '23.72469206' }],
                    marginMM: '0.00000000',
                    otherMM: '0.00000000',
                    accountStatus: 'NORMAL',
                    accountType: 'PM_3',
                })
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginProSpanAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProSpanAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProSpanAccountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginProSpanAccountInfo')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginProSpanAccountInfo()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getTransferableEarnAssetBalanceForPortfolioMargin()', () => {
        it('should execute getTransferableEarnAssetBalanceForPortfolioMargin() successfully with required parameters only', async () => {
            const params: GetTransferableEarnAssetBalanceForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
            };

            mockResponse = JSONParse(JSONStringify({ asset: 'LDUSDT', amount: '0.55' }));

            const spy = jest
                .spyOn(client, 'getTransferableEarnAssetBalanceForPortfolioMargin')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetTransferableEarnAssetBalanceForPortfolioMarginResponse>)
                );
            const response = await client.getTransferableEarnAssetBalanceForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getTransferableEarnAssetBalanceForPortfolioMargin() successfully with optional parameters', async () => {
            const params: GetTransferableEarnAssetBalanceForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ asset: 'LDUSDT', amount: '0.55' }));

            const spy = jest
                .spyOn(client, 'getTransferableEarnAssetBalanceForPortfolioMargin')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetTransferableEarnAssetBalanceForPortfolioMarginResponse>)
                );
            const response = await client.getTransferableEarnAssetBalanceForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: GetTransferableEarnAssetBalanceForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(
                client.getTransferableEarnAssetBalanceForPortfolioMargin(params)
            ).rejects.toThrow(
                'Required parameter asset was null or undefined when calling getTransferableEarnAssetBalanceForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when transferType is missing', async () => {
            const _params: GetTransferableEarnAssetBalanceForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.transferType;

            await expect(
                client.getTransferableEarnAssetBalanceForPortfolioMargin(params)
            ).rejects.toThrow(
                'Required parameter transferType was null or undefined when calling getTransferableEarnAssetBalanceForPortfolioMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetTransferableEarnAssetBalanceForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getTransferableEarnAssetBalanceForPortfolioMargin')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.getTransferableEarnAssetBalanceForPortfolioMargin(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('portfolioMarginProBankruptcyLoanRepay()', () => {
        it('should execute portfolioMarginProBankruptcyLoanRepay() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ tranId: 58203331886213500 }));

            const spy = jest.spyOn(client, 'portfolioMarginProBankruptcyLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PortfolioMarginProBankruptcyLoanRepayResponse>)
            );
            const response = await client.portfolioMarginProBankruptcyLoanRepay();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute portfolioMarginProBankruptcyLoanRepay() successfully with optional parameters', async () => {
            const params: PortfolioMarginProBankruptcyLoanRepayRequest = {
                from: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 58203331886213500 }));

            const spy = jest.spyOn(client, 'portfolioMarginProBankruptcyLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PortfolioMarginProBankruptcyLoanRepayResponse>)
            );
            const response = await client.portfolioMarginProBankruptcyLoanRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'portfolioMarginProBankruptcyLoanRepay')
                .mockRejectedValueOnce(mockError);
            await expect(client.portfolioMarginProBankruptcyLoanRepay()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginProBankruptcyLoanAmount()', () => {
        it('should execute queryPortfolioMarginProBankruptcyLoanAmount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ asset: 'BUSD', amount: '579.45' }));

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanAmount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanAmountResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanAmount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginProBankruptcyLoanAmount() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginProBankruptcyLoanAmountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ asset: 'BUSD', amount: '579.45' }));

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanAmount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanAmountResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanAmount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanAmount')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryPortfolioMarginProBankruptcyLoanAmount()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginProBankruptcyLoanRepayHistory()', () => {
        it('should execute queryPortfolioMarginProBankruptcyLoanRepayHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    total: 3,
                    rows: [
                        { asset: 'USDT', amount: '404.80294503', repayTime: 1731336427804 },
                        { asset: 'USDT', amount: '4620.41204574', repayTime: 1726125090016 },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanRepayHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanRepayHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginProBankruptcyLoanRepayHistory() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginProBankruptcyLoanRepayHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 3,
                    rows: [
                        { asset: 'USDT', amount: '404.80294503', repayTime: 1731336427804 },
                        { asset: 'USDT', amount: '4620.41204574', repayTime: 1726125090016 },
                    ],
                })
            );

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanRepayHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanRepayHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanRepayHistory')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryPortfolioMarginProBankruptcyLoanRepayHistory()
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginProNegativeBalanceInterestHistory()', () => {
        it('should execute queryPortfolioMarginProNegativeBalanceInterestHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        interest: '24.4440',
                        interestAccruedTime: 1670227200000,
                        interestRate: '0.0001164',
                        principal: '210000',
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProNegativeBalanceInterestHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginProNegativeBalanceInterestHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginProNegativeBalanceInterestHistory() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginProNegativeBalanceInterestHistoryRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        interest: '24.4440',
                        interestAccruedTime: 1670227200000,
                        interestRate: '0.0001164',
                        principal: '210000',
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProNegativeBalanceInterestHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse>)
                );
            const response =
                await client.queryPortfolioMarginProNegativeBalanceInterestHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProNegativeBalanceInterestHistory')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryPortfolioMarginProNegativeBalanceInterestHistory()
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('repayFuturesNegativeBalance()', () => {
        it('should execute repayFuturesNegativeBalance() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'repayFuturesNegativeBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RepayFuturesNegativeBalanceResponse>)
            );
            const response = await client.repayFuturesNegativeBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute repayFuturesNegativeBalance() successfully with optional parameters', async () => {
            const params: RepayFuturesNegativeBalanceRequest = {
                from: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'repayFuturesNegativeBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RepayFuturesNegativeBalanceResponse>)
            );
            const response = await client.repayFuturesNegativeBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'repayFuturesNegativeBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.repayFuturesNegativeBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('switchDeltaMode()', () => {
        it('should execute switchDeltaMode() successfully with required parameters only', async () => {
            const params: SwitchDeltaModeRequest = {
                deltaEnabled: 'deltaEnabled_example',
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'switchDeltaMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SwitchDeltaModeResponse>)
            );
            const response = await client.switchDeltaMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute switchDeltaMode() successfully with optional parameters', async () => {
            const params: SwitchDeltaModeRequest = {
                deltaEnabled: 'deltaEnabled_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'switchDeltaMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SwitchDeltaModeResponse>)
            );
            const response = await client.switchDeltaMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when deltaEnabled is missing', async () => {
            const _params: SwitchDeltaModeRequest = {
                deltaEnabled: 'deltaEnabled_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.deltaEnabled;

            await expect(client.switchDeltaMode(params)).rejects.toThrow(
                'Required parameter deltaEnabled was null or undefined when calling switchDeltaMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SwitchDeltaModeRequest = {
                deltaEnabled: 'deltaEnabled_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'switchDeltaMode').mockRejectedValueOnce(mockError);
            await expect(client.switchDeltaMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('transferLdusdtRwusdForPortfolioMargin()', () => {
        it('should execute transferLdusdtRwusdForPortfolioMargin() successfully with required parameters only', async () => {
            const params: TransferLdusdtRwusdForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'transferLdusdtRwusdForPortfolioMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferLdusdtRwusdForPortfolioMarginResponse>)
            );
            const response = await client.transferLdusdtRwusdForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute transferLdusdtRwusdForPortfolioMargin() successfully with optional parameters', async () => {
            const params: TransferLdusdtRwusdForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ msg: 'success' }));

            const spy = jest.spyOn(client, 'transferLdusdtRwusdForPortfolioMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferLdusdtRwusdForPortfolioMarginResponse>)
            );
            const response = await client.transferLdusdtRwusdForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: TransferLdusdtRwusdForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.transferLdusdtRwusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling transferLdusdtRwusdForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when transferType is missing', async () => {
            const _params: TransferLdusdtRwusdForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.transferType;

            await expect(client.transferLdusdtRwusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter transferType was null or undefined when calling transferLdusdtRwusdForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: TransferLdusdtRwusdForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.transferLdusdtRwusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling transferLdusdtRwusdForPortfolioMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TransferLdusdtRwusdForPortfolioMarginRequest = {
                asset: 'asset_example',
                transferType: 'transferType_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'transferLdusdtRwusdForPortfolioMargin')
                .mockRejectedValueOnce(mockError);
            await expect(client.transferLdusdtRwusdForPortfolioMargin(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
