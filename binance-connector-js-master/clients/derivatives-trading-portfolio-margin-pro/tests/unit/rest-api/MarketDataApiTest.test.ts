/**
 * Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { MarketDataApi } from '../../../src/rest-api';
import {
    PortfolioMarginProTieredCollateralRateRequest,
    QueryPortfolioMarginAssetIndexPriceRequest,
} from '../../../src/rest-api';
import type {
    GetPortfolioMarginAssetLeverageResponse,
    PortfolioMarginCollateralRateResponse,
    PortfolioMarginProTieredCollateralRateResponse,
    QueryPortfolioMarginAssetIndexPriceResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('getPortfolioMarginAssetLeverage()', () => {
        it('should execute getPortfolioMarginAssetLeverage() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { asset: 'USDC', leverage: 10 },
                    { asset: 'USDT', leverage: 10 },
                ])
            );

            const spy = jest.spyOn(client, 'getPortfolioMarginAssetLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginAssetLeverageResponse>)
            );
            const response = await client.getPortfolioMarginAssetLeverage();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginAssetLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginAssetLeverage()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('portfolioMarginCollateralRate()', () => {
        it('should execute portfolioMarginCollateralRate() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { asset: 'USDC', collateralRate: '1.0000' },
                    { asset: 'BUSD', collateralRate: '1.0000' },
                ])
            );

            const spy = jest.spyOn(client, 'portfolioMarginCollateralRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PortfolioMarginCollateralRateResponse>)
            );
            const response = await client.portfolioMarginCollateralRate();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'portfolioMarginCollateralRate')
                .mockRejectedValueOnce(mockError);
            await expect(client.portfolioMarginCollateralRate()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('portfolioMarginProTieredCollateralRate()', () => {
        it('should execute portfolioMarginProTieredCollateralRate() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'BNB',
                        collateralInfo: [
                            {
                                tierFloor: '0.0000',
                                tierCap: '1000.0000',
                                collateralRate: '1.0000',
                                cum: '0.0000',
                            },
                            {
                                tierFloor: '1000.0000',
                                tierCap: '2000.0000',
                                collateralRate: '0.9000',
                                cum: '0.0000',
                            },
                        ],
                    },
                    {
                        asset: 'USDT',
                        collateralInfo: [
                            {
                                tierFloor: '0.0000',
                                tierCap: '1000.0000',
                                collateralRate: '1.0000',
                                cum: '0.0000',
                            },
                            {
                                tierFloor: '1000.0000',
                                tierCap: '2000.0000',
                                collateralRate: '0.9999',
                                cum: '0.0000',
                            },
                        ],
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'portfolioMarginProTieredCollateralRate')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<PortfolioMarginProTieredCollateralRateResponse>)
                );
            const response = await client.portfolioMarginProTieredCollateralRate();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute portfolioMarginProTieredCollateralRate() successfully with optional parameters', async () => {
            const params: PortfolioMarginProTieredCollateralRateRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'BNB',
                        collateralInfo: [
                            {
                                tierFloor: '0.0000',
                                tierCap: '1000.0000',
                                collateralRate: '1.0000',
                                cum: '0.0000',
                            },
                            {
                                tierFloor: '1000.0000',
                                tierCap: '2000.0000',
                                collateralRate: '0.9000',
                                cum: '0.0000',
                            },
                        ],
                    },
                    {
                        asset: 'USDT',
                        collateralInfo: [
                            {
                                tierFloor: '0.0000',
                                tierCap: '1000.0000',
                                collateralRate: '1.0000',
                                cum: '0.0000',
                            },
                            {
                                tierFloor: '1000.0000',
                                tierCap: '2000.0000',
                                collateralRate: '0.9999',
                                cum: '0.0000',
                            },
                        ],
                    },
                ])
            );

            const spy = jest
                .spyOn(client, 'portfolioMarginProTieredCollateralRate')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<PortfolioMarginProTieredCollateralRateResponse>)
                );
            const response = await client.portfolioMarginProTieredCollateralRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'portfolioMarginProTieredCollateralRate')
                .mockRejectedValueOnce(mockError);
            await expect(client.portfolioMarginProTieredCollateralRate()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginAssetIndexPrice()', () => {
        it('should execute queryPortfolioMarginAssetIndexPrice() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { asset: 'BTC', assetIndexPrice: '28251.9136906', time: 1683518338121 },
                ])
            );

            const spy = jest.spyOn(client, 'queryPortfolioMarginAssetIndexPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryPortfolioMarginAssetIndexPriceResponse>)
            );
            const response = await client.queryPortfolioMarginAssetIndexPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginAssetIndexPrice() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginAssetIndexPriceRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { asset: 'BTC', assetIndexPrice: '28251.9136906', time: 1683518338121 },
                ])
            );

            const spy = jest.spyOn(client, 'queryPortfolioMarginAssetIndexPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryPortfolioMarginAssetIndexPriceResponse>)
            );
            const response = await client.queryPortfolioMarginAssetIndexPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginAssetIndexPrice')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryPortfolioMarginAssetIndexPrice()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
