/**
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { SolStakingApi } from '../../../src/rest-api';
import {
    ClaimBoostRewardsRequest,
    GetBnsolRateHistoryRequest,
    GetBnsolRewardsHistoryRequest,
    GetBoostRewardsHistoryRequest,
    GetSolRedemptionHistoryRequest,
    GetSolStakingHistoryRequest,
    GetSolStakingQuotaDetailsRequest,
    GetUnclaimedRewardsRequest,
    RedeemSolRequest,
    SolStakingAccountRequest,
    SubscribeSolStakingRequest,
} from '../../../src/rest-api';
import type {
    ClaimBoostRewardsResponse,
    GetBnsolRateHistoryResponse,
    GetBnsolRewardsHistoryResponse,
    GetBoostRewardsHistoryResponse,
    GetSolRedemptionHistoryResponse,
    GetSolStakingHistoryResponse,
    GetSolStakingQuotaDetailsResponse,
    GetUnclaimedRewardsResponse,
    RedeemSolResponse,
    SolStakingAccountResponse,
    SubscribeSolStakingResponse,
} from '../../../src/rest-api/types';

describe('SolStakingApi', () => {
    let client: SolStakingApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new SolStakingApi(config);
    });

    describe('claimBoostRewards()', () => {
        it('should execute claimBoostRewards() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'claimBoostRewards').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ClaimBoostRewardsResponse>)
            );
            const response = await client.claimBoostRewards();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute claimBoostRewards() successfully with optional parameters', async () => {
            const params: ClaimBoostRewardsRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'claimBoostRewards').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ClaimBoostRewardsResponse>)
            );
            const response = await client.claimBoostRewards(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'claimBoostRewards').mockRejectedValueOnce(mockError);
            await expect(client.claimBoostRewards()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getBnsolRateHistory()', () => {
        it('should execute getBnsolRateHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            annualPercentageRate: '0.00006408',
                            exchangeRate: '1.001212343432',
                            boostRewards: [
                                { boostAPR: '0.12000000', rewardsAsset: 'SOL' },
                                { boostAPR: '0.00200000', rewardsAsset: 'BNB' },
                            ],
                            time: 1577233578000,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getBnsolRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnsolRateHistoryResponse>)
            );
            const response = await client.getBnsolRateHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBnsolRateHistory() successfully with optional parameters', async () => {
            const params: GetBnsolRateHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            annualPercentageRate: '0.00006408',
                            exchangeRate: '1.001212343432',
                            boostRewards: [
                                { boostAPR: '0.12000000', rewardsAsset: 'SOL' },
                                { boostAPR: '0.00200000', rewardsAsset: 'BNB' },
                            ],
                            time: 1577233578000,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getBnsolRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnsolRateHistoryResponse>)
            );
            const response = await client.getBnsolRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getBnsolRateHistory').mockRejectedValueOnce(mockError);
            await expect(client.getBnsolRateHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getBnsolRewardsHistory()', () => {
        it('should execute getBnsolRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    estRewardsInSOL: '1.23230920',
                    rows: [
                        {
                            time: 1575018510000,
                            amountInSOL: '0.23223',
                            holding: '2.3223',
                            holdingInSOL: '2.4231',
                            annualPercentageRate: '0.5',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getBnsolRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnsolRewardsHistoryResponse>)
            );
            const response = await client.getBnsolRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBnsolRewardsHistory() successfully with optional parameters', async () => {
            const params: GetBnsolRewardsHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    estRewardsInSOL: '1.23230920',
                    rows: [
                        {
                            time: 1575018510000,
                            amountInSOL: '0.23223',
                            holding: '2.3223',
                            holdingInSOL: '2.4231',
                            annualPercentageRate: '0.5',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getBnsolRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnsolRewardsHistoryResponse>)
            );
            const response = await client.getBnsolRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getBnsolRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getBnsolRewardsHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getBoostRewardsHistory()', () => {
        it('should execute getBoostRewardsHistory() successfully with required parameters only', async () => {
            const params: GetBoostRewardsHistoryRequest = {
                type: 'CLAIM',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1729520680,
                            token: 'SOL',
                            amount: '1.20291028',
                            bnsolHolding: '2.0928798',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getBoostRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBoostRewardsHistoryResponse>)
            );
            const response = await client.getBoostRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBoostRewardsHistory() successfully with optional parameters', async () => {
            const params: GetBoostRewardsHistoryRequest = {
                type: 'CLAIM',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1729520680,
                            token: 'SOL',
                            amount: '1.20291028',
                            bnsolHolding: '2.0928798',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getBoostRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBoostRewardsHistoryResponse>)
            );
            const response = await client.getBoostRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: GetBoostRewardsHistoryRequest = {
                type: 'CLAIM',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.getBoostRewardsHistory(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling getBoostRewardsHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetBoostRewardsHistoryRequest = {
                type: 'CLAIM',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getBoostRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getBoostRewardsHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSolRedemptionHistory()', () => {
        it('should execute getSolRedemptionHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            arrivalTime: 1575018510000,
                            asset: 'BNSOL',
                            amount: '21312.23223',
                            distributeAsset: 'SOL',
                            distributeAmount: '21338.0699',
                            exchangeRate: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSolRedemptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSolRedemptionHistoryResponse>)
            );
            const response = await client.getSolRedemptionHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSolRedemptionHistory() successfully with optional parameters', async () => {
            const params: GetSolRedemptionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            arrivalTime: 1575018510000,
                            asset: 'BNSOL',
                            amount: '21312.23223',
                            distributeAsset: 'SOL',
                            distributeAmount: '21338.0699',
                            exchangeRate: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSolRedemptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSolRedemptionHistoryResponse>)
            );
            const response = await client.getSolRedemptionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSolRedemptionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSolRedemptionHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSolStakingHistory()', () => {
        it('should execute getSolStakingHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'SOL',
                            amount: '21312.23223',
                            distributeAsset: 'BNSOL',
                            distributeAmount: '21286.42584',
                            exchangeRate: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSolStakingHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSolStakingHistoryResponse>)
            );
            const response = await client.getSolStakingHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSolStakingHistory() successfully with optional parameters', async () => {
            const params: GetSolStakingHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'SOL',
                            amount: '21312.23223',
                            distributeAsset: 'BNSOL',
                            distributeAmount: '21286.42584',
                            exchangeRate: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSolStakingHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSolStakingHistoryResponse>)
            );
            const response = await client.getSolStakingHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getSolStakingHistory').mockRejectedValueOnce(mockError);
            await expect(client.getSolStakingHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSolStakingQuotaDetails()', () => {
        it('should execute getSolStakingQuotaDetails() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    leftStakingPersonalQuota: '1000',
                    leftRedemptionPersonalQuota: '1000',
                    minStakeAmount: '0.01000000',
                    minRedeemAmount: '0.00000001',
                    redeemPeriod: 4,
                    stakeable: true,
                    redeemable: true,
                    soldOut: false,
                    commissionFee: '0.25000000',
                    nextEpochTime: 725993969475,
                    calculating: false,
                })
            );

            const spy = jest.spyOn(client, 'getSolStakingQuotaDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSolStakingQuotaDetailsResponse>)
            );
            const response = await client.getSolStakingQuotaDetails();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSolStakingQuotaDetails() successfully with optional parameters', async () => {
            const params: GetSolStakingQuotaDetailsRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    leftStakingPersonalQuota: '1000',
                    leftRedemptionPersonalQuota: '1000',
                    minStakeAmount: '0.01000000',
                    minRedeemAmount: '0.00000001',
                    redeemPeriod: 4,
                    stakeable: true,
                    redeemable: true,
                    soldOut: false,
                    commissionFee: '0.25000000',
                    nextEpochTime: 725993969475,
                    calculating: false,
                })
            );

            const spy = jest.spyOn(client, 'getSolStakingQuotaDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSolStakingQuotaDetailsResponse>)
            );
            const response = await client.getSolStakingQuotaDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSolStakingQuotaDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSolStakingQuotaDetails()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getUnclaimedRewards()', () => {
        it('should execute getUnclaimedRewards() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { amount: '1.00000011', rewardsAsset: 'SOL' },
                    { amount: '2.00202321', rewardsAsset: 'BNB' },
                ])
            );

            const spy = jest.spyOn(client, 'getUnclaimedRewards').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUnclaimedRewardsResponse>)
            );
            const response = await client.getUnclaimedRewards();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUnclaimedRewards() successfully with optional parameters', async () => {
            const params: GetUnclaimedRewardsRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { amount: '1.00000011', rewardsAsset: 'SOL' },
                    { amount: '2.00202321', rewardsAsset: 'BNB' },
                ])
            );

            const spy = jest.spyOn(client, 'getUnclaimedRewards').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUnclaimedRewardsResponse>)
            );
            const response = await client.getUnclaimedRewards(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getUnclaimedRewards').mockRejectedValueOnce(mockError);
            await expect(client.getUnclaimedRewards()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemSol()', () => {
        it('should execute redeemSol() successfully with required parameters only', async () => {
            const params: RedeemSolRequest = {
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    solAmount: '0.23092091',
                    exchangeRate: '1.00121234',
                    arrivalTime: 1575018510000,
                })
            );

            const spy = jest.spyOn(client, 'redeemSol').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemSolResponse>)
            );
            const response = await client.redeemSol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemSol() successfully with optional parameters', async () => {
            const params: RedeemSolRequest = {
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    solAmount: '0.23092091',
                    exchangeRate: '1.00121234',
                    arrivalTime: 1575018510000,
                })
            );

            const spy = jest.spyOn(client, 'redeemSol').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemSolResponse>)
            );
            const response = await client.redeemSol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: RedeemSolRequest = {
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.redeemSol(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling redeemSol.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemSolRequest = {
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'redeemSol').mockRejectedValueOnce(mockError);
            await expect(client.redeemSol(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('solStakingAccount()', () => {
        it('should execute solStakingAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    bnsolAmount: '1.10928781',
                    holdingInSOL: '1.22330928',
                    thirtyDaysProfitInSOL: '0.22330928',
                })
            );

            const spy = jest.spyOn(client, 'solStakingAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SolStakingAccountResponse>)
            );
            const response = await client.solStakingAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute solStakingAccount() successfully with optional parameters', async () => {
            const params: SolStakingAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    bnsolAmount: '1.10928781',
                    holdingInSOL: '1.22330928',
                    thirtyDaysProfitInSOL: '0.22330928',
                })
            );

            const spy = jest.spyOn(client, 'solStakingAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SolStakingAccountResponse>)
            );
            const response = await client.solStakingAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'solStakingAccount').mockRejectedValueOnce(mockError);
            await expect(client.solStakingAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subscribeSolStaking()', () => {
        it('should execute subscribeSolStaking() successfully with required parameters only', async () => {
            const params: SubscribeSolStakingRequest = {
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    bnsolAmount: '0.23092091',
                    exchangeRate: '1.001212342342',
                })
            );

            const spy = jest.spyOn(client, 'subscribeSolStaking').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeSolStakingResponse>)
            );
            const response = await client.subscribeSolStaking(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeSolStaking() successfully with optional parameters', async () => {
            const params: SubscribeSolStakingRequest = {
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    bnsolAmount: '0.23092091',
                    exchangeRate: '1.001212342342',
                })
            );

            const spy = jest.spyOn(client, 'subscribeSolStaking').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeSolStakingResponse>)
            );
            const response = await client.subscribeSolStaking(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeSolStakingRequest = {
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeSolStaking(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeSolStaking.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeSolStakingRequest = {
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'subscribeSolStaking').mockRejectedValueOnce(mockError);
            await expect(client.subscribeSolStaking(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
