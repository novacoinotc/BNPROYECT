/**
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { SoftStakingApi } from '../../../src/rest-api';
import {
    GetSoftStakingProductListRequest,
    GetSoftStakingRewardsHistoryRequest,
    SetSoftStakingRequest,
} from '../../../src/rest-api';
import type {
    GetSoftStakingProductListResponse,
    GetSoftStakingRewardsHistoryResponse,
    SetSoftStakingResponse,
} from '../../../src/rest-api/types';

describe('SoftStakingApi', () => {
    let client: SoftStakingApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new SoftStakingApi(config);
    });

    describe('getSoftStakingProductList()', () => {
        it('should execute getSoftStakingProductList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    status: true,
                    totalRewardsUsdt: '3.09827182',
                    rows: [
                        {
                            asset: 'BNB',
                            minAmount: '0.5',
                            maxCap: '1000',
                            apr: '0.0015',
                            stakedAmount: '2.14',
                            totalProfit: '0.00171234',
                        },
                        {
                            asset: 'SUI',
                            minAmount: '100',
                            maxCap: '50000',
                            apr: '0.01',
                            stakedAmount: '100',
                            totalProfit: '0.1',
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getSoftStakingProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSoftStakingProductListResponse>)
            );
            const response = await client.getSoftStakingProductList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSoftStakingProductList() successfully with optional parameters', async () => {
            const params: GetSoftStakingProductListRequest = {
                asset: 'BETH',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    status: true,
                    totalRewardsUsdt: '3.09827182',
                    rows: [
                        {
                            asset: 'BNB',
                            minAmount: '0.5',
                            maxCap: '1000',
                            apr: '0.0015',
                            stakedAmount: '2.14',
                            totalProfit: '0.00171234',
                        },
                        {
                            asset: 'SUI',
                            minAmount: '100',
                            maxCap: '50000',
                            apr: '0.01',
                            stakedAmount: '100',
                            totalProfit: '0.1',
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getSoftStakingProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSoftStakingProductListResponse>)
            );
            const response = await client.getSoftStakingProductList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSoftStakingProductList')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSoftStakingProductList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSoftStakingRewardsHistory()', () => {
        it('should execute getSoftStakingRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            asset: 'BNB',
                            rewards: '0.00000557',
                            rewardAsset: 'BNB',
                            avgAmount: '2.14',
                            time: 1754007978000,
                        },
                        {
                            asset: 'SUI',
                            rewards: '0.00274257',
                            rewardAsset: 'SUI',
                            avgAmount: '100',
                            time: 1754007978000,
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getSoftStakingRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSoftStakingRewardsHistoryResponse>)
            );
            const response = await client.getSoftStakingRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSoftStakingRewardsHistory() successfully with optional parameters', async () => {
            const params: GetSoftStakingRewardsHistoryRequest = {
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            asset: 'BNB',
                            rewards: '0.00000557',
                            rewardAsset: 'BNB',
                            avgAmount: '2.14',
                            time: 1754007978000,
                        },
                        {
                            asset: 'SUI',
                            rewards: '0.00274257',
                            rewardAsset: 'SUI',
                            avgAmount: '100',
                            time: 1754007978000,
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getSoftStakingRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSoftStakingRewardsHistoryResponse>)
            );
            const response = await client.getSoftStakingRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSoftStakingRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSoftStakingRewardsHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setSoftStaking()', () => {
        it('should execute setSoftStaking() successfully with required parameters only', async () => {
            const params: SetSoftStakingRequest = {
                softStaking: true,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setSoftStaking').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetSoftStakingResponse>)
            );
            const response = await client.setSoftStaking(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setSoftStaking() successfully with optional parameters', async () => {
            const params: SetSoftStakingRequest = {
                softStaking: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setSoftStaking').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetSoftStakingResponse>)
            );
            const response = await client.setSoftStaking(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when softStaking is missing', async () => {
            const _params: SetSoftStakingRequest = {
                softStaking: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.softStaking;

            await expect(client.setSoftStaking(params)).rejects.toThrow(
                'Required parameter softStaking was null or undefined when calling setSoftStaking.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetSoftStakingRequest = {
                softStaking: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'setSoftStaking').mockRejectedValueOnce(mockError);
            await expect(client.setSoftStaking(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
