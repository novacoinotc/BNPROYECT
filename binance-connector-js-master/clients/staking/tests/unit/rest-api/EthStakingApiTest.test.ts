/**
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { EthStakingApi } from '../../../src/rest-api';
import {
    EthStakingAccountRequest,
    GetCurrentEthStakingQuotaRequest,
    GetEthRedemptionHistoryRequest,
    GetEthStakingHistoryRequest,
    GetWbethRateHistoryRequest,
    GetWbethRewardsHistoryRequest,
    GetWbethUnwrapHistoryRequest,
    GetWbethWrapHistoryRequest,
    RedeemEthRequest,
    SubscribeEthStakingRequest,
    WrapBethRequest,
} from '../../../src/rest-api';
import type {
    EthStakingAccountResponse,
    GetCurrentEthStakingQuotaResponse,
    GetEthRedemptionHistoryResponse,
    GetEthStakingHistoryResponse,
    GetWbethRateHistoryResponse,
    GetWbethRewardsHistoryResponse,
    GetWbethUnwrapHistoryResponse,
    GetWbethWrapHistoryResponse,
    RedeemEthResponse,
    SubscribeEthStakingResponse,
    WrapBethResponse,
} from '../../../src/rest-api/types';

describe('EthStakingApi', () => {
    let client: EthStakingApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new EthStakingApi(config);
    });

    describe('ethStakingAccount()', () => {
        it('should execute ethStakingAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    holdingInETH: '1.22330928',
                    holdings: { wbethAmount: '1.10928781', bethAmount: '1.90002112' },
                    thirtyDaysProfitInETH: '0.22330928',
                    profit: { amountFromWBETH: '0.12330928', amountFromBETH: '0.1' },
                })
            );

            const spy = jest.spyOn(client, 'ethStakingAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EthStakingAccountResponse>)
            );
            const response = await client.ethStakingAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ethStakingAccount() successfully with optional parameters', async () => {
            const params: EthStakingAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    holdingInETH: '1.22330928',
                    holdings: { wbethAmount: '1.10928781', bethAmount: '1.90002112' },
                    thirtyDaysProfitInETH: '0.22330928',
                    profit: { amountFromWBETH: '0.12330928', amountFromBETH: '0.1' },
                })
            );

            const spy = jest.spyOn(client, 'ethStakingAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EthStakingAccountResponse>)
            );
            const response = await client.ethStakingAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ethStakingAccount').mockRejectedValueOnce(mockError);
            await expect(client.ethStakingAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCurrentEthStakingQuota()', () => {
        it('should execute getCurrentEthStakingQuota() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    leftStakingPersonalQuota: '1000',
                    leftRedemptionPersonalQuota: '1000',
                    minStakeAmount: '0.00010000',
                    minRedeemAmount: '0.00000001',
                    redeemPeriod: 20,
                    stakeable: true,
                    redeemable: true,
                    commissionFee: '0.05000000',
                    calculating: false,
                })
            );

            const spy = jest.spyOn(client, 'getCurrentEthStakingQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentEthStakingQuotaResponse>)
            );
            const response = await client.getCurrentEthStakingQuota();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCurrentEthStakingQuota() successfully with optional parameters', async () => {
            const params: GetCurrentEthStakingQuotaRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    leftStakingPersonalQuota: '1000',
                    leftRedemptionPersonalQuota: '1000',
                    minStakeAmount: '0.00010000',
                    minRedeemAmount: '0.00000001',
                    redeemPeriod: 20,
                    stakeable: true,
                    redeemable: true,
                    commissionFee: '0.05000000',
                    calculating: false,
                })
            );

            const spy = jest.spyOn(client, 'getCurrentEthStakingQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentEthStakingQuotaResponse>)
            );
            const response = await client.getCurrentEthStakingQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCurrentEthStakingQuota')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCurrentEthStakingQuota()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getEthRedemptionHistory()', () => {
        it('should execute getEthRedemptionHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            arrivalTime: 1575018510000,
                            asset: 'WBETH',
                            amount: '21312.23223',
                            distributeAsset: 'ETH',
                            distributeAmount: '21338.0699',
                            conversionRatio: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getEthRedemptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetEthRedemptionHistoryResponse>)
            );
            const response = await client.getEthRedemptionHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getEthRedemptionHistory() successfully with optional parameters', async () => {
            const params: GetEthRedemptionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            arrivalTime: 1575018510000,
                            asset: 'WBETH',
                            amount: '21312.23223',
                            distributeAsset: 'ETH',
                            distributeAmount: '21338.0699',
                            conversionRatio: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getEthRedemptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetEthRedemptionHistoryResponse>)
            );
            const response = await client.getEthRedemptionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getEthRedemptionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getEthRedemptionHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getEthStakingHistory()', () => {
        it('should execute getEthStakingHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'ETH',
                            amount: '21312.23223',
                            distributeAsset: 'WBETH',
                            distributeAmount: '21286.42584',
                            conversionRatio: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getEthStakingHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetEthStakingHistoryResponse>)
            );
            const response = await client.getEthStakingHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getEthStakingHistory() successfully with optional parameters', async () => {
            const params: GetEthStakingHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'ETH',
                            amount: '21312.23223',
                            distributeAsset: 'WBETH',
                            distributeAmount: '21286.42584',
                            conversionRatio: '1.00121234',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getEthStakingHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetEthStakingHistoryResponse>)
            );
            const response = await client.getEthStakingHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getEthStakingHistory').mockRejectedValueOnce(mockError);
            await expect(client.getEthStakingHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getWbethRateHistory()', () => {
        it('should execute getWbethRateHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            annualPercentageRate: '0.00006408',
                            exchangeRate: '1.00121234',
                            time: 1577233578000,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getWbethRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethRateHistoryResponse>)
            );
            const response = await client.getWbethRateHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getWbethRateHistory() successfully with optional parameters', async () => {
            const params: GetWbethRateHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            annualPercentageRate: '0.00006408',
                            exchangeRate: '1.00121234',
                            time: 1577233578000,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getWbethRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethRateHistoryResponse>)
            );
            const response = await client.getWbethRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getWbethRateHistory').mockRejectedValueOnce(mockError);
            await expect(client.getWbethRateHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getWbethRewardsHistory()', () => {
        it('should execute getWbethRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    estRewardsInETH: '1.23230920',
                    rows: [
                        {
                            time: 1575018510000,
                            amountInETH: '0.23223',
                            holding: '2.3223',
                            holdingInETH: '2.4231',
                            annualPercentageRate: '0.5',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getWbethRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethRewardsHistoryResponse>)
            );
            const response = await client.getWbethRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getWbethRewardsHistory() successfully with optional parameters', async () => {
            const params: GetWbethRewardsHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    estRewardsInETH: '1.23230920',
                    rows: [
                        {
                            time: 1575018510000,
                            amountInETH: '0.23223',
                            holding: '2.3223',
                            holdingInETH: '2.4231',
                            annualPercentageRate: '0.5',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getWbethRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethRewardsHistoryResponse>)
            );
            const response = await client.getWbethRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getWbethRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getWbethRewardsHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getWbethUnwrapHistory()', () => {
        it('should execute getWbethUnwrapHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            fromAsset: 'WBETH',
                            fromAmount: '21312.23223',
                            toAsset: 'BETH',
                            toAmount: '21312.23223',
                            exchangeRate: '1.01243253',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getWbethUnwrapHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethUnwrapHistoryResponse>)
            );
            const response = await client.getWbethUnwrapHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getWbethUnwrapHistory() successfully with optional parameters', async () => {
            const params: GetWbethUnwrapHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            fromAsset: 'WBETH',
                            fromAmount: '21312.23223',
                            toAsset: 'BETH',
                            toAmount: '21312.23223',
                            exchangeRate: '1.01243253',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getWbethUnwrapHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethUnwrapHistoryResponse>)
            );
            const response = await client.getWbethUnwrapHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getWbethUnwrapHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getWbethUnwrapHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getWbethWrapHistory()', () => {
        it('should execute getWbethWrapHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            fromAsset: 'BETH',
                            fromAmount: '21312.23223',
                            toAsset: 'WBETH',
                            toAmount: '21312.23223',
                            exchangeRate: '1.01243253',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getWbethWrapHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethWrapHistoryResponse>)
            );
            const response = await client.getWbethWrapHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getWbethWrapHistory() successfully with optional parameters', async () => {
            const params: GetWbethWrapHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            fromAsset: 'BETH',
                            fromAmount: '21312.23223',
                            toAsset: 'WBETH',
                            toAmount: '21312.23223',
                            exchangeRate: '1.01243253',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getWbethWrapHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetWbethWrapHistoryResponse>)
            );
            const response = await client.getWbethWrapHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getWbethWrapHistory').mockRejectedValueOnce(mockError);
            await expect(client.getWbethWrapHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemEth()', () => {
        it('should execute redeemEth() successfully with required parameters only', async () => {
            const params: RedeemEthRequest = {
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    ethAmount: '0.23092091',
                    conversionRatio: '1.00121234',
                    arrivalTime: 1575018510000,
                })
            );

            const spy = jest.spyOn(client, 'redeemEth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemEthResponse>)
            );
            const response = await client.redeemEth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemEth() successfully with optional parameters', async () => {
            const params: RedeemEthRequest = {
                amount: 1.0,
                asset: 'BETH',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    ethAmount: '0.23092091',
                    conversionRatio: '1.00121234',
                    arrivalTime: 1575018510000,
                })
            );

            const spy = jest.spyOn(client, 'redeemEth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemEthResponse>)
            );
            const response = await client.redeemEth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: RedeemEthRequest = {
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.redeemEth(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling redeemEth.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemEthRequest = {
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'redeemEth').mockRejectedValueOnce(mockError);
            await expect(client.redeemEth(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subscribeEthStaking()', () => {
        it('should execute subscribeEthStaking() successfully with required parameters only', async () => {
            const params: SubscribeEthStakingRequest = {
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    wbethAmount: '0.23092091',
                    conversionRatio: '1.001212342342',
                })
            );

            const spy = jest.spyOn(client, 'subscribeEthStaking').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeEthStakingResponse>)
            );
            const response = await client.subscribeEthStaking(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeEthStaking() successfully with optional parameters', async () => {
            const params: SubscribeEthStakingRequest = {
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    wbethAmount: '0.23092091',
                    conversionRatio: '1.001212342342',
                })
            );

            const spy = jest.spyOn(client, 'subscribeEthStaking').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeEthStakingResponse>)
            );
            const response = await client.subscribeEthStaking(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeEthStakingRequest = {
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeEthStaking(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeEthStaking.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeEthStakingRequest = {
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'subscribeEthStaking').mockRejectedValueOnce(mockError);
            await expect(client.subscribeEthStaking(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('wrapBeth()', () => {
        it('should execute wrapBeth() successfully with required parameters only', async () => {
            const params: WrapBethRequest = {
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    wbethAmount: '0.23092091',
                    exchangeRate: '1.001212343432',
                })
            );

            const spy = jest.spyOn(client, 'wrapBeth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WrapBethResponse>)
            );
            const response = await client.wrapBeth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute wrapBeth() successfully with optional parameters', async () => {
            const params: WrapBethRequest = {
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    wbethAmount: '0.23092091',
                    exchangeRate: '1.001212343432',
                })
            );

            const spy = jest.spyOn(client, 'wrapBeth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WrapBethResponse>)
            );
            const response = await client.wrapBeth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WrapBethRequest = {
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.wrapBeth(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling wrapBeth.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WrapBethRequest = {
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'wrapBeth').mockRejectedValueOnce(mockError);
            await expect(client.wrapBeth(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
