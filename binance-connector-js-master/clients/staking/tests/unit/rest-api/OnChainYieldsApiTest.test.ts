/**
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { OnChainYieldsApi } from '../../../src/rest-api';
import {
    GetOnChainYieldsLockedPersonalLeftQuotaRequest,
    GetOnChainYieldsLockedProductListRequest,
    GetOnChainYieldsLockedProductPositionRequest,
    GetOnChainYieldsLockedRedemptionRecordRequest,
    GetOnChainYieldsLockedRewardsHistoryRequest,
    GetOnChainYieldsLockedSubscriptionPreviewRequest,
    GetOnChainYieldsLockedSubscriptionRecordRequest,
    OnChainYieldsAccountRequest,
    RedeemOnChainYieldsLockedProductRequest,
    SetOnChainYieldsLockedAutoSubscribeRequest,
    SetOnChainYieldsLockedProductRedeemOptionRequest,
    SubscribeOnChainYieldsLockedProductRequest,
} from '../../../src/rest-api';
import type {
    GetOnChainYieldsLockedPersonalLeftQuotaResponse,
    GetOnChainYieldsLockedProductListResponse,
    GetOnChainYieldsLockedProductPositionResponse,
    GetOnChainYieldsLockedRedemptionRecordResponse,
    GetOnChainYieldsLockedRewardsHistoryResponse,
    GetOnChainYieldsLockedSubscriptionPreviewResponse,
    GetOnChainYieldsLockedSubscriptionRecordResponse,
    OnChainYieldsAccountResponse,
    RedeemOnChainYieldsLockedProductResponse,
    SetOnChainYieldsLockedAutoSubscribeResponse,
    SetOnChainYieldsLockedProductRedeemOptionResponse,
    SubscribeOnChainYieldsLockedProductResponse,
} from '../../../src/rest-api/types';

describe('OnChainYieldsApi', () => {
    let client: OnChainYieldsApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new OnChainYieldsApi(config);
    });

    describe('getOnChainYieldsLockedPersonalLeftQuota()', () => {
        it('should execute getOnChainYieldsLockedPersonalLeftQuota() successfully with required parameters only', async () => {
            const params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };

            mockResponse = JSONParse(JSONStringify({ leftPersonalQuota: '1000' }));

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedPersonalLeftQuota')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedPersonalLeftQuotaResponse>)
                );
            const response = await client.getOnChainYieldsLockedPersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedPersonalLeftQuota() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ leftPersonalQuota: '1000' }));

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedPersonalLeftQuota')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedPersonalLeftQuotaResponse>)
                );
            const response = await client.getOnChainYieldsLockedPersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getOnChainYieldsLockedPersonalLeftQuota(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getOnChainYieldsLockedPersonalLeftQuota.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedPersonalLeftQuota')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedPersonalLeftQuota(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedProductList()', () => {
        it('should execute getOnChainYieldsLockedProductList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            projectId: 'Solv-60d',
                            detail: {
                                asset: 'BTC',
                                rewardAsset: 'SOLV',
                                duration: 60,
                                renewable: true,
                                isSoldOut: true,
                                apr: '0.039',
                                status: 'PREHEATING',
                                subscriptionStartTime: 1646182276000,
                                canRedeemToFlex: true,
                            },
                            quota: { totalPersonalQuota: '2', minimum: '0.001' },
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductListResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedProductList() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedProductListRequest = {
                asset: 'BETH',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            projectId: 'Solv-60d',
                            detail: {
                                asset: 'BTC',
                                rewardAsset: 'SOLV',
                                duration: 60,
                                renewable: true,
                                isSoldOut: true,
                                apr: '0.039',
                                status: 'PREHEATING',
                                subscriptionStartTime: 1646182276000,
                                canRedeemToFlex: true,
                            },
                            quota: { totalPersonalQuota: '2', minimum: '0.001' },
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductListResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedProductList')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedProductList()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedProductPosition()', () => {
        it('should execute getOnChainYieldsLockedProductPosition() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            projectId: 'Solv-60d',
                            asset: 'BTC',
                            amount: '122.09202928',
                            purchaseTime: '1646182276000',
                            duration: '60',
                            accrualDays: '4',
                            rewardAsset: 'SOLV',
                            APY: '0.039',
                            rewardAmt: '5.17181528',
                            nextPay: '1.29295383',
                            nextPayDate: '1646697600000',
                            payPeriod: '1',
                            rewardsPayDate: '1646697600000',
                            rewardsEndDate: '1651449600000',
                            deliverDate: '1651536000000',
                            nextSubscriptionDate: '1651536000000',
                            redeemingAmt: '232.2323',
                            redeemTo: 'FLEXIBLE',
                            canRedeemEarly: true,
                            autoSubscribe: true,
                            type: 'AUTO',
                            status: 'HOLDING',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductPositionResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductPosition();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedProductPosition() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedProductPositionRequest = {
                asset: 'BETH',
                positionId: 1,
                projectId: '1',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            projectId: 'Solv-60d',
                            asset: 'BTC',
                            amount: '122.09202928',
                            purchaseTime: '1646182276000',
                            duration: '60',
                            accrualDays: '4',
                            rewardAsset: 'SOLV',
                            APY: '0.039',
                            rewardAmt: '5.17181528',
                            nextPay: '1.29295383',
                            nextPayDate: '1646697600000',
                            payPeriod: '1',
                            rewardsPayDate: '1646697600000',
                            rewardsEndDate: '1651449600000',
                            deliverDate: '1651536000000',
                            nextSubscriptionDate: '1651536000000',
                            redeemingAmt: '232.2323',
                            redeemTo: 'FLEXIBLE',
                            canRedeemEarly: true,
                            autoSubscribe: true,
                            type: 'AUTO',
                            status: 'HOLDING',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductPositionResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductPosition(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedProductPosition')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedProductPosition()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedRedemptionRecord()', () => {
        it('should execute getOnChainYieldsLockedRedemptionRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            redeemId: 40607,
                            time: 1575018510000,
                            asset: 'BTC',
                            lockPeriod: '30',
                            amount: '21312.23223',
                            originalAmount: '21312.23223',
                            type: 'NORMAL',
                            deliverDate: '1575018510000',
                            lossAmount: '0.00001232',
                            isComplete: true,
                            rewardAsset: 'SOLV',
                            rewardAmt: '5.17181528',
                            status: 'PAID',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRedemptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedRedemptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedRedemptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedRedemptionRecord() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedRedemptionRecordRequest = {
                positionId: 1,
                redeemId: '1',
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            redeemId: 40607,
                            time: 1575018510000,
                            asset: 'BTC',
                            lockPeriod: '30',
                            amount: '21312.23223',
                            originalAmount: '21312.23223',
                            type: 'NORMAL',
                            deliverDate: '1575018510000',
                            lossAmount: '0.00001232',
                            isComplete: true,
                            rewardAsset: 'SOLV',
                            rewardAmt: '5.17181528',
                            status: 'PAID',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRedemptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedRedemptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedRedemptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRedemptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedRedemptionRecord()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedRewardsHistory()', () => {
        it('should execute getOnChainYieldsLockedRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            time: 1575018510000,
                            asset: 'BNB',
                            lockPeriod: '30',
                            amount: '21312.23223',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedRewardsHistoryResponse>)
            );
            const response = await client.getOnChainYieldsLockedRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedRewardsHistory() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedRewardsHistoryRequest = {
                positionId: '1',
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            time: 1575018510000,
                            asset: 'BNB',
                            lockPeriod: '30',
                            amount: '21312.23223',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedRewardsHistoryResponse>)
            );
            const response = await client.getOnChainYieldsLockedRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedRewardsHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedSubscriptionPreview()', () => {
        it('should execute getOnChainYieldsLockedSubscriptionPreview() successfully with required parameters only', async () => {
            const params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rewardAsset: 'SOLV',
                    totalRewardAmt: '5.17181528',
                    nextPay: '1.29295383',
                    nextPayDate: '1646697600000',
                    rewardsPayDate: '1646697600000',
                    valueDate: '1646697600000',
                    rewardsEndDate: '1651449600000',
                    deliverDate: '1651536000000',
                    nextSubscriptionDate: '1651536000000',
                })
            );

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionPreview')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionPreviewResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedSubscriptionPreview() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rewardAsset: 'SOLV',
                    totalRewardAmt: '5.17181528',
                    nextPay: '1.29295383',
                    nextPayDate: '1646697600000',
                    rewardsPayDate: '1646697600000',
                    valueDate: '1646697600000',
                    rewardsEndDate: '1651449600000',
                    deliverDate: '1651536000000',
                    nextSubscriptionDate: '1651536000000',
                })
            );

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionPreview')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionPreviewResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getOnChainYieldsLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getOnChainYieldsLockedSubscriptionPreview.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.getOnChainYieldsLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling getOnChainYieldsLockedSubscriptionPreview.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionPreview')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedSubscriptionPreview(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedSubscriptionRecord()', () => {
        it('should execute getOnChainYieldsLockedSubscriptionRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            purchaseId: '26055',
                            projectId: 'Solv-60d',
                            clientId: 'ABC',
                            time: 1575018510000,
                            asset: 'BTC',
                            amount: '21312.23223',
                            lockPeriod: '30',
                            type: 'AUTO',
                            sourceAccount: 'SPOT',
                            amtFromSpot: '30',
                            amtFromFunding: '70',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedSubscriptionRecord() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedSubscriptionRecordRequest = {
                purchaseId: '1',
                clientId: '1',
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: '123123',
                            purchaseId: '26055',
                            projectId: 'Solv-60d',
                            clientId: 'ABC',
                            time: 1575018510000,
                            asset: 'BTC',
                            amount: '21312.23223',
                            lockPeriod: '30',
                            type: 'AUTO',
                            sourceAccount: 'SPOT',
                            amtFromSpot: '30',
                            amtFromFunding: '70',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedSubscriptionRecord()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('onChainYieldsAccount()', () => {
        it('should execute onChainYieldsAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    totalAmountInBTC: '0.01067982',
                    totalAmountInUSDT: '77.13289230',
                    totalFlexibleAmountInBTC: '0.00000000',
                    totalFlexibleAmountInUSDT: '0.00000000',
                    totalLockedInBTC: '0.01067982',
                    totalLockedInUSDT: '77.13289230',
                })
            );

            const spy = jest.spyOn(client, 'onChainYieldsAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OnChainYieldsAccountResponse>)
            );
            const response = await client.onChainYieldsAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute onChainYieldsAccount() successfully with optional parameters', async () => {
            const params: OnChainYieldsAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalAmountInBTC: '0.01067982',
                    totalAmountInUSDT: '77.13289230',
                    totalFlexibleAmountInBTC: '0.00000000',
                    totalFlexibleAmountInUSDT: '0.00000000',
                    totalLockedInBTC: '0.01067982',
                    totalLockedInUSDT: '77.13289230',
                })
            );

            const spy = jest.spyOn(client, 'onChainYieldsAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OnChainYieldsAccountResponse>)
            );
            const response = await client.onChainYieldsAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'onChainYieldsAccount').mockRejectedValueOnce(mockError);
            await expect(client.onChainYieldsAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemOnChainYieldsLockedProduct()', () => {
        it('should execute redeemOnChainYieldsLockedProduct() successfully with required parameters only', async () => {
            const params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
            };

            mockResponse = JSONParse(JSONStringify({ redeemId: 40607, success: true }));

            const spy = jest.spyOn(client, 'redeemOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemOnChainYieldsLockedProductResponse>)
            );
            const response = await client.redeemOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemOnChainYieldsLockedProduct() successfully with optional parameters', async () => {
            const params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
                channelId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ redeemId: 40607, success: true }));

            const spy = jest.spyOn(client, 'redeemOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemOnChainYieldsLockedProductResponse>)
            );
            const response = await client.redeemOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.redeemOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling redeemOnChainYieldsLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'redeemOnChainYieldsLockedProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.redeemOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('setOnChainYieldsLockedAutoSubscribe()', () => {
        it('should execute setOnChainYieldsLockedAutoSubscribe() successfully with required parameters only', async () => {
            const params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setOnChainYieldsLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetOnChainYieldsLockedAutoSubscribeResponse>)
            );
            const response = await client.setOnChainYieldsLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setOnChainYieldsLockedAutoSubscribe() successfully with optional parameters', async () => {
            const params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setOnChainYieldsLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetOnChainYieldsLockedAutoSubscribeResponse>)
            );
            const response = await client.setOnChainYieldsLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setOnChainYieldsLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setOnChainYieldsLockedAutoSubscribe.'
            );
        });

        it('should throw RequiredError when autoSubscribe is missing', async () => {
            const _params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.autoSubscribe;

            await expect(client.setOnChainYieldsLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter autoSubscribe was null or undefined when calling setOnChainYieldsLockedAutoSubscribe.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedAutoSubscribe')
                .mockRejectedValueOnce(mockError);
            await expect(client.setOnChainYieldsLockedAutoSubscribe(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('setOnChainYieldsLockedProductRedeemOption()', () => {
        it('should execute setOnChainYieldsLockedProductRedeemOption() successfully with required parameters only', async () => {
            const params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedProductRedeemOption')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<SetOnChainYieldsLockedProductRedeemOptionResponse>)
                );
            const response = await client.setOnChainYieldsLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setOnChainYieldsLockedProductRedeemOption() successfully with optional parameters', async () => {
            const params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedProductRedeemOption')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<SetOnChainYieldsLockedProductRedeemOptionResponse>)
                );
            const response = await client.setOnChainYieldsLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setOnChainYieldsLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setOnChainYieldsLockedProductRedeemOption.'
            );
        });

        it('should throw RequiredError when redeemTo is missing', async () => {
            const _params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.redeemTo;

            await expect(client.setOnChainYieldsLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter redeemTo was null or undefined when calling setOnChainYieldsLockedProductRedeemOption.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedProductRedeemOption')
                .mockRejectedValueOnce(mockError);
            await expect(client.setOnChainYieldsLockedProductRedeemOption(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('subscribeOnChainYieldsLockedProduct()', () => {
        it('should execute subscribeOnChainYieldsLockedProduct() successfully with required parameters only', async () => {
            const params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    purchaseId: 40607,
                    positionId: '12345',
                    amount: '75.46000000',
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'subscribeOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeOnChainYieldsLockedProductResponse>)
            );
            const response = await client.subscribeOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeOnChainYieldsLockedProduct() successfully with optional parameters', async () => {
            const params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
                autoSubscribe: true,
                sourceAccount: 'SPOT',
                redeemTo: '',
                channelId: '1',
                clientId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    purchaseId: 40607,
                    positionId: '12345',
                    amount: '75.46000000',
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'subscribeOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeOnChainYieldsLockedProductResponse>)
            );
            const response = await client.subscribeOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.subscribeOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling subscribeOnChainYieldsLockedProduct.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeOnChainYieldsLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subscribeOnChainYieldsLockedProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.subscribeOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
