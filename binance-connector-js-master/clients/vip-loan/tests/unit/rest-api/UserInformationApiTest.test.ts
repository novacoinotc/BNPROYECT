/**
 * Binance VIP Loan REST API
 *
 * OpenAPI Specification for the Binance VIP Loan REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { UserInformationApi } from '../../../src/rest-api';
import {
    CheckVIPLoanCollateralAccountRequest,
    GetVIPLoanAccruedInterestRequest,
    GetVIPLoanOngoingOrdersRequest,
    QueryApplicationStatusRequest,
} from '../../../src/rest-api';
import type {
    CheckVIPLoanCollateralAccountResponse,
    GetVIPLoanAccruedInterestResponse,
    GetVIPLoanOngoingOrdersResponse,
    QueryApplicationStatusResponse,
} from '../../../src/rest-api/types';

describe('UserInformationApi', () => {
    let client: UserInformationApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new UserInformationApi(config);
    });

    describe('checkVIPLoanCollateralAccount()', () => {
        it('should execute checkVIPLoanCollateralAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        { collateralAccountId: '12345678', collateralCoin: 'BNB,BTC,ETH' },
                        { collateralAccountId: '23456789', collateralCoin: 'BNB,BTC,ETH' },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'checkVIPLoanCollateralAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckVIPLoanCollateralAccountResponse>)
            );
            const response = await client.checkVIPLoanCollateralAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute checkVIPLoanCollateralAccount() successfully with optional parameters', async () => {
            const params: CheckVIPLoanCollateralAccountRequest = {
                orderId: 1,
                collateralAccountId: 1,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        { collateralAccountId: '12345678', collateralCoin: 'BNB,BTC,ETH' },
                        { collateralAccountId: '23456789', collateralCoin: 'BNB,BTC,ETH' },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'checkVIPLoanCollateralAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckVIPLoanCollateralAccountResponse>)
            );
            const response = await client.checkVIPLoanCollateralAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'checkVIPLoanCollateralAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.checkVIPLoanCollateralAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getVIPLoanAccruedInterest()', () => {
        it('should execute getVIPLoanAccruedInterest() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'USDT',
                            principalAmount: '10000',
                            interestAmount: '1.2',
                            annualInterestRate: '0.001273',
                            accrualTime: 1575018510000,
                            orderId: 756783308056935400,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getVIPLoanAccruedInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetVIPLoanAccruedInterestResponse>)
            );
            const response = await client.getVIPLoanAccruedInterest();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getVIPLoanAccruedInterest() successfully with optional parameters', async () => {
            const params: GetVIPLoanAccruedInterestRequest = {
                orderId: 1,
                loanCoin: 'loanCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanCoin: 'USDT',
                            principalAmount: '10000',
                            interestAmount: '1.2',
                            annualInterestRate: '0.001273',
                            accrualTime: 1575018510000,
                            orderId: 756783308056935400,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getVIPLoanAccruedInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetVIPLoanAccruedInterestResponse>)
            );
            const response = await client.getVIPLoanAccruedInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getVIPLoanAccruedInterest')
                .mockRejectedValueOnce(mockError);
            await expect(client.getVIPLoanAccruedInterest()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getVIPLoanOngoingOrders()', () => {
        it('should execute getVIPLoanOngoingOrders() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            orderId: 100000001,
                            loanCoin: 'BUSD',
                            totalDebt: '10000',
                            residualInterest: '10.27687923',
                            collateralAccountId: '12345678,23456789',
                            collateralCoin: 'BNB,BTC,ETH',
                            totalCollateralValueAfterHaircut: '25000.27565492',
                            lockedCollateralValue: '25000.27565492',
                            currentLTV: '0.57',
                            expirationTime: 1575018510000,
                            loanDate: '1676851200000',
                            loanTerm: '30days',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getVIPLoanOngoingOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetVIPLoanOngoingOrdersResponse>)
            );
            const response = await client.getVIPLoanOngoingOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getVIPLoanOngoingOrders() successfully with optional parameters', async () => {
            const params: GetVIPLoanOngoingOrdersRequest = {
                orderId: 1,
                collateralAccountId: 1,
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            orderId: 100000001,
                            loanCoin: 'BUSD',
                            totalDebt: '10000',
                            residualInterest: '10.27687923',
                            collateralAccountId: '12345678,23456789',
                            collateralCoin: 'BNB,BTC,ETH',
                            totalCollateralValueAfterHaircut: '25000.27565492',
                            lockedCollateralValue: '25000.27565492',
                            currentLTV: '0.57',
                            expirationTime: 1575018510000,
                            loanDate: '1676851200000',
                            loanTerm: '30days',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getVIPLoanOngoingOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetVIPLoanOngoingOrdersResponse>)
            );
            const response = await client.getVIPLoanOngoingOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getVIPLoanOngoingOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.getVIPLoanOngoingOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryApplicationStatus()', () => {
        it('should execute queryApplicationStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanAccountId: '12345678',
                            orderId: '12345678',
                            requestId: '12345678',
                            loanCoin: 'BTC',
                            loanAmount: '100.55',
                            collateralAccountId: '12345678,12345678,12345678',
                            collateralCoin: 'BUSD,USDT,ETH',
                            loanTerm: '30',
                            status: 'Repaid',
                            loanDate: '1676851200000',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryApplicationStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryApplicationStatusResponse>)
            );
            const response = await client.queryApplicationStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryApplicationStatus() successfully with optional parameters', async () => {
            const params: QueryApplicationStatusRequest = {
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            loanAccountId: '12345678',
                            orderId: '12345678',
                            requestId: '12345678',
                            loanCoin: 'BTC',
                            loanAmount: '100.55',
                            collateralAccountId: '12345678,12345678,12345678',
                            collateralCoin: 'BUSD,USDT,ETH',
                            loanTerm: '30',
                            status: 'Repaid',
                            loanDate: '1676851200000',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'queryApplicationStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryApplicationStatusResponse>)
            );
            const response = await client.queryApplicationStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryApplicationStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryApplicationStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
