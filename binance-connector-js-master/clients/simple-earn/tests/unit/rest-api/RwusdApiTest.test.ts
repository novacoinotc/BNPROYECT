/**
 * Binance Simple Earn REST API
 *
 * OpenAPI Specification for the Binance Simple Earn REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { RwusdApi } from '../../../src/rest-api';
import {
    GetRwusdAccountRequest,
    GetRwusdQuotaDetailsRequest,
    GetRwusdRateHistoryRequest,
    GetRwusdRedemptionHistoryRequest,
    GetRwusdRewardsHistoryRequest,
    GetRwusdSubscriptionHistoryRequest,
    RedeemRwusdRequest,
    SubscribeRwusdRequest,
} from '../../../src/rest-api';
import type {
    GetRwusdAccountResponse,
    GetRwusdQuotaDetailsResponse,
    GetRwusdRateHistoryResponse,
    GetRwusdRedemptionHistoryResponse,
    GetRwusdRewardsHistoryResponse,
    GetRwusdSubscriptionHistoryResponse,
    RedeemRwusdResponse,
    SubscribeRwusdResponse,
} from '../../../src/rest-api/types';

describe('RwusdApi', () => {
    let client: RwusdApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new RwusdApi(config);
    });

    describe('getRwusdAccount()', () => {
        it('should execute getRwusdAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ rwusdAmount: '100', totalProfit: '12.81' }));

            const spy = jest.spyOn(client, 'getRwusdAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdAccountResponse>)
            );
            const response = await client.getRwusdAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRwusdAccount() successfully with optional parameters', async () => {
            const params: GetRwusdAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ rwusdAmount: '100', totalProfit: '12.81' }));

            const spy = jest.spyOn(client, 'getRwusdAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdAccountResponse>)
            );
            const response = await client.getRwusdAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getRwusdAccount').mockRejectedValueOnce(mockError);
            await expect(client.getRwusdAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRwusdQuotaDetails()', () => {
        it('should execute getRwusdQuotaDetails() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    subscriptionQuota: {
                        assets: ['USDT', 'USDC'],
                        leftQuota: '1000',
                        minimum: '0.10000000',
                    },
                    fastRedemptionQuota: {
                        leftQuota: '2',
                        minimum: '0.1',
                        fee: '0.0005',
                        freeQuota: '100',
                    },
                    standardRedemptionQuota: {
                        leftQuota: '2',
                        minimum: '0.1',
                        fee: '0.001',
                        redeemPeriod: 3,
                    },
                    subscribeEnable: true,
                    redeemEnable: true,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdQuotaDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdQuotaDetailsResponse>)
            );
            const response = await client.getRwusdQuotaDetails();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRwusdQuotaDetails() successfully with optional parameters', async () => {
            const params: GetRwusdQuotaDetailsRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    subscriptionQuota: {
                        assets: ['USDT', 'USDC'],
                        leftQuota: '1000',
                        minimum: '0.10000000',
                    },
                    fastRedemptionQuota: {
                        leftQuota: '2',
                        minimum: '0.1',
                        fee: '0.0005',
                        freeQuota: '100',
                    },
                    standardRedemptionQuota: {
                        leftQuota: '2',
                        minimum: '0.1',
                        fee: '0.001',
                        redeemPeriod: 3,
                    },
                    subscribeEnable: true,
                    redeemEnable: true,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdQuotaDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdQuotaDetailsResponse>)
            );
            const response = await client.getRwusdQuotaDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getRwusdQuotaDetails').mockRejectedValueOnce(mockError);
            await expect(client.getRwusdQuotaDetails()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRwusdRateHistory()', () => {
        it('should execute getRwusdRateHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [{ annualPercentageRate: '0.0418', time: 1577233578000 }],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getRwusdRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdRateHistoryResponse>)
            );
            const response = await client.getRwusdRateHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRwusdRateHistory() successfully with optional parameters', async () => {
            const params: GetRwusdRateHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [{ annualPercentageRate: '0.0418', time: 1577233578000 }],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getRwusdRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdRateHistoryResponse>)
            );
            const response = await client.getRwusdRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getRwusdRateHistory').mockRejectedValueOnce(mockError);
            await expect(client.getRwusdRateHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRwusdRedemptionHistory()', () => {
        it('should execute getRwusdRedemptionHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'RWUSD',
                            amount: '51',
                            receiveAsset: 'USDC',
                            receiveAmount: '50',
                            fee: '1',
                            arrivalTime: 1575018510000,
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdRedemptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdRedemptionHistoryResponse>)
            );
            const response = await client.getRwusdRedemptionHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRwusdRedemptionHistory() successfully with optional parameters', async () => {
            const params: GetRwusdRedemptionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'RWUSD',
                            amount: '51',
                            receiveAsset: 'USDC',
                            receiveAmount: '50',
                            fee: '1',
                            arrivalTime: 1575018510000,
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdRedemptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdRedemptionHistoryResponse>)
            );
            const response = await client.getRwusdRedemptionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getRwusdRedemptionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getRwusdRedemptionHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRwusdRewardsHistory()', () => {
        it('should execute getRwusdRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            rewardsAmount: '1',
                            rwusdPosition: '100',
                            annualPercentageRate: '0.0418',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdRewardsHistoryResponse>)
            );
            const response = await client.getRwusdRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRwusdRewardsHistory() successfully with optional parameters', async () => {
            const params: GetRwusdRewardsHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            rewardsAmount: '1',
                            rwusdPosition: '100',
                            annualPercentageRate: '0.0418',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdRewardsHistoryResponse>)
            );
            const response = await client.getRwusdRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getRwusdRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getRwusdRewardsHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRwusdSubscriptionHistory()', () => {
        it('should execute getRwusdSubscriptionHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'USDC',
                            amount: '100',
                            receiveAsset: 'RWUSD',
                            receiveAmount: '100',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdSubscriptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdSubscriptionHistoryResponse>)
            );
            const response = await client.getRwusdSubscriptionHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRwusdSubscriptionHistory() successfully with optional parameters', async () => {
            const params: GetRwusdSubscriptionHistoryRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            time: 1575018510000,
                            asset: 'USDC',
                            amount: '100',
                            receiveAsset: 'RWUSD',
                            receiveAmount: '100',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getRwusdSubscriptionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRwusdSubscriptionHistoryResponse>)
            );
            const response = await client.getRwusdSubscriptionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getRwusdSubscriptionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getRwusdSubscriptionHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemRwusd()', () => {
        it('should execute redeemRwusd() successfully with required parameters only', async () => {
            const params: RedeemRwusdRequest = {
                amount: 1.0,
                type: 's',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    receiveAmount: '0.23092091',
                    fee: '0.00000012',
                    arrivalTime: 1575018510000,
                })
            );

            const spy = jest.spyOn(client, 'redeemRwusd').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemRwusdResponse>)
            );
            const response = await client.redeemRwusd(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemRwusd() successfully with optional parameters', async () => {
            const params: RedeemRwusdRequest = {
                amount: 1.0,
                type: 's',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    success: true,
                    receiveAmount: '0.23092091',
                    fee: '0.00000012',
                    arrivalTime: 1575018510000,
                })
            );

            const spy = jest.spyOn(client, 'redeemRwusd').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemRwusdResponse>)
            );
            const response = await client.redeemRwusd(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: RedeemRwusdRequest = {
                amount: 1.0,
                type: 's',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.redeemRwusd(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling redeemRwusd.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: RedeemRwusdRequest = {
                amount: 1.0,
                type: 's',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.redeemRwusd(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling redeemRwusd.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemRwusdRequest = {
                amount: 1.0,
                type: 's',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'redeemRwusd').mockRejectedValueOnce(mockError);
            await expect(client.redeemRwusd(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subscribeRwusd()', () => {
        it('should execute subscribeRwusd() successfully with required parameters only', async () => {
            const params: SubscribeRwusdRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ success: true, rwusdAmount: '0.22091092' }));

            const spy = jest.spyOn(client, 'subscribeRwusd').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeRwusdResponse>)
            );
            const response = await client.subscribeRwusd(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeRwusd() successfully with optional parameters', async () => {
            const params: SubscribeRwusdRequest = {
                asset: 'asset_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true, rwusdAmount: '0.22091092' }));

            const spy = jest.spyOn(client, 'subscribeRwusd').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeRwusdResponse>)
            );
            const response = await client.subscribeRwusd(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: SubscribeRwusdRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.subscribeRwusd(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling subscribeRwusd.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeRwusdRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeRwusd(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeRwusd.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeRwusdRequest = {
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'subscribeRwusd').mockRejectedValueOnce(mockError);
            await expect(client.subscribeRwusd(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
