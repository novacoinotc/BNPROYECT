/**
 * Binance Simple Earn REST API
 *
 * OpenAPI Specification for the Binance Simple Earn REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { FlexibleLockedApi } from '../../../src/rest-api';
import {
    GetCollateralRecordRequest,
    GetFlexiblePersonalLeftQuotaRequest,
    GetFlexibleProductPositionRequest,
    GetFlexibleRedemptionRecordRequest,
    GetFlexibleRewardsHistoryRequest,
    GetFlexibleSubscriptionPreviewRequest,
    GetFlexibleSubscriptionRecordRequest,
    GetLockedPersonalLeftQuotaRequest,
    GetLockedProductPositionRequest,
    GetLockedRedemptionRecordRequest,
    GetLockedRewardsHistoryRequest,
    GetLockedSubscriptionPreviewRequest,
    GetLockedSubscriptionRecordRequest,
    GetRateHistoryRequest,
    GetSimpleEarnFlexibleProductListRequest,
    GetSimpleEarnLockedProductListRequest,
    RedeemFlexibleProductRequest,
    RedeemLockedProductRequest,
    SetFlexibleAutoSubscribeRequest,
    SetLockedAutoSubscribeRequest,
    SetLockedProductRedeemOptionRequest,
    SimpleAccountRequest,
    SubscribeFlexibleProductRequest,
    SubscribeLockedProductRequest,
} from '../../../src/rest-api';
import type {
    GetCollateralRecordResponse,
    GetFlexiblePersonalLeftQuotaResponse,
    GetFlexibleProductPositionResponse,
    GetFlexibleRedemptionRecordResponse,
    GetFlexibleRewardsHistoryResponse,
    GetFlexibleSubscriptionPreviewResponse,
    GetFlexibleSubscriptionRecordResponse,
    GetLockedPersonalLeftQuotaResponse,
    GetLockedProductPositionResponse,
    GetLockedRedemptionRecordResponse,
    GetLockedRewardsHistoryResponse,
    GetLockedSubscriptionPreviewResponse,
    GetLockedSubscriptionRecordResponse,
    GetRateHistoryResponse,
    GetSimpleEarnFlexibleProductListResponse,
    GetSimpleEarnLockedProductListResponse,
    RedeemFlexibleProductResponse,
    RedeemLockedProductResponse,
    SetFlexibleAutoSubscribeResponse,
    SetLockedAutoSubscribeResponse,
    SetLockedProductRedeemOptionResponse,
    SimpleAccountResponse,
    SubscribeFlexibleProductResponse,
    SubscribeLockedProductResponse,
} from '../../../src/rest-api/types';

describe('FlexibleLockedApi', () => {
    let client: FlexibleLockedApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new FlexibleLockedApi(config);
    });

    describe('getCollateralRecord()', () => {
        it('should execute getCollateralRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '100.00000000',
                            productId: 'BUSD001',
                            asset: 'USDT',
                            createTime: 1575018510000,
                            type: 'REPAY',
                            productName: 'USDT',
                            orderId: 26055,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getCollateralRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCollateralRecordResponse>)
            );
            const response = await client.getCollateralRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCollateralRecord() successfully with optional parameters', async () => {
            const params: GetCollateralRecordRequest = {
                productId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '100.00000000',
                            productId: 'BUSD001',
                            asset: 'USDT',
                            createTime: 1575018510000,
                            type: 'REPAY',
                            productName: 'USDT',
                            orderId: 26055,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getCollateralRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCollateralRecordResponse>)
            );
            const response = await client.getCollateralRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getCollateralRecord').mockRejectedValueOnce(mockError);
            await expect(client.getCollateralRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexiblePersonalLeftQuota()', () => {
        it('should execute getFlexiblePersonalLeftQuota() successfully with required parameters only', async () => {
            const params: GetFlexiblePersonalLeftQuotaRequest = {
                productId: '1',
            };

            mockResponse = JSONParse(JSONStringify({ leftPersonalQuota: '1000' }));

            const spy = jest.spyOn(client, 'getFlexiblePersonalLeftQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexiblePersonalLeftQuotaResponse>)
            );
            const response = await client.getFlexiblePersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexiblePersonalLeftQuota() successfully with optional parameters', async () => {
            const params: GetFlexiblePersonalLeftQuotaRequest = {
                productId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ leftPersonalQuota: '1000' }));

            const spy = jest.spyOn(client, 'getFlexiblePersonalLeftQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexiblePersonalLeftQuotaResponse>)
            );
            const response = await client.getFlexiblePersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: GetFlexiblePersonalLeftQuotaRequest = {
                productId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.getFlexiblePersonalLeftQuota(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling getFlexiblePersonalLeftQuota.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFlexiblePersonalLeftQuotaRequest = {
                productId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexiblePersonalLeftQuota')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexiblePersonalLeftQuota(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFlexibleProductPosition()', () => {
        it('should execute getFlexibleProductPosition() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            totalAmount: '75.46000000',
                            tierAnnualPercentageRate: { '0-5BTC': 0.05, '5-10BTC': 0.03 },
                            latestAnnualPercentageRate: '0.02599895',
                            yesterdayAirdropPercentageRate: '0.02599895',
                            asset: 'USDT',
                            airDropAsset: 'BETH',
                            canRedeem: true,
                            collateralAmount: '232.23123213',
                            productId: 'USDT001',
                            yesterdayRealTimeRewards: '0.10293829',
                            cumulativeBonusRewards: '0.22759183',
                            cumulativeRealTimeRewards: '0.22759183',
                            cumulativeTotalRewards: '0.45459183',
                            autoSubscribe: true,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleProductPositionResponse>)
            );
            const response = await client.getFlexibleProductPosition();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleProductPosition() successfully with optional parameters', async () => {
            const params: GetFlexibleProductPositionRequest = {
                asset: 'asset_example',
                productId: '1',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            totalAmount: '75.46000000',
                            tierAnnualPercentageRate: { '0-5BTC': 0.05, '5-10BTC': 0.03 },
                            latestAnnualPercentageRate: '0.02599895',
                            yesterdayAirdropPercentageRate: '0.02599895',
                            asset: 'USDT',
                            airDropAsset: 'BETH',
                            canRedeem: true,
                            collateralAmount: '232.23123213',
                            productId: 'USDT001',
                            yesterdayRealTimeRewards: '0.10293829',
                            cumulativeBonusRewards: '0.22759183',
                            cumulativeRealTimeRewards: '0.22759183',
                            cumulativeTotalRewards: '0.45459183',
                            autoSubscribe: true,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleProductPositionResponse>)
            );
            const response = await client.getFlexibleProductPosition(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleProductPosition')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleProductPosition()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleRedemptionRecord()', () => {
        it('should execute getFlexibleRedemptionRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '10.54000000',
                            asset: 'USDT',
                            time: 1577257222000,
                            projectId: 'USDT001',
                            redeemId: 40607,
                            destAccount: 'SPOT',
                            status: 'PAID',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRedemptionRecordResponse>)
            );
            const response = await client.getFlexibleRedemptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleRedemptionRecord() successfully with optional parameters', async () => {
            const params: GetFlexibleRedemptionRecordRequest = {
                productId: '1',
                redeemId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '10.54000000',
                            asset: 'USDT',
                            time: 1577257222000,
                            projectId: 'USDT001',
                            redeemId: 40607,
                            destAccount: 'SPOT',
                            status: 'PAID',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRedemptionRecordResponse>)
            );
            const response = await client.getFlexibleRedemptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleRedemptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleRedemptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleRewardsHistory()', () => {
        it('should execute getFlexibleRewardsHistory() successfully with required parameters only', async () => {
            const params: GetFlexibleRewardsHistoryRequest = {
                type: 's',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            asset: 'BUSD',
                            rewards: '0.00006408',
                            projectId: 'USDT001',
                            type: 'BONUS',
                            time: 1577233578000,
                        },
                        {
                            asset: 'USDT',
                            rewards: '0.00687654',
                            projectId: 'USDT001',
                            type: 'REALTIME',
                            time: 1577233562000,
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRewardsHistoryResponse>)
            );
            const response = await client.getFlexibleRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleRewardsHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleRewardsHistoryRequest = {
                type: 's',
                productId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            asset: 'BUSD',
                            rewards: '0.00006408',
                            projectId: 'USDT001',
                            type: 'BONUS',
                            time: 1577233578000,
                        },
                        {
                            asset: 'USDT',
                            rewards: '0.00687654',
                            projectId: 'USDT001',
                            type: 'REALTIME',
                            time: 1577233562000,
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRewardsHistoryResponse>)
            );
            const response = await client.getFlexibleRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: GetFlexibleRewardsHistoryRequest = {
                type: 's',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.getFlexibleRewardsHistory(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling getFlexibleRewardsHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFlexibleRewardsHistoryRequest = {
                type: 's',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleRewardsHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleSubscriptionPreview()', () => {
        it('should execute getFlexibleSubscriptionPreview() successfully with required parameters only', async () => {
            const params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalAmount: '1232.32230982',
                    rewardAsset: 'BUSD',
                    airDropAsset: 'BETH',
                    estDailyBonusRewards: '0.22759183',
                    estDailyRealTimeRewards: '0.22759183',
                    estDailyAirdropRewards: '0.22759183',
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionPreviewResponse>)
            );
            const response = await client.getFlexibleSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleSubscriptionPreview() successfully with optional parameters', async () => {
            const params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalAmount: '1232.32230982',
                    rewardAsset: 'BUSD',
                    airDropAsset: 'BETH',
                    estDailyBonusRewards: '0.22759183',
                    estDailyRealTimeRewards: '0.22759183',
                    estDailyAirdropRewards: '0.22759183',
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionPreviewResponse>)
            );
            const response = await client.getFlexibleSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.getFlexibleSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling getFlexibleSubscriptionPreview.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.getFlexibleSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling getFlexibleSubscriptionPreview.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleSubscriptionPreview')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleSubscriptionPreview(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFlexibleSubscriptionRecord()', () => {
        it('should execute getFlexibleSubscriptionRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '100.00000000',
                            asset: 'USDT',
                            time: 1575018510000,
                            purchaseId: 26055,
                            productId: 'USDT001',
                            type: 'AUTO',
                            sourceAccount: 'SPOT',
                            amtFromSpot: '30',
                            amtFromFunding: '70',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionRecordResponse>)
            );
            const response = await client.getFlexibleSubscriptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleSubscriptionRecord() successfully with optional parameters', async () => {
            const params: GetFlexibleSubscriptionRecordRequest = {
                productId: '1',
                purchaseId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            amount: '100.00000000',
                            asset: 'USDT',
                            time: 1575018510000,
                            purchaseId: 26055,
                            productId: 'USDT001',
                            type: 'AUTO',
                            sourceAccount: 'SPOT',
                            amtFromSpot: '30',
                            amtFromFunding: '70',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionRecordResponse>)
            );
            const response = await client.getFlexibleSubscriptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleSubscriptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleSubscriptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedPersonalLeftQuota()', () => {
        it('should execute getLockedPersonalLeftQuota() successfully with required parameters only', async () => {
            const params: GetLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };

            mockResponse = JSONParse(JSONStringify({ leftPersonalQuota: '1000' }));

            const spy = jest.spyOn(client, 'getLockedPersonalLeftQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedPersonalLeftQuotaResponse>)
            );
            const response = await client.getLockedPersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedPersonalLeftQuota() successfully with optional parameters', async () => {
            const params: GetLockedPersonalLeftQuotaRequest = {
                projectId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ leftPersonalQuota: '1000' }));

            const spy = jest.spyOn(client, 'getLockedPersonalLeftQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedPersonalLeftQuotaResponse>)
            );
            const response = await client.getLockedPersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getLockedPersonalLeftQuota(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getLockedPersonalLeftQuota.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedPersonalLeftQuota')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedPersonalLeftQuota(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getLockedProductPosition()', () => {
        it('should execute getLockedProductPosition() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            parentPositionId: 123122,
                            projectId: 'Axs*90',
                            asset: 'AXS',
                            amount: '122.09202928',
                            purchaseTime: '1646182276000',
                            duration: '60',
                            accrualDays: '4',
                            rewardAsset: 'AXS',
                            APY: '0.2032',
                            rewardAmt: '5.17181528',
                            extraRewardAsset: 'BNB',
                            extraRewardAPR: '0.0203',
                            estExtraRewardAmt: '5.17181528',
                            boostRewardAsset: 'AXS',
                            boostApr: '0.0121',
                            totalBoostRewardAmt: '3.98201829',
                            nextPay: '1.29295383',
                            nextPayDate: '1646697600000',
                            payPeriod: '1',
                            redeemAmountEarly: '2802.24068892',
                            rewardsEndDate: '1651449600000',
                            deliverDate: '1651536000000',
                            redeemPeriod: '1',
                            redeemingAmt: '232.2323',
                            redeemTo: 'FLEXIBLE',
                            partialAmtDeliverDate: '1651536000000',
                            canRedeemEarly: true,
                            canFastRedemption: true,
                            autoSubscribe: true,
                            type: 'AUTO',
                            status: 'HOLDING',
                            canReStake: true,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedProductPositionResponse>)
            );
            const response = await client.getLockedProductPosition();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedProductPosition() successfully with optional parameters', async () => {
            const params: GetLockedProductPositionRequest = {
                asset: 'asset_example',
                positionId: 1,
                projectId: '1',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            parentPositionId: 123122,
                            projectId: 'Axs*90',
                            asset: 'AXS',
                            amount: '122.09202928',
                            purchaseTime: '1646182276000',
                            duration: '60',
                            accrualDays: '4',
                            rewardAsset: 'AXS',
                            APY: '0.2032',
                            rewardAmt: '5.17181528',
                            extraRewardAsset: 'BNB',
                            extraRewardAPR: '0.0203',
                            estExtraRewardAmt: '5.17181528',
                            boostRewardAsset: 'AXS',
                            boostApr: '0.0121',
                            totalBoostRewardAmt: '3.98201829',
                            nextPay: '1.29295383',
                            nextPayDate: '1646697600000',
                            payPeriod: '1',
                            redeemAmountEarly: '2802.24068892',
                            rewardsEndDate: '1651449600000',
                            deliverDate: '1651536000000',
                            redeemPeriod: '1',
                            redeemingAmt: '232.2323',
                            redeemTo: 'FLEXIBLE',
                            partialAmtDeliverDate: '1651536000000',
                            canRedeemEarly: true,
                            canFastRedemption: true,
                            autoSubscribe: true,
                            type: 'AUTO',
                            status: 'HOLDING',
                            canReStake: true,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedProductPositionResponse>)
            );
            const response = await client.getLockedProductPosition(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedProductPosition')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedProductPosition()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedRedemptionRecord()', () => {
        it('should execute getLockedRedemptionRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            redeemId: 40607,
                            time: 1575018510000,
                            asset: 'BNB',
                            lockPeriod: '30',
                            amount: '21312.23223',
                            originalAmount: '21312.23223',
                            type: 'MATURE',
                            deliverDate: '1575018510000',
                            lossAmount: '0.00001232',
                            isComplete: true,
                            rewardAsset: 'AXS',
                            rewardAmt: '5.17181528',
                            extraRewardAsset: 'BNB',
                            estExtraRewardAmt: '5.17181528',
                            status: 'PAID',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRedemptionRecordResponse>)
            );
            const response = await client.getLockedRedemptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedRedemptionRecord() successfully with optional parameters', async () => {
            const params: GetLockedRedemptionRecordRequest = {
                positionId: 1,
                redeemId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            redeemId: 40607,
                            time: 1575018510000,
                            asset: 'BNB',
                            lockPeriod: '30',
                            amount: '21312.23223',
                            originalAmount: '21312.23223',
                            type: 'MATURE',
                            deliverDate: '1575018510000',
                            lossAmount: '0.00001232',
                            isComplete: true,
                            rewardAsset: 'AXS',
                            rewardAmt: '5.17181528',
                            extraRewardAsset: 'BNB',
                            estExtraRewardAmt: '5.17181528',
                            status: 'PAID',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRedemptionRecordResponse>)
            );
            const response = await client.getLockedRedemptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedRedemptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedRedemptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedRewardsHistory()', () => {
        it('should execute getLockedRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            time: 1575018510000,
                            asset: 'BNB',
                            lockPeriod: '30',
                            amount: '21312.23223',
                            type: 'Locked Rewards',
                        },
                        {
                            positionId: 123123,
                            time: 1575018510000,
                            asset: 'BNB',
                            amount: '1.23223',
                            type: 'Boost Rewards',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRewardsHistoryResponse>)
            );
            const response = await client.getLockedRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedRewardsHistory() successfully with optional parameters', async () => {
            const params: GetLockedRewardsHistoryRequest = {
                positionId: 1,
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            time: 1575018510000,
                            asset: 'BNB',
                            lockPeriod: '30',
                            amount: '21312.23223',
                            type: 'Locked Rewards',
                        },
                        {
                            positionId: 123123,
                            time: 1575018510000,
                            asset: 'BNB',
                            amount: '1.23223',
                            type: 'Boost Rewards',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRewardsHistoryResponse>)
            );
            const response = await client.getLockedRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedRewardsHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedSubscriptionPreview()', () => {
        it('should execute getLockedSubscriptionPreview() successfully with required parameters only', async () => {
            const params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        rewardAsset: 'AXS',
                        totalRewardAmt: '5.17181528',
                        extraRewardAsset: 'BNB',
                        estTotalExtraRewardAmt: '5.17181528',
                        boostRewardAsset: 'AXS',
                        estDailyRewardAmt: '1.20928901',
                        nextPay: '1.29295383',
                        nextPayDate: '1646697600000',
                        valueDate: '1646697600000',
                        rewardsEndDate: '1651449600000',
                        deliverDate: '1651536000000',
                        nextSubscriptionDate: '1651536000000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getLockedSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionPreviewResponse>)
            );
            const response = await client.getLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedSubscriptionPreview() successfully with optional parameters', async () => {
            const params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        rewardAsset: 'AXS',
                        totalRewardAmt: '5.17181528',
                        extraRewardAsset: 'BNB',
                        estTotalExtraRewardAmt: '5.17181528',
                        boostRewardAsset: 'AXS',
                        estDailyRewardAmt: '1.20928901',
                        nextPay: '1.29295383',
                        nextPayDate: '1646697600000',
                        valueDate: '1646697600000',
                        rewardsEndDate: '1651449600000',
                        deliverDate: '1651536000000',
                        nextSubscriptionDate: '1651536000000',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'getLockedSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionPreviewResponse>)
            );
            const response = await client.getLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getLockedSubscriptionPreview.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.getLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling getLockedSubscriptionPreview.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedSubscriptionPreview')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedSubscriptionPreview(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getLockedSubscriptionRecord()', () => {
        it('should execute getLockedSubscriptionRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            purchaseId: '26055',
                            projectId: 'Axs*90',
                            time: 1575018510000,
                            asset: 'BNB',
                            amount: '21312.23223',
                            lockPeriod: '30',
                            type: 'AUTO',
                            sourceAccount: 'SPOT',
                            amtFromSpot: '30',
                            amtFromFunding: '70',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionRecordResponse>)
            );
            const response = await client.getLockedSubscriptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedSubscriptionRecord() successfully with optional parameters', async () => {
            const params: GetLockedSubscriptionRecordRequest = {
                purchaseId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            positionId: 123123,
                            purchaseId: '26055',
                            projectId: 'Axs*90',
                            time: 1575018510000,
                            asset: 'BNB',
                            amount: '21312.23223',
                            lockPeriod: '30',
                            type: 'AUTO',
                            sourceAccount: 'SPOT',
                            amtFromSpot: '30',
                            amtFromFunding: '70',
                            status: 'SUCCESS',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getLockedSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionRecordResponse>)
            );
            const response = await client.getLockedSubscriptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedSubscriptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedSubscriptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRateHistory()', () => {
        it('should execute getRateHistory() successfully with required parameters only', async () => {
            const params: GetRateHistoryRequest = {
                productId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            productId: 'BUSD001',
                            asset: 'BUSD',
                            annualPercentageRate: '0.00006408',
                            time: 1577233578000,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRateHistoryResponse>)
            );
            const response = await client.getRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRateHistory() successfully with optional parameters', async () => {
            const params: GetRateHistoryRequest = {
                productId: '1',
                aprPeriod: 'DAY',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            productId: 'BUSD001',
                            asset: 'BUSD',
                            annualPercentageRate: '0.00006408',
                            time: 1577233578000,
                        },
                    ],
                    total: '1',
                })
            );

            const spy = jest.spyOn(client, 'getRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRateHistoryResponse>)
            );
            const response = await client.getRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: GetRateHistoryRequest = {
                productId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.getRateHistory(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling getRateHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetRateHistoryRequest = {
                productId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getRateHistory').mockRejectedValueOnce(mockError);
            await expect(client.getRateHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSimpleEarnFlexibleProductList()', () => {
        it('should execute getSimpleEarnFlexibleProductList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            asset: 'BTC',
                            latestAnnualPercentageRate: '0.05000000',
                            tierAnnualPercentageRate: { '0-5BTC': 0.05, '5-10BTC': 0.03 },
                            airDropPercentageRate: '0.05000000',
                            canPurchase: true,
                            canRedeem: true,
                            isSoldOut: true,
                            hot: true,
                            minPurchaseAmount: '0.01000000',
                            productId: 'BTC001',
                            subscriptionStartTime: 1646182276000,
                            status: 'PURCHASING',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSimpleEarnFlexibleProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSimpleEarnFlexibleProductListResponse>)
            );
            const response = await client.getSimpleEarnFlexibleProductList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSimpleEarnFlexibleProductList() successfully with optional parameters', async () => {
            const params: GetSimpleEarnFlexibleProductListRequest = {
                asset: 'asset_example',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            asset: 'BTC',
                            latestAnnualPercentageRate: '0.05000000',
                            tierAnnualPercentageRate: { '0-5BTC': 0.05, '5-10BTC': 0.03 },
                            airDropPercentageRate: '0.05000000',
                            canPurchase: true,
                            canRedeem: true,
                            isSoldOut: true,
                            hot: true,
                            minPurchaseAmount: '0.01000000',
                            productId: 'BTC001',
                            subscriptionStartTime: 1646182276000,
                            status: 'PURCHASING',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSimpleEarnFlexibleProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSimpleEarnFlexibleProductListResponse>)
            );
            const response = await client.getSimpleEarnFlexibleProductList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSimpleEarnFlexibleProductList')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSimpleEarnFlexibleProductList()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSimpleEarnLockedProductList()', () => {
        it('should execute getSimpleEarnLockedProductList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            projectId: 'Axs*90',
                            detail: {
                                asset: 'AXS',
                                rewardAsset: 'AXS',
                                duration: 90,
                                renewable: true,
                                isSoldOut: true,
                                apr: '1.2069',
                                status: 'CREATED',
                                subscriptionStartTime: 1646182276000,
                                extraRewardAsset: 'BNB',
                                extraRewardAPR: '0.23',
                                boostRewardAsset: 'AXS',
                                boostApr: '0.0121',
                                boostEndTime: 1646182276000,
                            },
                            quota: { totalPersonalQuota: '2', minimum: '0.001' },
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSimpleEarnLockedProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSimpleEarnLockedProductListResponse>)
            );
            const response = await client.getSimpleEarnLockedProductList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSimpleEarnLockedProductList() successfully with optional parameters', async () => {
            const params: GetSimpleEarnLockedProductListRequest = {
                asset: 'asset_example',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            projectId: 'Axs*90',
                            detail: {
                                asset: 'AXS',
                                rewardAsset: 'AXS',
                                duration: 90,
                                renewable: true,
                                isSoldOut: true,
                                apr: '1.2069',
                                status: 'CREATED',
                                subscriptionStartTime: 1646182276000,
                                extraRewardAsset: 'BNB',
                                extraRewardAPR: '0.23',
                                boostRewardAsset: 'AXS',
                                boostApr: '0.0121',
                                boostEndTime: 1646182276000,
                            },
                            quota: { totalPersonalQuota: '2', minimum: '0.001' },
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getSimpleEarnLockedProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSimpleEarnLockedProductListResponse>)
            );
            const response = await client.getSimpleEarnLockedProductList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSimpleEarnLockedProductList')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSimpleEarnLockedProductList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemFlexibleProduct()', () => {
        it('should execute redeemFlexibleProduct() successfully with required parameters only', async () => {
            const params: RedeemFlexibleProductRequest = {
                productId: '1',
            };

            mockResponse = JSONParse(JSONStringify({ redeemId: 40607, success: true }));

            const spy = jest.spyOn(client, 'redeemFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemFlexibleProductResponse>)
            );
            const response = await client.redeemFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemFlexibleProduct() successfully with optional parameters', async () => {
            const params: RedeemFlexibleProductRequest = {
                productId: '1',
                redeemAll: false,
                amount: 1.0,
                destAccount: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ redeemId: 40607, success: true }));

            const spy = jest.spyOn(client, 'redeemFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemFlexibleProductResponse>)
            );
            const response = await client.redeemFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: RedeemFlexibleProductRequest = {
                productId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.redeemFlexibleProduct(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling redeemFlexibleProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemFlexibleProductRequest = {
                productId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'redeemFlexibleProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.redeemFlexibleProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemLockedProduct()', () => {
        it('should execute redeemLockedProduct() successfully with required parameters only', async () => {
            const params: RedeemLockedProductRequest = {
                positionId: '1',
            };

            mockResponse = JSONParse(JSONStringify({ redeemId: 40607, success: true }));

            const spy = jest.spyOn(client, 'redeemLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemLockedProductResponse>)
            );
            const response = await client.redeemLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemLockedProduct() successfully with optional parameters', async () => {
            const params: RedeemLockedProductRequest = {
                positionId: '1',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ redeemId: 40607, success: true }));

            const spy = jest.spyOn(client, 'redeemLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemLockedProductResponse>)
            );
            const response = await client.redeemLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: RedeemLockedProductRequest = {
                positionId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.redeemLockedProduct(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling redeemLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemLockedProductRequest = {
                positionId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'redeemLockedProduct').mockRejectedValueOnce(mockError);
            await expect(client.redeemLockedProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setFlexibleAutoSubscribe()', () => {
        it('should execute setFlexibleAutoSubscribe() successfully with required parameters only', async () => {
            const params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setFlexibleAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetFlexibleAutoSubscribeResponse>)
            );
            const response = await client.setFlexibleAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setFlexibleAutoSubscribe() successfully with optional parameters', async () => {
            const params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setFlexibleAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetFlexibleAutoSubscribeResponse>)
            );
            const response = await client.setFlexibleAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.setFlexibleAutoSubscribe(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling setFlexibleAutoSubscribe.'
            );
        });

        it('should throw RequiredError when autoSubscribe is missing', async () => {
            const _params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.autoSubscribe;

            await expect(client.setFlexibleAutoSubscribe(params)).rejects.toThrow(
                'Required parameter autoSubscribe was null or undefined when calling setFlexibleAutoSubscribe.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setFlexibleAutoSubscribe')
                .mockRejectedValueOnce(mockError);
            await expect(client.setFlexibleAutoSubscribe(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setLockedAutoSubscribe()', () => {
        it('should execute setLockedAutoSubscribe() successfully with required parameters only', async () => {
            const params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedAutoSubscribeResponse>)
            );
            const response = await client.setLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setLockedAutoSubscribe() successfully with optional parameters', async () => {
            const params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedAutoSubscribeResponse>)
            );
            const response = await client.setLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setLockedAutoSubscribe.'
            );
        });

        it('should throw RequiredError when autoSubscribe is missing', async () => {
            const _params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.autoSubscribe;

            await expect(client.setLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter autoSubscribe was null or undefined when calling setLockedAutoSubscribe.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setLockedAutoSubscribe')
                .mockRejectedValueOnce(mockError);
            await expect(client.setLockedAutoSubscribe(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setLockedProductRedeemOption()', () => {
        it('should execute setLockedProductRedeemOption() successfully with required parameters only', async () => {
            const params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setLockedProductRedeemOption').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedProductRedeemOptionResponse>)
            );
            const response = await client.setLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setLockedProductRedeemOption() successfully with optional parameters', async () => {
            const params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'setLockedProductRedeemOption').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedProductRedeemOptionResponse>)
            );
            const response = await client.setLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setLockedProductRedeemOption.'
            );
        });

        it('should throw RequiredError when redeemTo is missing', async () => {
            const _params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.redeemTo;

            await expect(client.setLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter redeemTo was null or undefined when calling setLockedProductRedeemOption.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setLockedProductRedeemOption')
                .mockRejectedValueOnce(mockError);
            await expect(client.setLockedProductRedeemOption(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('simpleAccount()', () => {
        it('should execute simpleAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    totalAmountInBTC: '0.01067982',
                    totalAmountInUSDT: '77.13289230',
                    totalFlexibleAmountInBTC: '0.00000000',
                    totalFlexibleAmountInUSDT: '0.00000000',
                    totalLockedInBTC: '0.01067982',
                    totalLockedInUSDT: '77.13289230',
                })
            );

            const spy = jest.spyOn(client, 'simpleAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SimpleAccountResponse>)
            );
            const response = await client.simpleAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute simpleAccount() successfully with optional parameters', async () => {
            const params: SimpleAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalAmountInBTC: '0.01067982',
                    totalAmountInUSDT: '77.13289230',
                    totalFlexibleAmountInBTC: '0.00000000',
                    totalFlexibleAmountInUSDT: '0.00000000',
                    totalLockedInBTC: '0.01067982',
                    totalLockedInUSDT: '77.13289230',
                })
            );

            const spy = jest.spyOn(client, 'simpleAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SimpleAccountResponse>)
            );
            const response = await client.simpleAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'simpleAccount').mockRejectedValueOnce(mockError);
            await expect(client.simpleAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subscribeFlexibleProduct()', () => {
        it('should execute subscribeFlexibleProduct() successfully with required parameters only', async () => {
            const params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ purchaseId: 40607, success: true }));

            const spy = jest.spyOn(client, 'subscribeFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeFlexibleProductResponse>)
            );
            const response = await client.subscribeFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeFlexibleProduct() successfully with optional parameters', async () => {
            const params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1.0,
                autoSubscribe: true,
                sourceAccount: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ purchaseId: 40607, success: true }));

            const spy = jest.spyOn(client, 'subscribeFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeFlexibleProductResponse>)
            );
            const response = await client.subscribeFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.subscribeFlexibleProduct(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling subscribeFlexibleProduct.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeFlexibleProduct(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeFlexibleProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subscribeFlexibleProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.subscribeFlexibleProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subscribeLockedProduct()', () => {
        it('should execute subscribeLockedProduct() successfully with required parameters only', async () => {
            const params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({ purchaseId: 40607, positionId: '12345', success: true })
            );

            const spy = jest.spyOn(client, 'subscribeLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeLockedProductResponse>)
            );
            const response = await client.subscribeLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeLockedProduct() successfully with optional parameters', async () => {
            const params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
                autoSubscribe: true,
                sourceAccount: 'SPOT',
                redeemTo: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ purchaseId: 40607, positionId: '12345', success: true })
            );

            const spy = jest.spyOn(client, 'subscribeLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeLockedProductResponse>)
            );
            const response = await client.subscribeLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.subscribeLockedProduct(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling subscribeLockedProduct.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeLockedProduct(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subscribeLockedProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.subscribeLockedProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
