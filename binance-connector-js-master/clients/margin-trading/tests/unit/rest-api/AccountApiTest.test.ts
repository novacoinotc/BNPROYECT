/**
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AdjustCrossMarginMaxLeverageRequest,
    DisableIsolatedMarginAccountRequest,
    EnableIsolatedMarginAccountRequest,
    GetBnbBurnStatusRequest,
    GetSummaryOfMarginAccountRequest,
    QueryCrossIsolatedMarginCapitalFlowRequest,
    QueryCrossMarginAccountDetailsRequest,
    QueryCrossMarginFeeDataRequest,
    QueryEnabledIsolatedMarginAccountLimitRequest,
    QueryIsolatedMarginAccountInfoRequest,
    QueryIsolatedMarginFeeDataRequest,
} from '../../../src/rest-api';
import type {
    AdjustCrossMarginMaxLeverageResponse,
    DisableIsolatedMarginAccountResponse,
    EnableIsolatedMarginAccountResponse,
    GetBnbBurnStatusResponse,
    GetSummaryOfMarginAccountResponse,
    QueryCrossIsolatedMarginCapitalFlowResponse,
    QueryCrossMarginAccountDetailsResponse,
    QueryCrossMarginFeeDataResponse,
    QueryEnabledIsolatedMarginAccountLimitResponse,
    QueryIsolatedMarginAccountInfoResponse,
    QueryIsolatedMarginFeeDataResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('adjustCrossMarginMaxLeverage()', () => {
        it('should execute adjustCrossMarginMaxLeverage() successfully with required parameters only', async () => {
            const params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'adjustCrossMarginMaxLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AdjustCrossMarginMaxLeverageResponse>)
            );
            const response = await client.adjustCrossMarginMaxLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute adjustCrossMarginMaxLeverage() successfully with optional parameters', async () => {
            const params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };

            mockResponse = JSONParse(JSONStringify({ success: true }));

            const spy = jest.spyOn(client, 'adjustCrossMarginMaxLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AdjustCrossMarginMaxLeverageResponse>)
            );
            const response = await client.adjustCrossMarginMaxLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when maxLeverage is missing', async () => {
            const _params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.maxLeverage;

            await expect(client.adjustCrossMarginMaxLeverage(params)).rejects.toThrow(
                'Required parameter maxLeverage was null or undefined when calling adjustCrossMarginMaxLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'adjustCrossMarginMaxLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.adjustCrossMarginMaxLeverage(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('disableIsolatedMarginAccount()', () => {
        it('should execute disableIsolatedMarginAccount() successfully with required parameters only', async () => {
            const params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(JSONStringify({ success: true, symbol: 'BTCUSDT' }));

            const spy = jest.spyOn(client, 'disableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DisableIsolatedMarginAccountResponse>)
            );
            const response = await client.disableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute disableIsolatedMarginAccount() successfully with optional parameters', async () => {
            const params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true, symbol: 'BTCUSDT' }));

            const spy = jest.spyOn(client, 'disableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DisableIsolatedMarginAccountResponse>)
            );
            const response = await client.disableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.disableIsolatedMarginAccount(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling disableIsolatedMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'disableIsolatedMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.disableIsolatedMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('enableIsolatedMarginAccount()', () => {
        it('should execute enableIsolatedMarginAccount() successfully with required parameters only', async () => {
            const params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(JSONStringify({ success: true, symbol: 'BTCUSDT' }));

            const spy = jest.spyOn(client, 'enableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableIsolatedMarginAccountResponse>)
            );
            const response = await client.enableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableIsolatedMarginAccount() successfully with optional parameters', async () => {
            const params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ success: true, symbol: 'BTCUSDT' }));

            const spy = jest.spyOn(client, 'enableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableIsolatedMarginAccountResponse>)
            );
            const response = await client.enableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.enableIsolatedMarginAccount(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling enableIsolatedMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableIsolatedMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableIsolatedMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getBnbBurnStatus()', () => {
        it('should execute getBnbBurnStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ spotBNBBurn: true, interestBNBBurn: false }));

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBnbBurnStatus() successfully with optional parameters', async () => {
            const params: GetBnbBurnStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ spotBNBBurn: true, interestBNBBurn: false }));

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockRejectedValueOnce(mockError);
            await expect(client.getBnbBurnStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSummaryOfMarginAccount()', () => {
        it('should execute getSummaryOfMarginAccount() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    normalBar: '1.5',
                    marginCallBar: '1.3',
                    forceLiquidationBar: '1.1',
                })
            );

            const spy = jest.spyOn(client, 'getSummaryOfMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfMarginAccountResponse>)
            );
            const response = await client.getSummaryOfMarginAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfMarginAccount() successfully with optional parameters', async () => {
            const params: GetSummaryOfMarginAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    normalBar: '1.5',
                    marginCallBar: '1.3',
                    forceLiquidationBar: '1.1',
                })
            );

            const spy = jest.spyOn(client, 'getSummaryOfMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfMarginAccountResponse>)
            );
            const response = await client.getSummaryOfMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfMarginAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCrossIsolatedMarginCapitalFlow()', () => {
        it('should execute queryCrossIsolatedMarginCapitalFlow() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 123456,
                        tranId: 123123,
                        timestamp: 1691116657000,
                        asset: 'USDT',
                        symbol: 'BTCUSDT',
                        type: 'BORROW',
                        amount: '101',
                    },
                    {
                        id: 123457,
                        tranId: 123124,
                        timestamp: 1691116658000,
                        asset: 'BTC',
                        symbol: 'BTCUSDT',
                        type: 'REPAY',
                        amount: '10',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCrossIsolatedMarginCapitalFlow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossIsolatedMarginCapitalFlowResponse>)
            );
            const response = await client.queryCrossIsolatedMarginCapitalFlow();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCrossIsolatedMarginCapitalFlow() successfully with optional parameters', async () => {
            const params: QueryCrossIsolatedMarginCapitalFlowRequest = {
                asset: 'asset_example',
                symbol: 'symbol_example',
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 123456,
                        tranId: 123123,
                        timestamp: 1691116657000,
                        asset: 'USDT',
                        symbol: 'BTCUSDT',
                        type: 'BORROW',
                        amount: '101',
                    },
                    {
                        id: 123457,
                        tranId: 123124,
                        timestamp: 1691116658000,
                        asset: 'BTC',
                        symbol: 'BTCUSDT',
                        type: 'REPAY',
                        amount: '10',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCrossIsolatedMarginCapitalFlow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossIsolatedMarginCapitalFlowResponse>)
            );
            const response = await client.queryCrossIsolatedMarginCapitalFlow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCrossIsolatedMarginCapitalFlow')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCrossIsolatedMarginCapitalFlow()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryCrossMarginAccountDetails()', () => {
        it('should execute queryCrossMarginAccountDetails() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    created: true,
                    borrowEnabled: true,
                    marginLevel: '11.64405625',
                    collateralMarginLevel: '3.2',
                    totalAssetOfBtc: '6.82728457',
                    totalLiabilityOfBtc: '0.58633215',
                    totalNetAssetOfBtc: '6.24095242',
                    TotalCollateralValueInUSDT: '5.82728457',
                    totalOpenOrderLossInUSDT: '582.728457',
                    tradeEnabled: true,
                    transferInEnabled: true,
                    transferOutEnabled: true,
                    accountType: 'MARGIN_1',
                    userAssets: [
                        {
                            asset: 'BTC',
                            borrowed: '0.00000000',
                            free: '0.00499500',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00499500',
                        },
                        {
                            asset: 'BNB',
                            borrowed: '201.66666672',
                            free: '2346.50000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '2144.83333328',
                        },
                        {
                            asset: 'ETH',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                        {
                            asset: 'USDT',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryCrossMarginAccountDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginAccountDetailsResponse>)
            );
            const response = await client.queryCrossMarginAccountDetails();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCrossMarginAccountDetails() successfully with optional parameters', async () => {
            const params: QueryCrossMarginAccountDetailsRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    created: true,
                    borrowEnabled: true,
                    marginLevel: '11.64405625',
                    collateralMarginLevel: '3.2',
                    totalAssetOfBtc: '6.82728457',
                    totalLiabilityOfBtc: '0.58633215',
                    totalNetAssetOfBtc: '6.24095242',
                    TotalCollateralValueInUSDT: '5.82728457',
                    totalOpenOrderLossInUSDT: '582.728457',
                    tradeEnabled: true,
                    transferInEnabled: true,
                    transferOutEnabled: true,
                    accountType: 'MARGIN_1',
                    userAssets: [
                        {
                            asset: 'BTC',
                            borrowed: '0.00000000',
                            free: '0.00499500',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00499500',
                        },
                        {
                            asset: 'BNB',
                            borrowed: '201.66666672',
                            free: '2346.50000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '2144.83333328',
                        },
                        {
                            asset: 'ETH',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                        {
                            asset: 'USDT',
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryCrossMarginAccountDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginAccountDetailsResponse>)
            );
            const response = await client.queryCrossMarginAccountDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCrossMarginAccountDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCrossMarginAccountDetails()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCrossMarginFeeData()', () => {
        it('should execute queryCrossMarginFeeData() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        vipLevel: 0,
                        coin: 'BTC',
                        transferIn: true,
                        borrowable: true,
                        dailyInterest: '0.00026125',
                        yearlyInterest: '0.0953',
                        borrowLimit: '180',
                        marginablePairs: ['BNBBTC', 'TRXBTC', 'ETHBTC', 'BTCUSDT'],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCrossMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginFeeDataResponse>)
            );
            const response = await client.queryCrossMarginFeeData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCrossMarginFeeData() successfully with optional parameters', async () => {
            const params: QueryCrossMarginFeeDataRequest = {
                vipLevel: 1,
                coin: 'coin_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        vipLevel: 0,
                        coin: 'BTC',
                        transferIn: true,
                        borrowable: true,
                        dailyInterest: '0.00026125',
                        yearlyInterest: '0.0953',
                        borrowLimit: '180',
                        marginablePairs: ['BNBBTC', 'TRXBTC', 'ETHBTC', 'BTCUSDT'],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryCrossMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginFeeDataResponse>)
            );
            const response = await client.queryCrossMarginFeeData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCrossMarginFeeData')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCrossMarginFeeData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryEnabledIsolatedMarginAccountLimit()', () => {
        it('should execute queryEnabledIsolatedMarginAccountLimit() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ enabledAccount: 5, maxAccount: 20 }));

            const spy = jest
                .spyOn(client, 'queryEnabledIsolatedMarginAccountLimit')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryEnabledIsolatedMarginAccountLimitResponse>)
                );
            const response = await client.queryEnabledIsolatedMarginAccountLimit();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryEnabledIsolatedMarginAccountLimit() successfully with optional parameters', async () => {
            const params: QueryEnabledIsolatedMarginAccountLimitRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ enabledAccount: 5, maxAccount: 20 }));

            const spy = jest
                .spyOn(client, 'queryEnabledIsolatedMarginAccountLimit')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryEnabledIsolatedMarginAccountLimitResponse>)
                );
            const response = await client.queryEnabledIsolatedMarginAccountLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryEnabledIsolatedMarginAccountLimit')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryEnabledIsolatedMarginAccountLimit()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryIsolatedMarginAccountInfo()', () => {
        it('should execute queryIsolatedMarginAccountInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            baseAsset: {
                                asset: 'BTC',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            quoteAsset: {
                                asset: 'USDT',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            symbol: 'BTCUSDT',
                            isolatedCreated: true,
                            enabled: true,
                            marginLevel: '0.00000000',
                            marginLevelStatus: 'EXCESSIVE',
                            marginRatio: '0.00000000',
                            indexPrice: '10000.00000000',
                            liquidatePrice: '1000.00000000',
                            liquidateRate: '1.00000000',
                            tradeEnabled: true,
                        },
                        {
                            baseAsset: {
                                asset: 'BTC',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            quoteAsset: {
                                asset: 'USDT',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            symbol: 'BTCUSDT',
                            isolatedCreated: true,
                            enabled: true,
                            marginLevel: '0.00000000',
                            marginLevelStatus: 'EXCESSIVE',
                            marginRatio: '0.00000000',
                            indexPrice: '10000.00000000',
                            liquidatePrice: '1000.00000000',
                            liquidateRate: '1.00000000',
                            tradeEnabled: true,
                        },
                    ],
                    totalAssetOfBtc: '0.00000000',
                    totalLiabilityOfBtc: '0.00000000',
                    totalNetAssetOfBtc: '0.00000000',
                })
            );

            const spy = jest.spyOn(client, 'queryIsolatedMarginAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginAccountInfoResponse>)
            );
            const response = await client.queryIsolatedMarginAccountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIsolatedMarginAccountInfo() successfully with optional parameters', async () => {
            const params: QueryIsolatedMarginAccountInfoRequest = {
                symbols: 'symbols_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    assets: [
                        {
                            baseAsset: {
                                asset: 'BTC',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            quoteAsset: {
                                asset: 'USDT',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            symbol: 'BTCUSDT',
                            isolatedCreated: true,
                            enabled: true,
                            marginLevel: '0.00000000',
                            marginLevelStatus: 'EXCESSIVE',
                            marginRatio: '0.00000000',
                            indexPrice: '10000.00000000',
                            liquidatePrice: '1000.00000000',
                            liquidateRate: '1.00000000',
                            tradeEnabled: true,
                        },
                        {
                            baseAsset: {
                                asset: 'BTC',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            quoteAsset: {
                                asset: 'USDT',
                                borrowEnabled: true,
                                borrowed: '0.00000000',
                                free: '0.00000000',
                                interest: '0.00000000',
                                locked: '0.00000000',
                                netAsset: '0.00000000',
                                netAssetOfBtc: '0.00000000',
                                repayEnabled: true,
                                totalAsset: '0.00000000',
                            },
                            symbol: 'BTCUSDT',
                            isolatedCreated: true,
                            enabled: true,
                            marginLevel: '0.00000000',
                            marginLevelStatus: 'EXCESSIVE',
                            marginRatio: '0.00000000',
                            indexPrice: '10000.00000000',
                            liquidatePrice: '1000.00000000',
                            liquidateRate: '1.00000000',
                            tradeEnabled: true,
                        },
                    ],
                    totalAssetOfBtc: '0.00000000',
                    totalLiabilityOfBtc: '0.00000000',
                    totalNetAssetOfBtc: '0.00000000',
                })
            );

            const spy = jest.spyOn(client, 'queryIsolatedMarginAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginAccountInfoResponse>)
            );
            const response = await client.queryIsolatedMarginAccountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIsolatedMarginAccountInfo')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIsolatedMarginAccountInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryIsolatedMarginFeeData()', () => {
        it('should execute queryIsolatedMarginFeeData() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        vipLevel: 0,
                        symbol: 'BTCUSDT',
                        leverage: '10',
                        data: [
                            { coin: 'BTC', dailyInterest: '0.00026125', borrowLimit: '270' },
                            { coin: 'USDT', dailyInterest: '0.000475', borrowLimit: '2100000' },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryIsolatedMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginFeeDataResponse>)
            );
            const response = await client.queryIsolatedMarginFeeData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIsolatedMarginFeeData() successfully with optional parameters', async () => {
            const params: QueryIsolatedMarginFeeDataRequest = {
                vipLevel: 1,
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        vipLevel: 0,
                        symbol: 'BTCUSDT',
                        leverage: '10',
                        data: [
                            { coin: 'BTC', dailyInterest: '0.00026125', borrowLimit: '270' },
                            { coin: 'USDT', dailyInterest: '0.000475', borrowLimit: '2100000' },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryIsolatedMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginFeeDataResponse>)
            );
            const response = await client.queryIsolatedMarginFeeData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIsolatedMarginFeeData')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIsolatedMarginFeeData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
