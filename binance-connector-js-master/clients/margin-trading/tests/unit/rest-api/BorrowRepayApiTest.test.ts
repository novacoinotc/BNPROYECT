/**
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { BorrowRepayApi } from '../../../src/rest-api';
import {
    GetFutureHourlyInterestRateRequest,
    GetInterestHistoryRequest,
    MarginAccountBorrowRepayRequest,
    QueryBorrowRepayRecordsInMarginAccountRequest,
    QueryMarginInterestRateHistoryRequest,
    QueryMaxBorrowRequest,
} from '../../../src/rest-api';
import type {
    GetFutureHourlyInterestRateResponse,
    GetInterestHistoryResponse,
    MarginAccountBorrowRepayResponse,
    QueryBorrowRepayRecordsInMarginAccountResponse,
    QueryMarginInterestRateHistoryResponse,
    QueryMaxBorrowResponse,
} from '../../../src/rest-api/types';

describe('BorrowRepayApi', () => {
    let client: BorrowRepayApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new BorrowRepayApi(config);
    });

    describe('getFutureHourlyInterestRate()', () => {
        it('should execute getFutureHourlyInterestRate() successfully with required parameters only', async () => {
            const params: GetFutureHourlyInterestRateRequest = {
                assets: 'assets_example',
                isIsolated: false,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { asset: 'BTC', nextHourlyInterestRate: '0.00000571' },
                    { asset: 'ETH', nextHourlyInterestRate: '0.00000578' },
                ])
            );

            const spy = jest.spyOn(client, 'getFutureHourlyInterestRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFutureHourlyInterestRateResponse>)
            );
            const response = await client.getFutureHourlyInterestRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFutureHourlyInterestRate() successfully with optional parameters', async () => {
            const params: GetFutureHourlyInterestRateRequest = {
                assets: 'assets_example',
                isIsolated: false,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { asset: 'BTC', nextHourlyInterestRate: '0.00000571' },
                    { asset: 'ETH', nextHourlyInterestRate: '0.00000578' },
                ])
            );

            const spy = jest.spyOn(client, 'getFutureHourlyInterestRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFutureHourlyInterestRateResponse>)
            );
            const response = await client.getFutureHourlyInterestRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when assets is missing', async () => {
            const _params: GetFutureHourlyInterestRateRequest = {
                assets: 'assets_example',
                isIsolated: false,
            };
            const params = Object.assign({ ..._params });
            delete params?.assets;

            await expect(client.getFutureHourlyInterestRate(params)).rejects.toThrow(
                'Required parameter assets was null or undefined when calling getFutureHourlyInterestRate.'
            );
        });

        it('should throw RequiredError when isIsolated is missing', async () => {
            const _params: GetFutureHourlyInterestRateRequest = {
                assets: 'assets_example',
                isIsolated: false,
            };
            const params = Object.assign({ ..._params });
            delete params?.isIsolated;

            await expect(client.getFutureHourlyInterestRate(params)).rejects.toThrow(
                'Required parameter isIsolated was null or undefined when calling getFutureHourlyInterestRate.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFutureHourlyInterestRateRequest = {
                assets: 'assets_example',
                isIsolated: false,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFutureHourlyInterestRate')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFutureHourlyInterestRate(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getInterestHistory()', () => {
        it('should execute getInterestHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            txId: 1352286576452864800,
                            interestAccuredTime: 1672160400000,
                            asset: 'USDT',
                            rawAsset: 'USDT',
                            principal: '45.3313',
                            interest: '0.00024995',
                            interestRate: '0.00013233',
                            type: 'ON_BORROW',
                            isolatedSymbol: 'BNBUSDT',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getInterestHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetInterestHistoryResponse>)
            );
            const response = await client.getInterestHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getInterestHistory() successfully with optional parameters', async () => {
            const params: GetInterestHistoryRequest = {
                asset: 'asset_example',
                isolatedSymbol: 'isolatedSymbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            txId: 1352286576452864800,
                            interestAccuredTime: 1672160400000,
                            asset: 'USDT',
                            rawAsset: 'USDT',
                            principal: '45.3313',
                            interest: '0.00024995',
                            interestRate: '0.00013233',
                            type: 'ON_BORROW',
                            isolatedSymbol: 'BNBUSDT',
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest.spyOn(client, 'getInterestHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetInterestHistoryResponse>)
            );
            const response = await client.getInterestHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getInterestHistory').mockRejectedValueOnce(mockError);
            await expect(client.getInterestHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountBorrowRepay()', () => {
        it('should execute marginAccountBorrowRepay() successfully with required parameters only', async () => {
            const params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 100000001 }));

            const spy = jest.spyOn(client, 'marginAccountBorrowRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountBorrowRepayResponse>)
            );
            const response = await client.marginAccountBorrowRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountBorrowRepay() successfully with optional parameters', async () => {
            const params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 100000001 }));

            const spy = jest.spyOn(client, 'marginAccountBorrowRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountBorrowRepayResponse>)
            );
            const response = await client.marginAccountBorrowRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginAccountBorrowRepay(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginAccountBorrowRepay.'
            );
        });

        it('should throw RequiredError when isIsolated is missing', async () => {
            const _params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.isIsolated;

            await expect(client.marginAccountBorrowRepay(params)).rejects.toThrow(
                'Required parameter isIsolated was null or undefined when calling marginAccountBorrowRepay.'
            );
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountBorrowRepay(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountBorrowRepay.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.marginAccountBorrowRepay(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling marginAccountBorrowRepay.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.marginAccountBorrowRepay(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling marginAccountBorrowRepay.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountBorrowRepayRequest = {
                asset: 'asset_example',
                isIsolated: 'FALSE',
                symbol: 'symbol_example',
                amount: 'amount_example',
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountBorrowRepay')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountBorrowRepay(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryBorrowRepayRecordsInMarginAccount()', () => {
        it('should execute queryBorrowRepayRecordsInMarginAccount() successfully with required parameters only', async () => {
            const params: QueryBorrowRepayRecordsInMarginAccountRequest = {
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            type: 'AUTO',
                            isolatedSymbol: 'BNBUSDT',
                            amount: '14.00000000',
                            asset: 'BNB',
                            interest: '0.01866667',
                            principal: '13.98133333',
                            status: 'CONFIRMED',
                            timestamp: 1563438204000,
                            txId: 2970933056,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest
                .spyOn(client, 'queryBorrowRepayRecordsInMarginAccount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryBorrowRepayRecordsInMarginAccountResponse>)
                );
            const response = await client.queryBorrowRepayRecordsInMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryBorrowRepayRecordsInMarginAccount() successfully with optional parameters', async () => {
            const params: QueryBorrowRepayRecordsInMarginAccountRequest = {
                type: 'type_example',
                asset: 'asset_example',
                isolatedSymbol: 'isolatedSymbol_example',
                txId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            type: 'AUTO',
                            isolatedSymbol: 'BNBUSDT',
                            amount: '14.00000000',
                            asset: 'BNB',
                            interest: '0.01866667',
                            principal: '13.98133333',
                            status: 'CONFIRMED',
                            timestamp: 1563438204000,
                            txId: 2970933056,
                        },
                    ],
                    total: 1,
                })
            );

            const spy = jest
                .spyOn(client, 'queryBorrowRepayRecordsInMarginAccount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryBorrowRepayRecordsInMarginAccountResponse>)
                );
            const response = await client.queryBorrowRepayRecordsInMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: QueryBorrowRepayRecordsInMarginAccountRequest = {
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.queryBorrowRepayRecordsInMarginAccount(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling queryBorrowRepayRecordsInMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryBorrowRepayRecordsInMarginAccountRequest = {
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryBorrowRepayRecordsInMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryBorrowRepayRecordsInMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryMarginInterestRateHistory()', () => {
        it('should execute queryMarginInterestRateHistory() successfully with required parameters only', async () => {
            const params: QueryMarginInterestRateHistoryRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'BTC',
                        dailyInterestRate: '0.00025000',
                        timestamp: 1611544731000,
                        vipLevel: 1,
                    },
                    {
                        asset: 'BTC',
                        dailyInterestRate: '0.00035000',
                        timestamp: 1610248118000,
                        vipLevel: 1,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryMarginInterestRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginInterestRateHistoryResponse>)
            );
            const response = await client.queryMarginInterestRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginInterestRateHistory() successfully with optional parameters', async () => {
            const params: QueryMarginInterestRateHistoryRequest = {
                asset: 'asset_example',
                vipLevel: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'BTC',
                        dailyInterestRate: '0.00025000',
                        timestamp: 1611544731000,
                        vipLevel: 1,
                    },
                    {
                        asset: 'BTC',
                        dailyInterestRate: '0.00035000',
                        timestamp: 1610248118000,
                        vipLevel: 1,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'queryMarginInterestRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginInterestRateHistoryResponse>)
            );
            const response = await client.queryMarginInterestRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: QueryMarginInterestRateHistoryRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.queryMarginInterestRateHistory(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling queryMarginInterestRateHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginInterestRateHistoryRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginInterestRateHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginInterestRateHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryMaxBorrow()', () => {
        it('should execute queryMaxBorrow() successfully with required parameters only', async () => {
            const params: QueryMaxBorrowRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(JSONStringify({ amount: '1.69248805', borrowLimit: '60' }));

            const spy = jest.spyOn(client, 'queryMaxBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMaxBorrowResponse>)
            );
            const response = await client.queryMaxBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMaxBorrow() successfully with optional parameters', async () => {
            const params: QueryMaxBorrowRequest = {
                asset: 'asset_example',
                isolatedSymbol: 'isolatedSymbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ amount: '1.69248805', borrowLimit: '60' }));

            const spy = jest.spyOn(client, 'queryMaxBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMaxBorrowResponse>)
            );
            const response = await client.queryMaxBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: QueryMaxBorrowRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.queryMaxBorrow(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling queryMaxBorrow.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMaxBorrowRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryMaxBorrow').mockRejectedValueOnce(mockError);
            await expect(client.queryMaxBorrow(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
