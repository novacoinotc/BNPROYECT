/**
 * Binance Fiat REST API
 *
 * OpenAPI Specification for the Binance Fiat REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { FiatApi } from '../../../src/rest-api';
import {
    DepositRequest,
    FiatWithdrawRequest,
    GetFiatDepositWithdrawHistoryRequest,
    GetFiatPaymentsHistoryRequest,
    GetOrderDetailRequest,
} from '../../../src/rest-api';
import type {
    DepositResponse,
    FiatWithdrawResponse,
    GetFiatDepositWithdrawHistoryResponse,
    GetFiatPaymentsHistoryResponse,
    GetOrderDetailResponse,
} from '../../../src/rest-api/types';

describe('FiatApi', () => {
    let client: FiatApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new FiatApi(config);
    });

    describe('deposit()', () => {
        it('should execute deposit() successfully with required parameters only', async () => {
            const params: DepositRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: { orderId: '04595xxxxxxxxx37' },
                })
            );

            const spy = jest.spyOn(client, 'deposit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositResponse>)
            );
            const response = await client.deposit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deposit() successfully with optional parameters', async () => {
            const params: DepositRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                recvWindow: 5000,
                ext: Object,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: { orderId: '04595xxxxxxxxx37' },
                })
            );

            const spy = jest.spyOn(client, 'deposit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositResponse>)
            );
            const response = await client.deposit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when currency is missing', async () => {
            const _params: DepositRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.currency;

            await expect(client.deposit(params)).rejects.toThrow(
                'Required parameter currency was null or undefined when calling deposit.'
            );
        });

        it('should throw RequiredError when apiPaymentMethod is missing', async () => {
            const _params: DepositRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.apiPaymentMethod;

            await expect(client.deposit(params)).rejects.toThrow(
                'Required parameter apiPaymentMethod was null or undefined when calling deposit.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: DepositRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.deposit(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling deposit.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepositRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deposit').mockRejectedValueOnce(mockError);
            await expect(client.deposit(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fiatWithdraw()', () => {
        it('should execute fiatWithdraw() successfully with required parameters only', async () => {
            const params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: { orderId: '04595xxxxxxxxx37' },
                })
            );

            const spy = jest.spyOn(client, 'fiatWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FiatWithdrawResponse>)
            );
            const response = await client.fiatWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fiatWithdraw() successfully with optional parameters', async () => {
            const params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
                recvWindow: 5000,
                ext: Object,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: { orderId: '04595xxxxxxxxx37' },
                })
            );

            const spy = jest.spyOn(client, 'fiatWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FiatWithdrawResponse>)
            );
            const response = await client.fiatWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when currency is missing', async () => {
            const _params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
            };
            const params = Object.assign({ ..._params });
            delete params?.currency;

            await expect(client.fiatWithdraw(params)).rejects.toThrow(
                'Required parameter currency was null or undefined when calling fiatWithdraw.'
            );
        });

        it('should throw RequiredError when apiPaymentMethod is missing', async () => {
            const _params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
            };
            const params = Object.assign({ ..._params });
            delete params?.apiPaymentMethod;

            await expect(client.fiatWithdraw(params)).rejects.toThrow(
                'Required parameter apiPaymentMethod was null or undefined when calling fiatWithdraw.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.fiatWithdraw(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling fiatWithdraw.'
            );
        });

        it('should throw RequiredError when accountInfo is missing', async () => {
            const _params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
            };
            const params = Object.assign({ ..._params });
            delete params?.accountInfo;

            await expect(client.fiatWithdraw(params)).rejects.toThrow(
                'Required parameter accountInfo was null or undefined when calling fiatWithdraw.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FiatWithdrawRequest = {
                currency: 'currency_example',
                apiPaymentMethod: 'apiPaymentMethod_example',
                amount: 789,
                accountInfo: {},
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fiatWithdraw').mockRejectedValueOnce(mockError);
            await expect(client.fiatWithdraw(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFiatDepositWithdrawHistory()', () => {
        it('should execute getFiatDepositWithdrawHistory() successfully with required parameters only', async () => {
            const params: GetFiatDepositWithdrawHistoryRequest = {
                transactionType: 'transactionType_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: [
                        {
                            orderNo: '7d76d611-0568-4f43-afb6-24cac7767365',
                            fiatCurrency: 'BRL',
                            indicatedAmount: '10.00',
                            amount: '10.00',
                            totalFee: '0.00',
                            method: 'BankAccount',
                            status: 'Expired',
                            createTime: 1626144956000,
                            updateTime: 1626400907000,
                        },
                    ],
                    total: 1,
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'getFiatDepositWithdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFiatDepositWithdrawHistoryResponse>)
            );
            const response = await client.getFiatDepositWithdrawHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFiatDepositWithdrawHistory() successfully with optional parameters', async () => {
            const params: GetFiatDepositWithdrawHistoryRequest = {
                transactionType: 'transactionType_example',
                beginTime: 789,
                endTime: 1641782889000,
                page: 1,
                rows: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: [
                        {
                            orderNo: '7d76d611-0568-4f43-afb6-24cac7767365',
                            fiatCurrency: 'BRL',
                            indicatedAmount: '10.00',
                            amount: '10.00',
                            totalFee: '0.00',
                            method: 'BankAccount',
                            status: 'Expired',
                            createTime: 1626144956000,
                            updateTime: 1626400907000,
                        },
                    ],
                    total: 1,
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'getFiatDepositWithdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFiatDepositWithdrawHistoryResponse>)
            );
            const response = await client.getFiatDepositWithdrawHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when transactionType is missing', async () => {
            const _params: GetFiatDepositWithdrawHistoryRequest = {
                transactionType: 'transactionType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.transactionType;

            await expect(client.getFiatDepositWithdrawHistory(params)).rejects.toThrow(
                'Required parameter transactionType was null or undefined when calling getFiatDepositWithdrawHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFiatDepositWithdrawHistoryRequest = {
                transactionType: 'transactionType_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFiatDepositWithdrawHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFiatDepositWithdrawHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFiatPaymentsHistory()', () => {
        it('should execute getFiatPaymentsHistory() successfully with required parameters only', async () => {
            const params: GetFiatPaymentsHistoryRequest = {
                transactionType: 'transactionType_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: [
                        {
                            orderNo: '353fca443f06466db0c4dc89f94f027a',
                            sourceAmount: '20.0',
                            fiatCurrency: 'EUR',
                            obtainAmount: '4.462',
                            cryptoCurrency: 'LUNA',
                            totalFee: '0.2',
                            price: '4.437472',
                            status: 'Failed',
                            paymentMethod: 'Credit Card',
                            createTime: 1624529919000,
                            updateTime: 1624529919000,
                        },
                    ],
                    total: 1,
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'getFiatPaymentsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFiatPaymentsHistoryResponse>)
            );
            const response = await client.getFiatPaymentsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFiatPaymentsHistory() successfully with optional parameters', async () => {
            const params: GetFiatPaymentsHistoryRequest = {
                transactionType: 'transactionType_example',
                beginTime: 789,
                endTime: 1641782889000,
                page: 1,
                rows: 100,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: [
                        {
                            orderNo: '353fca443f06466db0c4dc89f94f027a',
                            sourceAmount: '20.0',
                            fiatCurrency: 'EUR',
                            obtainAmount: '4.462',
                            cryptoCurrency: 'LUNA',
                            totalFee: '0.2',
                            price: '4.437472',
                            status: 'Failed',
                            paymentMethod: 'Credit Card',
                            createTime: 1624529919000,
                            updateTime: 1624529919000,
                        },
                    ],
                    total: 1,
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'getFiatPaymentsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFiatPaymentsHistoryResponse>)
            );
            const response = await client.getFiatPaymentsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when transactionType is missing', async () => {
            const _params: GetFiatPaymentsHistoryRequest = {
                transactionType: 'transactionType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.transactionType;

            await expect(client.getFiatPaymentsHistory(params)).rejects.toThrow(
                'Required parameter transactionType was null or undefined when calling getFiatPaymentsHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFiatPaymentsHistoryRequest = {
                transactionType: 'transactionType_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFiatPaymentsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFiatPaymentsHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderDetail()', () => {
        it('should execute getOrderDetail() successfully with required parameters only', async () => {
            const params: GetOrderDetailRequest = {
                orderNo: 'orderNo_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        orderId: '036752*678',
                        orderStatus: 'ORDER_INITIAL',
                        amount: '4.33',
                        fee: '0.43',
                        fiatCurrency: '***',
                        errorCode: '',
                        errorMessage: '',
                        ext: {},
                    },
                })
            );

            const spy = jest.spyOn(client, 'getOrderDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderDetailResponse>)
            );
            const response = await client.getOrderDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderDetail() successfully with optional parameters', async () => {
            const params: GetOrderDetailRequest = {
                orderNo: 'orderNo_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: 'success',
                    data: {
                        orderId: '036752*678',
                        orderStatus: 'ORDER_INITIAL',
                        amount: '4.33',
                        fee: '0.43',
                        fiatCurrency: '***',
                        errorCode: '',
                        errorMessage: '',
                        ext: {},
                    },
                })
            );

            const spy = jest.spyOn(client, 'getOrderDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderDetailResponse>)
            );
            const response = await client.getOrderDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when orderNo is missing', async () => {
            const _params: GetOrderDetailRequest = {
                orderNo: 'orderNo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.orderNo;

            await expect(client.getOrderDetail(params)).rejects.toThrow(
                'Required parameter orderNo was null or undefined when calling getOrderDetail.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderDetailRequest = {
                orderNo: 'orderNo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrderDetail').mockRejectedValueOnce(mockError);
            await expect(client.getOrderDetail(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
