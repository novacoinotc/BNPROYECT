/**
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountApiTradingStatusRequest,
    AccountInfoRequest,
    AccountStatusRequest,
    DailyAccountSnapshotRequest,
    DisableFastWithdrawSwitchRequest,
    EnableFastWithdrawSwitchRequest,
    GetApiKeyPermissionRequest,
} from '../../../src/rest-api';
import type {
    AccountApiTradingStatusResponse,
    AccountInfoResponse,
    AccountStatusResponse,
    DailyAccountSnapshotResponse,
    GetApiKeyPermissionResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountApiTradingStatus()', () => {
        it('should execute accountApiTradingStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    data: {
                        isLocked: false,
                        plannedRecoverTime: 0,
                        triggerCondition: { GCR: 150, IFER: 150, UFR: 300 },
                        updateTime: 1547630471725,
                    },
                })
            );

            const spy = jest.spyOn(client, 'accountApiTradingStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountApiTradingStatusResponse>)
            );
            const response = await client.accountApiTradingStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountApiTradingStatus() successfully with optional parameters', async () => {
            const params: AccountApiTradingStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    data: {
                        isLocked: false,
                        plannedRecoverTime: 0,
                        triggerCondition: { GCR: 150, IFER: 150, UFR: 300 },
                        updateTime: 1547630471725,
                    },
                })
            );

            const spy = jest.spyOn(client, 'accountApiTradingStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountApiTradingStatusResponse>)
            );
            const response = await client.accountApiTradingStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'accountApiTradingStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.accountApiTradingStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountInfo()', () => {
        it('should execute accountInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    vipLevel: 0,
                    isMarginEnabled: true,
                    isFutureEnabled: true,
                    isOptionsEnabled: true,
                    isPortfolioMarginRetailEnabled: true,
                })
            );

            const spy = jest.spyOn(client, 'accountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInfoResponse>)
            );
            const response = await client.accountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInfo() successfully with optional parameters', async () => {
            const params: AccountInfoRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    vipLevel: 0,
                    isMarginEnabled: true,
                    isFutureEnabled: true,
                    isOptionsEnabled: true,
                    isPortfolioMarginRetailEnabled: true,
                })
            );

            const spy = jest.spyOn(client, 'accountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInfoResponse>)
            );
            const response = await client.accountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInfo').mockRejectedValueOnce(mockError);
            await expect(client.accountInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountStatus()', () => {
        it('should execute accountStatus() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ data: 'Normal' }));

            const spy = jest.spyOn(client, 'accountStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountStatusResponse>)
            );
            const response = await client.accountStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountStatus() successfully with optional parameters', async () => {
            const params: AccountStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ data: 'Normal' }));

            const spy = jest.spyOn(client, 'accountStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountStatusResponse>)
            );
            const response = await client.accountStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountStatus').mockRejectedValueOnce(mockError);
            await expect(client.accountStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dailyAccountSnapshot()', () => {
        it('should execute dailyAccountSnapshot() successfully with required parameters only', async () => {
            const params: DailyAccountSnapshotRequest = {
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: 200,
                    msg: '',
                    snapshotVos: [
                        {
                            data: {
                                balances: [
                                    { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                    { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                                ],
                                totalAssetOfBtc: '0.09942700',
                            },
                            type: 'spot',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                marginLevel: '2748.02909813',
                                totalAssetOfBtc: '0.00274803',
                                totalLiabilityOfBtc: '0.00000100',
                                totalNetAssetOfBtc: '0.00274750',
                                userAssets: [
                                    {
                                        asset: 'XRP',
                                        borrowed: '0.00000000',
                                        free: '1.00000000',
                                        interest: '0.00000000',
                                        locked: '0.00000000',
                                        netAsset: '1.00000000',
                                    },
                                ],
                            },
                            type: 'margin',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                assets: [
                                    {
                                        asset: 'USDT',
                                        marginBalance: '118.99782335',
                                        walletBalance: '120.23811389',
                                    },
                                ],
                                position: [
                                    {
                                        entryPrice: '7130.41000000',
                                        markPrice: '7257.66239673',
                                        positionAmt: '0.01000000',
                                        symbol: 'BTCUSDT',
                                        unRealizedProfit: '1.24029054',
                                    },
                                ],
                            },
                            type: 'futures',
                            updateTime: 1576281599000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dailyAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DailyAccountSnapshotResponse>)
            );
            const response = await client.dailyAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dailyAccountSnapshot() successfully with optional parameters', async () => {
            const params: DailyAccountSnapshotRequest = {
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 7,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: 200,
                    msg: '',
                    snapshotVos: [
                        {
                            data: {
                                balances: [
                                    { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                    { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                                ],
                                totalAssetOfBtc: '0.09942700',
                            },
                            type: 'spot',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                marginLevel: '2748.02909813',
                                totalAssetOfBtc: '0.00274803',
                                totalLiabilityOfBtc: '0.00000100',
                                totalNetAssetOfBtc: '0.00274750',
                                userAssets: [
                                    {
                                        asset: 'XRP',
                                        borrowed: '0.00000000',
                                        free: '1.00000000',
                                        interest: '0.00000000',
                                        locked: '0.00000000',
                                        netAsset: '1.00000000',
                                    },
                                ],
                            },
                            type: 'margin',
                            updateTime: 1576281599000,
                        },
                        {
                            data: {
                                assets: [
                                    {
                                        asset: 'USDT',
                                        marginBalance: '118.99782335',
                                        walletBalance: '120.23811389',
                                    },
                                ],
                                position: [
                                    {
                                        entryPrice: '7130.41000000',
                                        markPrice: '7257.66239673',
                                        positionAmt: '0.01000000',
                                        symbol: 'BTCUSDT',
                                        unRealizedProfit: '1.24029054',
                                    },
                                ],
                            },
                            type: 'futures',
                            updateTime: 1576281599000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dailyAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DailyAccountSnapshotResponse>)
            );
            const response = await client.dailyAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: DailyAccountSnapshotRequest = {
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.dailyAccountSnapshot(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling dailyAccountSnapshot.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DailyAccountSnapshotRequest = {
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dailyAccountSnapshot').mockRejectedValueOnce(mockError);
            await expect(client.dailyAccountSnapshot(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('disableFastWithdrawSwitch()', () => {
        it('should execute disableFastWithdrawSwitch() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'disableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.disableFastWithdrawSwitch();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute disableFastWithdrawSwitch() successfully with optional parameters', async () => {
            const params: DisableFastWithdrawSwitchRequest = {
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'disableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.disableFastWithdrawSwitch(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'disableFastWithdrawSwitch')
                .mockRejectedValueOnce(mockError);
            await expect(client.disableFastWithdrawSwitch()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('enableFastWithdrawSwitch()', () => {
        it('should execute enableFastWithdrawSwitch() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'enableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.enableFastWithdrawSwitch();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute enableFastWithdrawSwitch() successfully with optional parameters', async () => {
            const params: EnableFastWithdrawSwitchRequest = {
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'enableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.enableFastWithdrawSwitch(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableFastWithdrawSwitch')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableFastWithdrawSwitch()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getApiKeyPermission()', () => {
        it('should execute getApiKeyPermission() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    ipRestrict: false,
                    createTime: 1698645219000,
                    enableReading: true,
                    enableWithdrawals: false,
                    enableInternalTransfer: false,
                    enableMargin: false,
                    enableFutures: false,
                    permitsUniversalTransfer: false,
                    enableVanillaOptions: false,
                    enableFixApiTrade: false,
                    enableFixReadOnly: true,
                    enableSpotAndMarginTrading: false,
                    enablePortfolioMarginTrading: true,
                })
            );

            const spy = jest.spyOn(client, 'getApiKeyPermission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetApiKeyPermissionResponse>)
            );
            const response = await client.getApiKeyPermission();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getApiKeyPermission() successfully with optional parameters', async () => {
            const params: GetApiKeyPermissionRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    ipRestrict: false,
                    createTime: 1698645219000,
                    enableReading: true,
                    enableWithdrawals: false,
                    enableInternalTransfer: false,
                    enableMargin: false,
                    enableFutures: false,
                    permitsUniversalTransfer: false,
                    enableVanillaOptions: false,
                    enableFixApiTrade: false,
                    enableFixReadOnly: true,
                    enableSpotAndMarginTrading: false,
                    enablePortfolioMarginTrading: true,
                })
            );

            const spy = jest.spyOn(client, 'getApiKeyPermission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetApiKeyPermissionResponse>)
            );
            const response = await client.getApiKeyPermission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getApiKeyPermission').mockRejectedValueOnce(mockError);
            await expect(client.getApiKeyPermission()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
