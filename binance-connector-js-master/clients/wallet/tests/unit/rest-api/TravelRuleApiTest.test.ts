/**
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { TravelRuleApi } from '../../../src/rest-api';
import {
    BrokerWithdrawRequest,
    CheckQuestionnaireRequirementsRequest,
    DepositHistoryTravelRuleRequest,
    DepositHistoryV2Request,
    FetchAddressVerificationListRequest,
    SubmitDepositQuestionnaireRequest,
    SubmitDepositQuestionnaireTravelRuleRequest,
    SubmitDepositQuestionnaireV2Request,
    VaspListRequest,
    WithdrawHistoryV1Request,
    WithdrawHistoryV2Request,
    WithdrawTravelRuleRequest,
} from '../../../src/rest-api';
import type {
    BrokerWithdrawResponse,
    CheckQuestionnaireRequirementsResponse,
    DepositHistoryTravelRuleResponse,
    DepositHistoryV2Response,
    FetchAddressVerificationListResponse,
    SubmitDepositQuestionnaireResponse,
    SubmitDepositQuestionnaireTravelRuleResponse,
    SubmitDepositQuestionnaireV2Response,
    VaspListResponse,
    WithdrawHistoryV1Response,
    WithdrawHistoryV2Response,
    WithdrawTravelRuleResponse,
} from '../../../src/rest-api/types';

describe('TravelRuleApi', () => {
    let client: TravelRuleApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TravelRuleApi(config);
    });

    describe('brokerWithdraw()', () => {
        it('should execute brokerWithdraw() successfully with required parameters only', async () => {
            const params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ trId: 123456, accpted: true, info: 'Withdraw request accepted' })
            );

            const spy = jest.spyOn(client, 'brokerWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BrokerWithdrawResponse>)
            );
            const response = await client.brokerWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute brokerWithdraw() successfully with optional parameters', async () => {
            const params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
                addressTag: 'addressTag_example',
                network: 'network_example',
                addressName: 'addressName_example',
                transactionFeeFlag: false,
                walletType: 0,
            };

            mockResponse = JSONParse(
                JSONStringify({ trId: 123456, accpted: true, info: 'Withdraw request accepted' })
            );

            const spy = jest.spyOn(client, 'brokerWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BrokerWithdrawResponse>)
            );
            const response = await client.brokerWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when address is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.address;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter address was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when withdrawOrderId is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.withdrawOrderId;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter withdrawOrderId was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when originatorPii is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.originatorPii;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter originatorPii was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when signature is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.signature;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter signature was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BrokerWithdrawRequest = {
                address: 'address_example',
                coin: 'coin_example',
                amount: 1.0,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'brokerWithdraw').mockRejectedValueOnce(mockError);
            await expect(client.brokerWithdraw(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('checkQuestionnaireRequirements()', () => {
        it('should execute checkQuestionnaireRequirements() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ questionnaireCountryCode: 'AE' }));

            const spy = jest.spyOn(client, 'checkQuestionnaireRequirements').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckQuestionnaireRequirementsResponse>)
            );
            const response = await client.checkQuestionnaireRequirements();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute checkQuestionnaireRequirements() successfully with optional parameters', async () => {
            const params: CheckQuestionnaireRequirementsRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ questionnaireCountryCode: 'AE' }));

            const spy = jest.spyOn(client, 'checkQuestionnaireRequirements').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckQuestionnaireRequirementsResponse>)
            );
            const response = await client.checkQuestionnaireRequirements(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'checkQuestionnaireRequirements')
                .mockRejectedValueOnce(mockError);
            await expect(client.checkQuestionnaireRequirements()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositHistoryTravelRule()', () => {
        it('should execute depositHistoryTravelRule() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        trId: 123451123,
                        tranId: 17644346245865,
                        amount: '0.001',
                        coin: 'BNB',
                        network: 'BNB',
                        depositStatus: 0,
                        travelRuleStatus: 1,
                        address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                        addressTag: '101764890',
                        txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                        insertTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        requireQuestionnaire: false,
                        questionnaire: null,
                    },
                    {
                        trId: 2451123,
                        tranId: 4544346245865,
                        amount: '0.50000000',
                        coin: 'IOTA',
                        network: 'IOTA',
                        depositStatus: 0,
                        travelRuleStatus: 0,
                        address:
                            'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                        addressTag: '',
                        txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                        insertTime: 1599620082000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        requireQuestionnaire: false,
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'depositHistoryTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryTravelRuleResponse>)
            );
            const response = await client.depositHistoryTravelRule();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositHistoryTravelRule() successfully with optional parameters', async () => {
            const params: DepositHistoryTravelRuleRequest = {
                trId: '1',
                txId: '1',
                tranId: '1',
                network: 'network_example',
                coin: 'coin_example',
                travelRuleStatus: 789,
                pendingQuestionnaire: true,
                startTime: 1623319461670,
                endTime: 1641782889000,
                offset: 0,
                limit: 7,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        trId: 123451123,
                        tranId: 17644346245865,
                        amount: '0.001',
                        coin: 'BNB',
                        network: 'BNB',
                        depositStatus: 0,
                        travelRuleStatus: 1,
                        address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                        addressTag: '101764890',
                        txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                        insertTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        requireQuestionnaire: false,
                        questionnaire: null,
                    },
                    {
                        trId: 2451123,
                        tranId: 4544346245865,
                        amount: '0.50000000',
                        coin: 'IOTA',
                        network: 'IOTA',
                        depositStatus: 0,
                        travelRuleStatus: 0,
                        address:
                            'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                        addressTag: '',
                        txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                        insertTime: 1599620082000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        requireQuestionnaire: false,
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'depositHistoryTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryTravelRuleResponse>)
            );
            const response = await client.depositHistoryTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'depositHistoryTravelRule')
                .mockRejectedValueOnce(mockError);
            await expect(client.depositHistoryTravelRule()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositHistoryV2()', () => {
        it('should execute depositHistoryV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        depositId: '4615328107052018945',
                        amount: '0.01',
                        network: 'AVAXC',
                        coin: 'AVAX',
                        depositStatus: 1,
                        travelRuleReqStatus: 0,
                        address: '0x0010627ab66d69232f4080d54e0f838b4dc3894a',
                        addressTag: '',
                        txId: '0xdde578983015741eed764e7ca10defb5a2caafdca3db5f92872d24a96beb1879',
                        transferType: 0,
                        confirmTimes: '12/12',
                        requireQuestionnaire: false,
                        questionnaire: { vaspName: 'BINANCE', depositOriginator: 0 },
                        insertTime: 1753053392000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'depositHistoryV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryV2Response>)
            );
            const response = await client.depositHistoryV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositHistoryV2() successfully with optional parameters', async () => {
            const params: DepositHistoryV2Request = {
                depositId: '1',
                txId: '1',
                network: 'network_example',
                coin: 'coin_example',
                retrieveQuestionnaire: true,
                startTime: 1623319461670,
                endTime: 1641782889000,
                offset: 0,
                limit: 7,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        depositId: '4615328107052018945',
                        amount: '0.01',
                        network: 'AVAXC',
                        coin: 'AVAX',
                        depositStatus: 1,
                        travelRuleReqStatus: 0,
                        address: '0x0010627ab66d69232f4080d54e0f838b4dc3894a',
                        addressTag: '',
                        txId: '0xdde578983015741eed764e7ca10defb5a2caafdca3db5f92872d24a96beb1879',
                        transferType: 0,
                        confirmTimes: '12/12',
                        requireQuestionnaire: false,
                        questionnaire: { vaspName: 'BINANCE', depositOriginator: 0 },
                        insertTime: 1753053392000,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'depositHistoryV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryV2Response>)
            );
            const response = await client.depositHistoryV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depositHistoryV2').mockRejectedValueOnce(mockError);
            await expect(client.depositHistoryV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fetchAddressVerificationList()', () => {
        it('should execute fetchAddressVerificationList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        status: 'PENDING',
                        token: 'AVAX',
                        network: 'AVAXC',
                        walletAddress: '0xc03a6aa728a8dde7464c33828424ede7553a0021',
                        addressQuestionnaire: {
                            sendTo: 1,
                            satoshiToken: 'AVAX',
                            isAddressOwner: 1,
                            verifyMethod: 1,
                        },
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fetchAddressVerificationList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchAddressVerificationListResponse>)
            );
            const response = await client.fetchAddressVerificationList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fetchAddressVerificationList() successfully with optional parameters', async () => {
            const params: FetchAddressVerificationListRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        status: 'PENDING',
                        token: 'AVAX',
                        network: 'AVAXC',
                        walletAddress: '0xc03a6aa728a8dde7464c33828424ede7553a0021',
                        addressQuestionnaire: {
                            sendTo: 1,
                            satoshiToken: 'AVAX',
                            isAddressOwner: 1,
                            verifyMethod: 1,
                        },
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fetchAddressVerificationList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchAddressVerificationListResponse>)
            );
            const response = await client.fetchAddressVerificationList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fetchAddressVerificationList')
                .mockRejectedValueOnce(mockError);
            await expect(client.fetchAddressVerificationList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('submitDepositQuestionnaire()', () => {
        it('should execute submitDepositQuestionnaire() successfully with required parameters only', async () => {
            const params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    trId: 765127651,
                    accepted: true,
                    info: 'Deposit questionnaire accepted.',
                })
            );

            const spy = jest.spyOn(client, 'submitDepositQuestionnaire').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireResponse>)
            );
            const response = await client.submitDepositQuestionnaire(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute submitDepositQuestionnaire() successfully with optional parameters', async () => {
            const params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
                network: 'network_example',
                coin: 'coin_example',
                amount: 1.0,
                address: 'address_example',
                addressTag: 'addressTag_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    trId: 765127651,
                    accepted: true,
                    info: 'Deposit questionnaire accepted.',
                })
            );

            const spy = jest.spyOn(client, 'submitDepositQuestionnaire').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireResponse>)
            );
            const response = await client.submitDepositQuestionnaire(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when subAccountId is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.subAccountId;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter subAccountId was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when depositId is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.depositId;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter depositId was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when beneficiaryPii is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.beneficiaryPii;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter beneficiaryPii was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when signature is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.signature;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter signature was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: 1,
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'submitDepositQuestionnaire')
                .mockRejectedValueOnce(mockError);
            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('submitDepositQuestionnaireTravelRule()', () => {
        it('should execute submitDepositQuestionnaireTravelRule() successfully with required parameters only', async () => {
            const params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    trId: 765127651,
                    accepted: true,
                    info: 'Deposit questionnaire accepted.',
                })
            );

            const spy = jest.spyOn(client, 'submitDepositQuestionnaireTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireTravelRuleResponse>)
            );
            const response = await client.submitDepositQuestionnaireTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute submitDepositQuestionnaireTravelRule() successfully with optional parameters', async () => {
            const params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    trId: 765127651,
                    accepted: true,
                    info: 'Deposit questionnaire accepted.',
                })
            );

            const spy = jest.spyOn(client, 'submitDepositQuestionnaireTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireTravelRuleResponse>)
            );
            const response = await client.submitDepositQuestionnaireTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when tranId is missing', async () => {
            const _params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.tranId;

            await expect(client.submitDepositQuestionnaireTravelRule(params)).rejects.toThrow(
                'Required parameter tranId was null or undefined when calling submitDepositQuestionnaireTravelRule.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.submitDepositQuestionnaireTravelRule(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling submitDepositQuestionnaireTravelRule.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'submitDepositQuestionnaireTravelRule')
                .mockRejectedValueOnce(mockError);
            await expect(client.submitDepositQuestionnaireTravelRule(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('submitDepositQuestionnaireV2()', () => {
        it('should execute submitDepositQuestionnaireV2() successfully with required parameters only', async () => {
            const params: SubmitDepositQuestionnaireV2Request = {
                depositId: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    trId: 765127651,
                    accepted: true,
                    info: 'Deposit questionnaire accepted.',
                })
            );

            const spy = jest.spyOn(client, 'submitDepositQuestionnaireV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireV2Response>)
            );
            const response = await client.submitDepositQuestionnaireV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute submitDepositQuestionnaireV2() successfully with optional parameters', async () => {
            const params: SubmitDepositQuestionnaireV2Request = {
                depositId: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    trId: 765127651,
                    accepted: true,
                    info: 'Deposit questionnaire accepted.',
                })
            );

            const spy = jest.spyOn(client, 'submitDepositQuestionnaireV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireV2Response>)
            );
            const response = await client.submitDepositQuestionnaireV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when depositId is missing', async () => {
            const _params: SubmitDepositQuestionnaireV2Request = {
                depositId: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.depositId;

            await expect(client.submitDepositQuestionnaireV2(params)).rejects.toThrow(
                'Required parameter depositId was null or undefined when calling submitDepositQuestionnaireV2.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: SubmitDepositQuestionnaireV2Request = {
                depositId: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.submitDepositQuestionnaireV2(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling submitDepositQuestionnaireV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubmitDepositQuestionnaireV2Request = {
                depositId: 1,
                questionnaire: 'questionnaire_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'submitDepositQuestionnaireV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.submitDepositQuestionnaireV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('vaspList()', () => {
        it('should execute vaspList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { vaspName: 'Binance', vaspCode: 'BINANCE' },
                    { vaspName: 'HashKeyGlobal', vaspCode: 'NVBH3Z_nNEHjvqbUfkaL' },
                ])
            );

            const spy = jest.spyOn(client, 'vaspList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<VaspListResponse>)
            );
            const response = await client.vaspList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute vaspList() successfully with optional parameters', async () => {
            const params: VaspListRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { vaspName: 'Binance', vaspCode: 'BINANCE' },
                    { vaspName: 'HashKeyGlobal', vaspCode: 'NVBH3Z_nNEHjvqbUfkaL' },
                ])
            );

            const spy = jest.spyOn(client, 'vaspList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<VaspListResponse>)
            );
            const response = await client.vaspList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'vaspList').mockRejectedValueOnce(mockError);
            await expect(client.vaspList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawHistoryV1()', () => {
        it('should execute withdrawHistoryV1() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 'b6ae22b3aa844210a7041aee7589627c',
                        trId: 1234456,
                        amount: '8.91000000',
                        transactionFee: '0.004',
                        coin: 'USDT',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                        addressTag: '1231212',
                        txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                        applyTime: '2019-10-12 11:12:02',
                        network: 'ETH',
                        transferType: 0,
                        withdrawOrderId: 'WITHDRAWtest123',
                        info: 'The address is not valid. Please confirm with the recipient',
                        confirmNo: 3,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                    {
                        id: '156ec387f49b41df8724fa744fa82719',
                        trId: 2231556234,
                        amount: '0.00150000',
                        transactionFee: '0.004',
                        coin: 'BTC',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                        txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                        applyTime: '2019-09-24 12:43:45',
                        network: 'BTC',
                        transferType: 0,
                        info: '',
                        confirmNo: 2,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'withdrawHistoryV1').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV1Response>)
            );
            const response = await client.withdrawHistoryV1();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawHistoryV1() successfully with optional parameters', async () => {
            const params: WithdrawHistoryV1Request = {
                trId: '1',
                txId: '1',
                withdrawOrderId: '1',
                network: 'network_example',
                coin: 'coin_example',
                travelRuleStatus: 789,
                offset: 0,
                limit: 7,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 'b6ae22b3aa844210a7041aee7589627c',
                        trId: 1234456,
                        amount: '8.91000000',
                        transactionFee: '0.004',
                        coin: 'USDT',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                        addressTag: '1231212',
                        txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                        applyTime: '2019-10-12 11:12:02',
                        network: 'ETH',
                        transferType: 0,
                        withdrawOrderId: 'WITHDRAWtest123',
                        info: 'The address is not valid. Please confirm with the recipient',
                        confirmNo: 3,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                    {
                        id: '156ec387f49b41df8724fa744fa82719',
                        trId: 2231556234,
                        amount: '0.00150000',
                        transactionFee: '0.004',
                        coin: 'BTC',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                        txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                        applyTime: '2019-09-24 12:43:45',
                        network: 'BTC',
                        transferType: 0,
                        info: '',
                        confirmNo: 2,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'withdrawHistoryV1').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV1Response>)
            );
            const response = await client.withdrawHistoryV1(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawHistoryV1').mockRejectedValueOnce(mockError);
            await expect(client.withdrawHistoryV1()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawHistoryV2()', () => {
        it('should execute withdrawHistoryV2() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 'b6ae22b3aa844210a7041aee7589627c',
                        trId: 1234456,
                        amount: '8.91000000',
                        transactionFee: '0.004',
                        coin: 'USDT',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                        addressTag: '1231212',
                        txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                        applyTime: '2019-10-12 11:12:02',
                        network: 'ETH',
                        transferType: 0,
                        withdrawOrderId: 'WITHDRAWtest123',
                        info: 'The address is not valid. Please confirm with the recipient',
                        confirmNo: 3,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                    {
                        id: '156ec387f49b41df8724fa744fa82719',
                        trId: 2231556234,
                        amount: '0.00150000',
                        transactionFee: '0.004',
                        coin: 'BTC',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                        txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                        applyTime: '2019-09-24 12:43:45',
                        network: 'BTC',
                        transferType: 0,
                        info: '',
                        confirmNo: 2,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'withdrawHistoryV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV2Response>)
            );
            const response = await client.withdrawHistoryV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawHistoryV2() successfully with optional parameters', async () => {
            const params: WithdrawHistoryV2Request = {
                trId: '1',
                txId: '1',
                withdrawOrderId: '1',
                network: 'network_example',
                coin: 'coin_example',
                travelRuleStatus: 789,
                offset: 0,
                limit: 7,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 'b6ae22b3aa844210a7041aee7589627c',
                        trId: 1234456,
                        amount: '8.91000000',
                        transactionFee: '0.004',
                        coin: 'USDT',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                        addressTag: '1231212',
                        txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                        applyTime: '2019-10-12 11:12:02',
                        network: 'ETH',
                        transferType: 0,
                        withdrawOrderId: 'WITHDRAWtest123',
                        info: 'The address is not valid. Please confirm with the recipient',
                        confirmNo: 3,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                    {
                        id: '156ec387f49b41df8724fa744fa82719',
                        trId: 2231556234,
                        amount: '0.00150000',
                        transactionFee: '0.004',
                        coin: 'BTC',
                        withdrawalStatus: 6,
                        travelRuleStatus: 0,
                        address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                        txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                        applyTime: '2019-09-24 12:43:45',
                        network: 'BTC',
                        transferType: 0,
                        info: '',
                        confirmNo: 2,
                        walletType: 1,
                        txKey: '',
                        questionnaire: '{"question1":"answer1","question2":"answer2"}',
                        completeTime: '2023-03-23 16:52:41',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'withdrawHistoryV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV2Response>)
            );
            const response = await client.withdrawHistoryV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawHistoryV2').mockRejectedValueOnce(mockError);
            await expect(client.withdrawHistoryV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawTravelRule()', () => {
        it('should execute withdrawTravelRule() successfully with required parameters only', async () => {
            const params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = JSONParse(
                JSONStringify({ trId: 123456, accpted: true, info: 'Withdraw request accepted' })
            );

            const spy = jest.spyOn(client, 'withdrawTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawTravelRuleResponse>)
            );
            const response = await client.withdrawTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawTravelRule() successfully with optional parameters', async () => {
            const params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
                withdrawOrderId: '1',
                network: 'network_example',
                addressTag: 'addressTag_example',
                transactionFeeFlag: false,
                name: 'name_example',
                walletType: 0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({ trId: 123456, accpted: true, info: 'Withdraw request accepted' })
            );

            const spy = jest.spyOn(client, 'withdrawTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawTravelRuleResponse>)
            );
            const response = await client.withdrawTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw RequiredError when address is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.address;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter address was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                questionnaire: 'questionnaire_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawTravelRule').mockRejectedValueOnce(mockError);
            await expect(client.withdrawTravelRule(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
