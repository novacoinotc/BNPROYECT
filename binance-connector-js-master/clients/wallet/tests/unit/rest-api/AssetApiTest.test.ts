/**
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AssetApi } from '../../../src/rest-api';
import {
    AssetDetailRequest,
    AssetDividendRecordRequest,
    DustConvertRequest,
    DustConvertibleAssetsRequest,
    DustTransferRequest,
    DustlogRequest,
    FundingWalletRequest,
    GetAssetsThatCanBeConvertedIntoBnbRequest,
    GetCloudMiningPaymentAndRefundHistoryRequest,
    QueryUserDelegationHistoryRequest,
    QueryUserUniversalTransferHistoryRequest,
    QueryUserWalletBalanceRequest,
    ToggleBnbBurnOnSpotTradeAndMarginInterestRequest,
    TradeFeeRequest,
    UserAssetRequest,
    UserUniversalTransferRequest,
} from '../../../src/rest-api';
import type {
    AssetDetailResponse,
    AssetDividendRecordResponse,
    DustConvertResponse,
    DustConvertibleAssetsResponse,
    DustTransferResponse,
    DustlogResponse,
    FundingWalletResponse,
    GetAssetsThatCanBeConvertedIntoBnbResponse,
    GetCloudMiningPaymentAndRefundHistoryResponse,
    GetOpenSymbolListResponse,
    QueryUserDelegationHistoryResponse,
    QueryUserUniversalTransferHistoryResponse,
    QueryUserWalletBalanceResponse,
    ToggleBnbBurnOnSpotTradeAndMarginInterestResponse,
    TradeFeeResponse,
    UserAssetResponse,
    UserUniversalTransferResponse,
} from '../../../src/rest-api/types';

describe('AssetApi', () => {
    let client: AssetApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AssetApi(config);
    });

    describe('assetDetail()', () => {
        it('should execute assetDetail() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    CTR: {
                        minWithdrawAmount: '70.00000000',
                        depositStatus: false,
                        withdrawFee: 35,
                        withdrawStatus: true,
                        depositTip: 'Delisted, Deposit Suspended',
                    },
                    SKY: {
                        minWithdrawAmount: '0.02000000',
                        depositStatus: true,
                        withdrawFee: 0.01,
                        withdrawStatus: true,
                    },
                })
            );

            const spy = jest.spyOn(client, 'assetDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDetailResponse>)
            );
            const response = await client.assetDetail();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute assetDetail() successfully with optional parameters', async () => {
            const params: AssetDetailRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    CTR: {
                        minWithdrawAmount: '70.00000000',
                        depositStatus: false,
                        withdrawFee: 35,
                        withdrawStatus: true,
                        depositTip: 'Delisted, Deposit Suspended',
                    },
                    SKY: {
                        minWithdrawAmount: '0.02000000',
                        depositStatus: true,
                        withdrawFee: 0.01,
                        withdrawStatus: true,
                    },
                })
            );

            const spy = jest.spyOn(client, 'assetDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDetailResponse>)
            );
            const response = await client.assetDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'assetDetail').mockRejectedValueOnce(mockError);
            await expect(client.assetDetail()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('assetDividendRecord()', () => {
        it('should execute assetDividendRecord() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            id: 1637366104,
                            amount: '10.00000000',
                            asset: 'BHFT',
                            divTime: 1563189166000,
                            enInfo: 'BHFT distribution',
                            tranId: 2968885920,
                        },
                        {
                            id: 1631750237,
                            amount: '10.00000000',
                            asset: 'BHFT',
                            divTime: 1563189165000,
                            enInfo: 'BHFT distribution',
                            tranId: 2968885920,
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'assetDividendRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDividendRecordResponse>)
            );
            const response = await client.assetDividendRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute assetDividendRecord() successfully with optional parameters', async () => {
            const params: AssetDividendRecordRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 7,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    rows: [
                        {
                            id: 1637366104,
                            amount: '10.00000000',
                            asset: 'BHFT',
                            divTime: 1563189166000,
                            enInfo: 'BHFT distribution',
                            tranId: 2968885920,
                        },
                        {
                            id: 1631750237,
                            amount: '10.00000000',
                            asset: 'BHFT',
                            divTime: 1563189165000,
                            enInfo: 'BHFT distribution',
                            tranId: 2968885920,
                        },
                    ],
                    total: 2,
                })
            );

            const spy = jest.spyOn(client, 'assetDividendRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDividendRecordResponse>)
            );
            const response = await client.assetDividendRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'assetDividendRecord').mockRejectedValueOnce(mockError);
            await expect(client.assetDividendRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dustConvert()', () => {
        it('should execute dustConvert() successfully with required parameters only', async () => {
            const params: DustConvertRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalTransfered: '3.5971223',
                    totalServiceCharge: '0.0794964',
                    transferResult: [
                        {
                            tranId: 2987331510,
                            fromAsset: 'USDT',
                            amount: '1',
                            transferedAmount: '3.5971223',
                            serviceChargeAmount: '0.0794964',
                            operateTime: 1765212029749,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustConvert').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustConvertResponse>)
            );
            const response = await client.dustConvert(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dustConvert() successfully with optional parameters', async () => {
            const params: DustConvertRequest = {
                asset: 'asset_example',
                clientId: '1',
                targetAsset: 'targetAsset_example',
                thirdPartyClientId: '1',
                dustQuotaAssetToTargetAssetPrice: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalTransfered: '3.5971223',
                    totalServiceCharge: '0.0794964',
                    transferResult: [
                        {
                            tranId: 2987331510,
                            fromAsset: 'USDT',
                            amount: '1',
                            transferedAmount: '3.5971223',
                            serviceChargeAmount: '0.0794964',
                            operateTime: 1765212029749,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustConvert').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustConvertResponse>)
            );
            const response = await client.dustConvert(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: DustConvertRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.dustConvert(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling dustConvert.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DustConvertRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dustConvert').mockRejectedValueOnce(mockError);
            await expect(client.dustConvert(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dustConvertibleAssets()', () => {
        it('should execute dustConvertibleAssets() successfully with required parameters only', async () => {
            const params: DustConvertibleAssetsRequest = {
                targetAsset: 'targetAsset_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    dribbletPercentage: '0.02',
                    totalTransferQuotaAssetAmount: '0.7899968',
                    totalTransferTargetAssetAmount: '0.7899968',
                    dribbletBase: '10',
                    details: [
                        {
                            asset: 'AR',
                            assetFullName: 'AR',
                            amountFree: '0.00856',
                            exchange: '0.00073616',
                            toQuotaAssetAmount: '0.036808',
                            toTargetAssetAmount: '0.036808',
                            toTargetAssetOffExchange: '0.03607184',
                        },
                        {
                            asset: 'BNB',
                            assetFullName: 'BNB',
                            amountFree: '0.00082768',
                            exchange: '0.01506378',
                            toQuotaAssetAmount: '0.7531888',
                            toTargetAssetAmount: '0.7531888',
                            toTargetAssetOffExchange: '0.73812502',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustConvertibleAssets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustConvertibleAssetsResponse>)
            );
            const response = await client.dustConvertibleAssets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dustConvertibleAssets() successfully with optional parameters', async () => {
            const params: DustConvertibleAssetsRequest = {
                targetAsset: 'targetAsset_example',
                dustQuotaAssetToTargetAssetPrice: 1.0,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    dribbletPercentage: '0.02',
                    totalTransferQuotaAssetAmount: '0.7899968',
                    totalTransferTargetAssetAmount: '0.7899968',
                    dribbletBase: '10',
                    details: [
                        {
                            asset: 'AR',
                            assetFullName: 'AR',
                            amountFree: '0.00856',
                            exchange: '0.00073616',
                            toQuotaAssetAmount: '0.036808',
                            toTargetAssetAmount: '0.036808',
                            toTargetAssetOffExchange: '0.03607184',
                        },
                        {
                            asset: 'BNB',
                            assetFullName: 'BNB',
                            amountFree: '0.00082768',
                            exchange: '0.01506378',
                            toQuotaAssetAmount: '0.7531888',
                            toTargetAssetAmount: '0.7531888',
                            toTargetAssetOffExchange: '0.73812502',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustConvertibleAssets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustConvertibleAssetsResponse>)
            );
            const response = await client.dustConvertibleAssets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when targetAsset is missing', async () => {
            const _params: DustConvertibleAssetsRequest = {
                targetAsset: 'targetAsset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.targetAsset;

            await expect(client.dustConvertibleAssets(params)).rejects.toThrow(
                'Required parameter targetAsset was null or undefined when calling dustConvertibleAssets.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DustConvertibleAssetsRequest = {
                targetAsset: 'targetAsset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'dustConvertibleAssets')
                .mockRejectedValueOnce(mockError);
            await expect(client.dustConvertibleAssets(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dustTransfer()', () => {
        it('should execute dustTransfer() successfully with required parameters only', async () => {
            const params: DustTransferRequest = {
                asset: 'asset_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalServiceCharge: '0.02102542',
                    totalTransfered: '1.05127099',
                    transferResult: [
                        {
                            amount: '0.03000000',
                            fromAsset: 'ETH',
                            operateTime: 1563368549307,
                            serviceChargeAmount: '0.00500000',
                            tranId: 2970932918,
                            transferedAmount: '0.25000000',
                        },
                        {
                            amount: '0.09000000',
                            fromAsset: 'LTC',
                            operateTime: 1563368549404,
                            serviceChargeAmount: '0.01548000',
                            tranId: 2970932918,
                            transferedAmount: '0.77400000',
                        },
                        {
                            amount: '248.61878453',
                            fromAsset: 'TRX',
                            operateTime: 1563368549489,
                            serviceChargeAmount: '0.00054542',
                            tranId: 2970932918,
                            transferedAmount: '0.02727099',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustTransferResponse>)
            );
            const response = await client.dustTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dustTransfer() successfully with optional parameters', async () => {
            const params: DustTransferRequest = {
                asset: 'asset_example',
                accountType: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    totalServiceCharge: '0.02102542',
                    totalTransfered: '1.05127099',
                    transferResult: [
                        {
                            amount: '0.03000000',
                            fromAsset: 'ETH',
                            operateTime: 1563368549307,
                            serviceChargeAmount: '0.00500000',
                            tranId: 2970932918,
                            transferedAmount: '0.25000000',
                        },
                        {
                            amount: '0.09000000',
                            fromAsset: 'LTC',
                            operateTime: 1563368549404,
                            serviceChargeAmount: '0.01548000',
                            tranId: 2970932918,
                            transferedAmount: '0.77400000',
                        },
                        {
                            amount: '248.61878453',
                            fromAsset: 'TRX',
                            operateTime: 1563368549489,
                            serviceChargeAmount: '0.00054542',
                            tranId: 2970932918,
                            transferedAmount: '0.02727099',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustTransferResponse>)
            );
            const response = await client.dustTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: DustTransferRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.dustTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling dustTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DustTransferRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dustTransfer').mockRejectedValueOnce(mockError);
            await expect(client.dustTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dustlog()', () => {
        it('should execute dustlog() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    total: 8,
                    userAssetDribblets: [
                        {
                            operateTime: 1615985535000,
                            totalTransferedAmount: '0.00132256',
                            totalServiceChargeAmount: '0.00002699',
                            transId: 45178372831,
                            userAssetDribbletDetails: [
                                {
                                    transId: 4359321,
                                    serviceChargeAmount: '0.000009',
                                    amount: '0.0009',
                                    operateTime: 1615985535000,
                                    transferedAmount: '0.000441',
                                    fromAsset: 'USDT',
                                },
                                {
                                    transId: 4359321,
                                    serviceChargeAmount: '0.00001799',
                                    amount: '0.0009',
                                    operateTime: 1615985535000,
                                    transferedAmount: '0.00088156',
                                    fromAsset: 'ETH',
                                },
                            ],
                        },
                        {
                            operateTime: 1616203180000,
                            totalTransferedAmount: '0.00058795',
                            totalServiceChargeAmount: '0.000012',
                            transId: 4357015,
                            userAssetDribbletDetails: [
                                {
                                    transId: 4357015,
                                    serviceChargeAmount: '0.00001',
                                    amount: '0.001',
                                    operateTime: 1616203180000,
                                    transferedAmount: '0.00049',
                                    fromAsset: 'USDT',
                                },
                                {
                                    transId: 4357015,
                                    serviceChargeAmount: '0.000002',
                                    amount: '0.0001',
                                    operateTime: 1616203180000,
                                    transferedAmount: '0.00009795',
                                    fromAsset: 'ETH',
                                },
                            ],
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustlog').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustlogResponse>)
            );
            const response = await client.dustlog();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dustlog() successfully with optional parameters', async () => {
            const params: DustlogRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 8,
                    userAssetDribblets: [
                        {
                            operateTime: 1615985535000,
                            totalTransferedAmount: '0.00132256',
                            totalServiceChargeAmount: '0.00002699',
                            transId: 45178372831,
                            userAssetDribbletDetails: [
                                {
                                    transId: 4359321,
                                    serviceChargeAmount: '0.000009',
                                    amount: '0.0009',
                                    operateTime: 1615985535000,
                                    transferedAmount: '0.000441',
                                    fromAsset: 'USDT',
                                },
                                {
                                    transId: 4359321,
                                    serviceChargeAmount: '0.00001799',
                                    amount: '0.0009',
                                    operateTime: 1615985535000,
                                    transferedAmount: '0.00088156',
                                    fromAsset: 'ETH',
                                },
                            ],
                        },
                        {
                            operateTime: 1616203180000,
                            totalTransferedAmount: '0.00058795',
                            totalServiceChargeAmount: '0.000012',
                            transId: 4357015,
                            userAssetDribbletDetails: [
                                {
                                    transId: 4357015,
                                    serviceChargeAmount: '0.00001',
                                    amount: '0.001',
                                    operateTime: 1616203180000,
                                    transferedAmount: '0.00049',
                                    fromAsset: 'USDT',
                                },
                                {
                                    transId: 4357015,
                                    serviceChargeAmount: '0.000002',
                                    amount: '0.0001',
                                    operateTime: 1616203180000,
                                    transferedAmount: '0.00009795',
                                    fromAsset: 'ETH',
                                },
                            ],
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'dustlog').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustlogResponse>)
            );
            const response = await client.dustlog(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dustlog').mockRejectedValueOnce(mockError);
            await expect(client.dustlog()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fundingWallet()', () => {
        it('should execute fundingWallet() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        free: '1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        btcValuation: '0.00000091',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fundingWallet').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundingWalletResponse>)
            );
            const response = await client.fundingWallet();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundingWallet() successfully with optional parameters', async () => {
            const params: FundingWalletRequest = {
                asset: 'asset_example',
                needBtcValuation: 'needBtcValuation_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'USDT',
                        free: '1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        btcValuation: '0.00000091',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fundingWallet').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundingWalletResponse>)
            );
            const response = await client.fundingWallet(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fundingWallet').mockRejectedValueOnce(mockError);
            await expect(client.fundingWallet()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAssetsThatCanBeConvertedIntoBnb()', () => {
        it('should execute getAssetsThatCanBeConvertedIntoBnb() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    details: [
                        {
                            asset: 'ADA',
                            assetFullName: 'ADA',
                            amountFree: '6.21',
                            toBTC: '0.00016848',
                            toBNB: '0.01777302',
                            toBNBOffExchange: '0.01741756',
                            exchange: '0.00035546',
                        },
                    ],
                    totalTransferBtc: '0.00016848',
                    totalTransferBNB: '0.01777302',
                    dribbletPercentage: '0.02',
                })
            );

            const spy = jest.spyOn(client, 'getAssetsThatCanBeConvertedIntoBnb').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAssetsThatCanBeConvertedIntoBnbResponse>)
            );
            const response = await client.getAssetsThatCanBeConvertedIntoBnb();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAssetsThatCanBeConvertedIntoBnb() successfully with optional parameters', async () => {
            const params: GetAssetsThatCanBeConvertedIntoBnbRequest = {
                accountType: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    details: [
                        {
                            asset: 'ADA',
                            assetFullName: 'ADA',
                            amountFree: '6.21',
                            toBTC: '0.00016848',
                            toBNB: '0.01777302',
                            toBNBOffExchange: '0.01741756',
                            exchange: '0.00035546',
                        },
                    ],
                    totalTransferBtc: '0.00016848',
                    totalTransferBNB: '0.01777302',
                    dribbletPercentage: '0.02',
                })
            );

            const spy = jest.spyOn(client, 'getAssetsThatCanBeConvertedIntoBnb').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAssetsThatCanBeConvertedIntoBnbResponse>)
            );
            const response = await client.getAssetsThatCanBeConvertedIntoBnb(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getAssetsThatCanBeConvertedIntoBnb')
                .mockRejectedValueOnce(mockError);
            await expect(client.getAssetsThatCanBeConvertedIntoBnb()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getCloudMiningPaymentAndRefundHistory()', () => {
        it('should execute getCloudMiningPaymentAndRefundHistory() successfully with required parameters only', async () => {
            const params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 5,
                    rows: [
                        {
                            createTime: 1667880112000,
                            tranId: 121230610120,
                            type: 248,
                            asset: 'USDT',
                            amount: '25.0068',
                            status: 'S',
                        },
                        {
                            createTime: 1666776366000,
                            tranId: 119991507468,
                            type: 249,
                            asset: 'USDT',
                            amount: '0.027',
                            status: 'S',
                        },
                        {
                            createTime: 1666764505000,
                            tranId: 119977966327,
                            type: 248,
                            asset: 'USDT',
                            amount: '0.027',
                            status: 'S',
                        },
                        {
                            createTime: 1666758189000,
                            tranId: 119973601721,
                            type: 248,
                            asset: 'USDT',
                            amount: '0.018',
                            status: 'S',
                        },
                        {
                            createTime: 1666757278000,
                            tranId: 119973028551,
                            type: 248,
                            asset: 'USDT',
                            amount: '0.018',
                            status: 'S',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getCloudMiningPaymentAndRefundHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCloudMiningPaymentAndRefundHistoryResponse>)
            );
            const response = await client.getCloudMiningPaymentAndRefundHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCloudMiningPaymentAndRefundHistory() successfully with optional parameters', async () => {
            const params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                tranId: 1,
                clientTranId: '1',
                asset: 'asset_example',
                current: 1,
                size: 10,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 5,
                    rows: [
                        {
                            createTime: 1667880112000,
                            tranId: 121230610120,
                            type: 248,
                            asset: 'USDT',
                            amount: '25.0068',
                            status: 'S',
                        },
                        {
                            createTime: 1666776366000,
                            tranId: 119991507468,
                            type: 249,
                            asset: 'USDT',
                            amount: '0.027',
                            status: 'S',
                        },
                        {
                            createTime: 1666764505000,
                            tranId: 119977966327,
                            type: 248,
                            asset: 'USDT',
                            amount: '0.027',
                            status: 'S',
                        },
                        {
                            createTime: 1666758189000,
                            tranId: 119973601721,
                            type: 248,
                            asset: 'USDT',
                            amount: '0.018',
                            status: 'S',
                        },
                        {
                            createTime: 1666757278000,
                            tranId: 119973028551,
                            type: 248,
                            asset: 'USDT',
                            amount: '0.018',
                            status: 'S',
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'getCloudMiningPaymentAndRefundHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCloudMiningPaymentAndRefundHistoryResponse>)
            );
            const response = await client.getCloudMiningPaymentAndRefundHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getCloudMiningPaymentAndRefundHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getCloudMiningPaymentAndRefundHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getCloudMiningPaymentAndRefundHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getCloudMiningPaymentAndRefundHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCloudMiningPaymentAndRefundHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCloudMiningPaymentAndRefundHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOpenSymbolList()', () => {
        it('should execute getOpenSymbolList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { openTime: 1686161202000, symbols: ['BNBBTC', 'BNBETH'] },
                    { openTime: 1686222232000, symbols: ['BTCUSDT'] },
                ])
            );

            const spy = jest.spyOn(client, 'getOpenSymbolList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenSymbolListResponse>)
            );
            const response = await client.getOpenSymbolList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOpenSymbolList').mockRejectedValueOnce(mockError);
            await expect(client.getOpenSymbolList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUserDelegationHistory()', () => {
        it('should execute queryUserDelegationHistory() successfully with required parameters only', async () => {
            const params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 3316,
                    rows: [
                        {
                            clientTranId: '293915932290879488',
                            transferType: 'Undelegate',
                            asset: 'ETH',
                            amount: '1',
                            time: 1695205406000,
                        },
                        {
                            clientTranId: '293915892281413632',
                            transferType: 'Delegate',
                            asset: 'ETH',
                            amount: '1',
                            time: 1695205396000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryUserDelegationHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserDelegationHistoryResponse>)
            );
            const response = await client.queryUserDelegationHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserDelegationHistory() successfully with optional parameters', async () => {
            const params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                type: 'type_example',
                asset: 'asset_example',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 3316,
                    rows: [
                        {
                            clientTranId: '293915932290879488',
                            transferType: 'Undelegate',
                            asset: 'ETH',
                            amount: '1',
                            time: 1695205406000,
                        },
                        {
                            clientTranId: '293915892281413632',
                            transferType: 'Delegate',
                            asset: 'ETH',
                            amount: '1',
                            time: 1695205396000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryUserDelegationHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserDelegationHistoryResponse>)
            );
            const response = await client.queryUserDelegationHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryUserDelegationHistory.'
            );
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryUserDelegationHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryUserDelegationHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserDelegationHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUserUniversalTransferHistory()', () => {
        it('should execute queryUserUniversalTransferHistory() successfully with required parameters only', async () => {
            const params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    rows: [
                        {
                            asset: 'USDT',
                            amount: '1',
                            type: 'MAIN_UMFUTURE',
                            status: 'CONFIRMED',
                            tranId: 11415955596,
                            timestamp: 1544433328000,
                        },
                        {
                            asset: 'USDT',
                            amount: '2',
                            type: 'MAIN_UMFUTURE',
                            status: 'CONFIRMED',
                            tranId: 11366865406,
                            timestamp: 1544433328000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryUserUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUserUniversalTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserUniversalTransferHistory() successfully with optional parameters', async () => {
            const params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                fromSymbol: 'fromSymbol_example',
                toSymbol: 'toSymbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    total: 2,
                    rows: [
                        {
                            asset: 'USDT',
                            amount: '1',
                            type: 'MAIN_UMFUTURE',
                            status: 'CONFIRMED',
                            tranId: 11415955596,
                            timestamp: 1544433328000,
                        },
                        {
                            asset: 'USDT',
                            amount: '2',
                            type: 'MAIN_UMFUTURE',
                            status: 'CONFIRMED',
                            tranId: 11366865406,
                            timestamp: 1544433328000,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'queryUserUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUserUniversalTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.queryUserUniversalTransferHistory(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling queryUserUniversalTransferHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserUniversalTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserUniversalTransferHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUserWalletBalance()', () => {
        it('should execute queryUserWalletBalance() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { activate: true, balance: '0', walletName: 'Spot' },
                    { activate: true, balance: '0', walletName: 'Funding' },
                    { activate: true, balance: '0', walletName: 'Cross Margin' },
                    { activate: true, balance: '0', walletName: 'Isolated Margin' },
                    { activate: true, balance: '0.71842752', walletName: 'USD-M Futures' },
                    { activate: true, balance: '0', walletName: 'COIN-M Futures' },
                    { activate: true, balance: '0', walletName: 'Earn' },
                    { activate: false, balance: '0', walletName: 'Options' },
                    { activate: true, balance: '0', walletName: 'Trading Bots' },
                    { activate: true, balance: '0', walletName: 'Copy Trading' },
                ])
            );

            const spy = jest.spyOn(client, 'queryUserWalletBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserWalletBalanceResponse>)
            );
            const response = await client.queryUserWalletBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserWalletBalance() successfully with optional parameters', async () => {
            const params: QueryUserWalletBalanceRequest = {
                quoteAsset: 'BTC',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { activate: true, balance: '0', walletName: 'Spot' },
                    { activate: true, balance: '0', walletName: 'Funding' },
                    { activate: true, balance: '0', walletName: 'Cross Margin' },
                    { activate: true, balance: '0', walletName: 'Isolated Margin' },
                    { activate: true, balance: '0.71842752', walletName: 'USD-M Futures' },
                    { activate: true, balance: '0', walletName: 'COIN-M Futures' },
                    { activate: true, balance: '0', walletName: 'Earn' },
                    { activate: false, balance: '0', walletName: 'Options' },
                    { activate: true, balance: '0', walletName: 'Trading Bots' },
                    { activate: true, balance: '0', walletName: 'Copy Trading' },
                ])
            );

            const spy = jest.spyOn(client, 'queryUserWalletBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserWalletBalanceResponse>)
            );
            const response = await client.queryUserWalletBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserWalletBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserWalletBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('toggleBnbBurnOnSpotTradeAndMarginInterest()', () => {
        it('should execute toggleBnbBurnOnSpotTradeAndMarginInterest() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ spotBNBBurn: true, interestBNBBurn: false }));

            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnSpotTradeAndMarginInterest')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ToggleBnbBurnOnSpotTradeAndMarginInterestResponse>)
                );
            const response = await client.toggleBnbBurnOnSpotTradeAndMarginInterest();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute toggleBnbBurnOnSpotTradeAndMarginInterest() successfully with optional parameters', async () => {
            const params: ToggleBnbBurnOnSpotTradeAndMarginInterestRequest = {
                spotBNBBurn: 'spotBNBBurn_example',
                interestBNBBurn: 'interestBNBBurn_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ spotBNBBurn: true, interestBNBBurn: false }));

            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnSpotTradeAndMarginInterest')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ToggleBnbBurnOnSpotTradeAndMarginInterestResponse>)
                );
            const response = await client.toggleBnbBurnOnSpotTradeAndMarginInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnSpotTradeAndMarginInterest')
                .mockRejectedValueOnce(mockError);
            await expect(client.toggleBnbBurnOnSpotTradeAndMarginInterest()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('tradeFee()', () => {
        it('should execute tradeFee() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'ADABNB', makerCommission: '0.001', takerCommission: '0.001' },
                    { symbol: 'BNBBTC', makerCommission: '0.001', takerCommission: '0.001' },
                ])
            );

            const spy = jest.spyOn(client, 'tradeFee').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TradeFeeResponse>)
            );
            const response = await client.tradeFee();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tradeFee() successfully with optional parameters', async () => {
            const params: TradeFeeRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    { symbol: 'ADABNB', makerCommission: '0.001', takerCommission: '0.001' },
                    { symbol: 'BNBBTC', makerCommission: '0.001', takerCommission: '0.001' },
                ])
            );

            const spy = jest.spyOn(client, 'tradeFee').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TradeFeeResponse>)
            );
            const response = await client.tradeFee(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tradeFee').mockRejectedValueOnce(mockError);
            await expect(client.tradeFee()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userAsset()', () => {
        it('should execute userAsset() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'AVAX',
                        free: '1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'BCH',
                        free: '0.9',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'BNB',
                        free: '887.47061626',
                        locked: '0',
                        freeze: '10.52',
                        withdrawing: '0.1',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'BUSD',
                        free: '9999.7',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'SHIB',
                        free: '532.32',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'USDT',
                        free: '50300000001.44911105',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'WRZ',
                        free: '1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'userAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserAssetResponse>)
            );
            const response = await client.userAsset();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userAsset() successfully with optional parameters', async () => {
            const params: UserAssetRequest = {
                asset: 'asset_example',
                needBtcValuation: true,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        asset: 'AVAX',
                        free: '1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'BCH',
                        free: '0.9',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'BNB',
                        free: '887.47061626',
                        locked: '0',
                        freeze: '10.52',
                        withdrawing: '0.1',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'BUSD',
                        free: '9999.7',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'SHIB',
                        free: '532.32',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'USDT',
                        free: '50300000001.44911105',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                    {
                        asset: 'WRZ',
                        free: '1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoable: '0',
                        btcValuation: '0',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'userAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserAssetResponse>)
            );
            const response = await client.userAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userAsset').mockRejectedValueOnce(mockError);
            await expect(client.userAsset()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userUniversalTransfer()', () => {
        it('should execute userUniversalTransfer() successfully with required parameters only', async () => {
            const params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 13526853623 }));

            const spy = jest.spyOn(client, 'userUniversalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserUniversalTransferResponse>)
            );
            const response = await client.userUniversalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userUniversalTransfer() successfully with optional parameters', async () => {
            const params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1.0,
                fromSymbol: 'fromSymbol_example',
                toSymbol: 'toSymbol_example',
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ tranId: 13526853623 }));

            const spy = jest.spyOn(client, 'userUniversalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserUniversalTransferResponse>)
            );
            const response = await client.userUniversalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.userUniversalTransfer(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling userUniversalTransfer.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.userUniversalTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling userUniversalTransfer.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.userUniversalTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling userUniversalTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'userUniversalTransfer')
                .mockRejectedValueOnce(mockError);
            await expect(client.userUniversalTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
