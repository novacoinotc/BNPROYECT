/**
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { CapitalApi } from '../../../src/rest-api';
import {
    AllCoinsInformationRequest,
    DepositAddressRequest,
    DepositHistoryRequest,
    FetchDepositAddressListWithNetworkRequest,
    OneClickArrivalDepositApplyRequest,
    WithdrawRequest,
    WithdrawHistoryRequest,
} from '../../../src/rest-api';
import type {
    AllCoinsInformationResponse,
    DepositAddressResponse,
    DepositHistoryResponse,
    FetchDepositAddressListWithNetworkResponse,
    FetchWithdrawAddressListResponse,
    FetchWithdrawQuotaResponse,
    OneClickArrivalDepositApplyResponse,
    WithdrawHistoryResponse,
    WithdrawResponse,
} from '../../../src/rest-api/types';

describe('CapitalApi', () => {
    let client: CapitalApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new CapitalApi(config);
    });

    describe('allCoinsInformation()', () => {
        it('should execute allCoinsInformation() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        coin: '1MBABYDOGE',
                        depositAllEnable: true,
                        withdrawAllEnable: true,
                        name: '1M x BABYDOGE',
                        free: '34941.1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoing: '0',
                        ipoable: '0',
                        storage: '0',
                        isLegalMoney: false,
                        trading: true,
                        networkList: [
                            {
                                network: 'BSC',
                                coin: '1MBABYDOGE',
                                withdrawIntegerMultiple: '0.01',
                                isDefault: false,
                                depositEnable: true,
                                withdrawEnable: true,
                                depositDesc: '',
                                withdrawDesc: '',
                                specialTips: '',
                                specialWithdrawTips: '',
                                name: 'BNB Smart Chain (BEP20)',
                                resetAddressStatus: false,
                                addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                memoRegex: '',
                                withdrawFee: '10',
                                withdrawMin: '20',
                                withdrawMax: '9999999999',
                                withdrawInternalMin: '0.01',
                                depositDust: '0.01',
                                minConfirm: 5,
                                unLockConfirm: 0,
                                sameAddress: false,
                                withdrawTag: false,
                                estimatedArrivalTime: 1,
                                busy: false,
                                contractAddressUrl: 'https://bscscan.com/token/',
                                contractAddress: '0xc748673057861a797275cd8a068abb95a902e8de',
                                denomination: 1000000,
                            },
                            {
                                network: 'ETH',
                                coin: '1MBABYDOGE',
                                withdrawIntegerMultiple: '0.01',
                                isDefault: true,
                                depositEnable: true,
                                withdrawEnable: true,
                                depositDesc: '',
                                withdrawDesc: '',
                                specialTips: '',
                                specialWithdrawTips: '',
                                name: 'Ethereum (ERC20)',
                                resetAddressStatus: false,
                                addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                memoRegex: '',
                                withdrawFee: '1511',
                                withdrawMin: '3022',
                                withdrawMax: '9999999999',
                                withdrawInternalMin: '0.01',
                                depositDust: '0.01',
                                minConfirm: 6,
                                unLockConfirm: 64,
                                sameAddress: false,
                                withdrawTag: false,
                                estimatedArrivalTime: 2,
                                busy: false,
                                contractAddressUrl: 'https://etherscan.io/address/',
                                contractAddress: '0xac57de9c1a09fec648e93eb98875b212db0d460b',
                                denomination: 1000000,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allCoinsInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllCoinsInformationResponse>)
            );
            const response = await client.allCoinsInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allCoinsInformation() successfully with optional parameters', async () => {
            const params: AllCoinsInformationRequest = {
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        coin: '1MBABYDOGE',
                        depositAllEnable: true,
                        withdrawAllEnable: true,
                        name: '1M x BABYDOGE',
                        free: '34941.1',
                        locked: '0',
                        freeze: '0',
                        withdrawing: '0',
                        ipoing: '0',
                        ipoable: '0',
                        storage: '0',
                        isLegalMoney: false,
                        trading: true,
                        networkList: [
                            {
                                network: 'BSC',
                                coin: '1MBABYDOGE',
                                withdrawIntegerMultiple: '0.01',
                                isDefault: false,
                                depositEnable: true,
                                withdrawEnable: true,
                                depositDesc: '',
                                withdrawDesc: '',
                                specialTips: '',
                                specialWithdrawTips: '',
                                name: 'BNB Smart Chain (BEP20)',
                                resetAddressStatus: false,
                                addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                memoRegex: '',
                                withdrawFee: '10',
                                withdrawMin: '20',
                                withdrawMax: '9999999999',
                                withdrawInternalMin: '0.01',
                                depositDust: '0.01',
                                minConfirm: 5,
                                unLockConfirm: 0,
                                sameAddress: false,
                                withdrawTag: false,
                                estimatedArrivalTime: 1,
                                busy: false,
                                contractAddressUrl: 'https://bscscan.com/token/',
                                contractAddress: '0xc748673057861a797275cd8a068abb95a902e8de',
                                denomination: 1000000,
                            },
                            {
                                network: 'ETH',
                                coin: '1MBABYDOGE',
                                withdrawIntegerMultiple: '0.01',
                                isDefault: true,
                                depositEnable: true,
                                withdrawEnable: true,
                                depositDesc: '',
                                withdrawDesc: '',
                                specialTips: '',
                                specialWithdrawTips: '',
                                name: 'Ethereum (ERC20)',
                                resetAddressStatus: false,
                                addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                memoRegex: '',
                                withdrawFee: '1511',
                                withdrawMin: '3022',
                                withdrawMax: '9999999999',
                                withdrawInternalMin: '0.01',
                                depositDust: '0.01',
                                minConfirm: 6,
                                unLockConfirm: 64,
                                sameAddress: false,
                                withdrawTag: false,
                                estimatedArrivalTime: 2,
                                busy: false,
                                contractAddressUrl: 'https://etherscan.io/address/',
                                contractAddress: '0xac57de9c1a09fec648e93eb98875b212db0d460b',
                                denomination: 1000000,
                            },
                        ],
                    },
                ])
            );

            const spy = jest.spyOn(client, 'allCoinsInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllCoinsInformationResponse>)
            );
            const response = await client.allCoinsInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allCoinsInformation').mockRejectedValueOnce(mockError);
            await expect(client.allCoinsInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositAddress()', () => {
        it('should execute depositAddress() successfully with required parameters only', async () => {
            const params: DepositAddressRequest = {
                coin: 'coin_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    address: '1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
                    coin: 'BTC',
                    tag: '',
                    url: 'https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
                })
            );

            const spy = jest.spyOn(client, 'depositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAddressResponse>)
            );
            const response = await client.depositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositAddress() successfully with optional parameters', async () => {
            const params: DepositAddressRequest = {
                coin: 'coin_example',
                network: 'network_example',
                amount: 1.0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    address: '1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
                    coin: 'BTC',
                    tag: '',
                    url: 'https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
                })
            );

            const spy = jest.spyOn(client, 'depositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAddressResponse>)
            );
            const response = await client.depositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: DepositAddressRequest = {
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.depositAddress(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling depositAddress.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepositAddressRequest = {
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depositAddress').mockRejectedValueOnce(mockError);
            await expect(client.depositAddress(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositHistory()', () => {
        it('should execute depositHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: '769800519366885376',
                        amount: '0.001',
                        coin: 'BNB',
                        network: 'BNB',
                        status: 1,
                        address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                        addressTag: '101764890',
                        txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                        insertTime: 1661493146000,
                        completeTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        travelRuleStatus: 0,
                    },
                    {
                        id: '769754833590042625',
                        amount: '0.50000000',
                        coin: 'IOTA',
                        network: 'IOTA',
                        status: 1,
                        address:
                            'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                        addressTag: '',
                        txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                        insertTime: 1599620082000,
                        completeTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        travelRuleStatus: 1,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'depositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryResponse>)
            );
            const response = await client.depositHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositHistory() successfully with optional parameters', async () => {
            const params: DepositHistoryRequest = {
                includeSource: false,
                coin: 'coin_example',
                status: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                offset: 0,
                limit: 7,
                recvWindow: 5000,
                txId: '1',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: '769800519366885376',
                        amount: '0.001',
                        coin: 'BNB',
                        network: 'BNB',
                        status: 1,
                        address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                        addressTag: '101764890',
                        txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                        insertTime: 1661493146000,
                        completeTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        travelRuleStatus: 0,
                    },
                    {
                        id: '769754833590042625',
                        amount: '0.50000000',
                        coin: 'IOTA',
                        network: 'IOTA',
                        status: 1,
                        address:
                            'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                        addressTag: '',
                        txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                        insertTime: 1599620082000,
                        completeTime: 1661493146000,
                        transferType: 0,
                        confirmTimes: '1/1',
                        unlockConfirm: 0,
                        walletType: 0,
                        travelRuleStatus: 1,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'depositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryResponse>)
            );
            const response = await client.depositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depositHistory').mockRejectedValueOnce(mockError);
            await expect(client.depositHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fetchDepositAddressListWithNetwork()', () => {
        it('should execute fetchDepositAddressListWithNetwork() successfully with required parameters only', async () => {
            const params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        coin: 'ETH',
                        address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                        tag: '',
                        isDefault: 0,
                    },
                    {
                        coin: 'ETH',
                        address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                        tag: '',
                        isDefault: 0,
                    },
                    {
                        coin: 'ETH',
                        address: '0x00003ada75e7da97ba0db2fcde72131f712455e2',
                        tag: '',
                        isDefault: 1,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fetchDepositAddressListWithNetwork').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchDepositAddressListWithNetworkResponse>)
            );
            const response = await client.fetchDepositAddressListWithNetwork(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fetchDepositAddressListWithNetwork() successfully with optional parameters', async () => {
            const params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
                network: 'network_example',
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        coin: 'ETH',
                        address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                        tag: '',
                        isDefault: 0,
                    },
                    {
                        coin: 'ETH',
                        address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                        tag: '',
                        isDefault: 0,
                    },
                    {
                        coin: 'ETH',
                        address: '0x00003ada75e7da97ba0db2fcde72131f712455e2',
                        tag: '',
                        isDefault: 1,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fetchDepositAddressListWithNetwork').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchDepositAddressListWithNetworkResponse>)
            );
            const response = await client.fetchDepositAddressListWithNetwork(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.fetchDepositAddressListWithNetwork(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling fetchDepositAddressListWithNetwork.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fetchDepositAddressListWithNetwork')
                .mockRejectedValueOnce(mockError);
            await expect(client.fetchDepositAddressListWithNetwork(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('fetchWithdrawAddressList()', () => {
        it('should execute fetchWithdrawAddressList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        address: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',
                        addressTag: '',
                        coin: 'BTC',
                        name: 'Satoshi',
                        network: 'BTC',
                        origin: 'bla',
                        originType: 'others',
                        whiteStatus: true,
                    },
                ])
            );

            const spy = jest.spyOn(client, 'fetchWithdrawAddressList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchWithdrawAddressListResponse>)
            );
            const response = await client.fetchWithdrawAddressList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fetchWithdrawAddressList')
                .mockRejectedValueOnce(mockError);
            await expect(client.fetchWithdrawAddressList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fetchWithdrawQuota()', () => {
        it('should execute fetchWithdrawQuota() successfully with required parameters only', async () => {
            mockResponse = JSONParse(JSONStringify({ wdQuota: '10000', usedWdQuota: '1000' }));

            const spy = jest.spyOn(client, 'fetchWithdrawQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchWithdrawQuotaResponse>)
            );
            const response = await client.fetchWithdrawQuota();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fetchWithdrawQuota').mockRejectedValueOnce(mockError);
            await expect(client.fetchWithdrawQuota()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('oneClickArrivalDepositApply()', () => {
        it('should execute oneClickArrivalDepositApply() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({ code: '000000', message: 'success', data: true, success: true })
            );

            const spy = jest.spyOn(client, 'oneClickArrivalDepositApply').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OneClickArrivalDepositApplyResponse>)
            );
            const response = await client.oneClickArrivalDepositApply();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oneClickArrivalDepositApply() successfully with optional parameters', async () => {
            const params: OneClickArrivalDepositApplyRequest = {
                depositId: 1,
                txId: '1',
                subAccountId: 1,
                subUserId: 1,
            };

            mockResponse = JSONParse(
                JSONStringify({ code: '000000', message: 'success', data: true, success: true })
            );

            const spy = jest.spyOn(client, 'oneClickArrivalDepositApply').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OneClickArrivalDepositApplyResponse>)
            );
            const response = await client.oneClickArrivalDepositApply(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'oneClickArrivalDepositApply')
                .mockRejectedValueOnce(mockError);
            await expect(client.oneClickArrivalDepositApply()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdraw()', () => {
        it('should execute withdraw() successfully with required parameters only', async () => {
            const params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
            };

            mockResponse = JSONParse(JSONStringify({ id: '7213fea8e94b4a5593d507237e5a555b' }));

            const spy = jest.spyOn(client, 'withdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawResponse>)
            );
            const response = await client.withdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdraw() successfully with optional parameters', async () => {
            const params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
                withdrawOrderId: '1',
                network: 'network_example',
                addressTag: 'addressTag_example',
                transactionFeeFlag: false,
                name: 'name_example',
                walletType: 0,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(JSONStringify({ id: '7213fea8e94b4a5593d507237e5a555b' }));

            const spy = jest.spyOn(client, 'withdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawResponse>)
            );
            const response = await client.withdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.withdraw(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling withdraw.'
            );
        });

        it('should throw RequiredError when address is missing', async () => {
            const _params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.address;

            await expect(client.withdraw(params)).rejects.toThrow(
                'Required parameter address was null or undefined when calling withdraw.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.withdraw(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling withdraw.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdraw').mockRejectedValueOnce(mockError);
            await expect(client.withdraw(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawHistory()', () => {
        it('should execute withdrawHistory() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 'b6ae22b3aa844210a7041aee7589627c',
                        amount: '8.91000000',
                        transactionFee: '0.004',
                        coin: 'USDT',
                        status: 6,
                        address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                        txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                        applyTime: '2019-10-12 11:12:02',
                        network: 'ETH',
                        transferType: 0,
                        withdrawOrderId: 'WITHDRAWtest123',
                        info: 'The address is not valid. Please confirm with the recipient',
                        confirmNo: 3,
                        walletType: 1,
                        txKey: '',
                        completeTime: '2023-03-23 16:52:41',
                    },
                    {
                        id: '156ec387f49b41df8724fa744fa82719',
                        amount: '0.00150000',
                        transactionFee: '0.004',
                        coin: 'BTC',
                        status: 6,
                        address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                        txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                        applyTime: '2019-09-24 12:43:45',
                        network: 'BTC',
                        transferType: 0,
                        info: '',
                        confirmNo: 2,
                        walletType: 1,
                        txKey: '',
                        completeTime: '2023-03-23 16:52:41',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'withdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryResponse>)
            );
            const response = await client.withdrawHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawHistory() successfully with optional parameters', async () => {
            const params: WithdrawHistoryRequest = {
                coin: 'coin_example',
                withdrawOrderId: '1',
                status: 789,
                offset: 0,
                limit: 7,
                idList: 'idList_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = JSONParse(
                JSONStringify([
                    {
                        id: 'b6ae22b3aa844210a7041aee7589627c',
                        amount: '8.91000000',
                        transactionFee: '0.004',
                        coin: 'USDT',
                        status: 6,
                        address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                        txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                        applyTime: '2019-10-12 11:12:02',
                        network: 'ETH',
                        transferType: 0,
                        withdrawOrderId: 'WITHDRAWtest123',
                        info: 'The address is not valid. Please confirm with the recipient',
                        confirmNo: 3,
                        walletType: 1,
                        txKey: '',
                        completeTime: '2023-03-23 16:52:41',
                    },
                    {
                        id: '156ec387f49b41df8724fa744fa82719',
                        amount: '0.00150000',
                        transactionFee: '0.004',
                        coin: 'BTC',
                        status: 6,
                        address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                        txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                        applyTime: '2019-09-24 12:43:45',
                        network: 'BTC',
                        transferType: 0,
                        info: '',
                        confirmNo: 2,
                        walletType: 1,
                        txKey: '',
                        completeTime: '2023-03-23 16:52:41',
                    },
                ])
            );

            const spy = jest.spyOn(client, 'withdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryResponse>)
            );
            const response = await client.withdrawHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawHistory').mockRejectedValueOnce(mockError);
            await expect(client.withdrawHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
