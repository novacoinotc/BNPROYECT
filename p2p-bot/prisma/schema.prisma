// =====================================================
// PRISMA SCHEMA
// PostgreSQL database for P2P Trading Bot
// Multi-Merchant Architecture
// =====================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum TradeType {
  BUY
  SELL
}

enum OrderStatus {
  PENDING
  PAID
  APPEALING
  COMPLETED
  CANCELLED
  CANCELLED_SYSTEM
  CANCELLED_TIMEOUT
}

enum PaymentStatus {
  PENDING
  VERIFIED
  MATCHED
  RELEASED
  FAILED
  REVERSED
  THIRD_PARTY  // Payment sender doesn't match any known buyer - requires manual review
}

enum VerificationMethod {
  BANK_WEBHOOK
  OCR_RECEIPT
  MANUAL
}

// ==================== MERCHANT (NEW - Multi-tenant) ====================

/// Merchant account - each merchant has their own bot and dashboard access
model Merchant {
  id                String   @id @default(cuid())
  name              String
  email             String   @unique
  passwordHash      String

  // Binance credentials (stored encrypted in env vars per Railway project)
  // These fields are for reference/display only - actual keys are in Railway
  binanceNickname   String?

  // Bank account for webhook routing
  clabeAccount      String?  @unique
  bankName          String?

  // Roles and status
  isAdmin           Boolean  @default(false)
  isActive          Boolean  @default(true)

  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastLoginAt       DateTime?

  // Relations
  orders            Order[]
  payments          Payment[]
  botConfig         BotConfig?
  trustedBuyers     TrustedBuyer[]
  priceHistory      PriceHistory[]
  dailyStats        DailyStats[]
  buyerCache        BuyerCache[]
  alerts            Alert[]
  auditLogs         AuditLog[]
  supportRequests   SupportRequest[]
  chatMessages      ChatMessage[]

  @@index([email])
  @@index([clabeAccount])
  @@index([isActive])
}

// ==================== MODELS ====================

/// Stores all P2P orders
model Order {
  id                String      @id @default(cuid())
  orderNumber       String      @unique
  advNo             String
  tradeType         TradeType
  asset             String
  fiatUnit          String
  amount            Decimal     @db.Decimal(18, 8)
  totalPrice        Decimal     @db.Decimal(18, 2)
  unitPrice         Decimal     @db.Decimal(18, 2)
  commission        Decimal     @db.Decimal(18, 8)
  status            OrderStatus

  // Buyer info
  buyerUserNo       String
  buyerNickName     String
  buyerRealName     String?

  // Seller info
  sellerUserNo      String
  sellerNickName    String

  // Verification tracking
  verificationStatus   String?     // Current verification state
  verificationTimeline Json?       // Array of verification steps with timestamps

  // Timestamps
  binanceCreateTime DateTime
  confirmPayEndTime DateTime?
  paidAt            DateTime?
  releasedAt        DateTime?
  cancelledAt       DateTime?

  // Internal timestamps
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Dashboard control
  dismissed         Boolean     @default(false)  // Hide from dashboard when stale

  // Multi-tenant
  merchantId        String?
  merchant          Merchant?   @relation(fields: [merchantId], references: [id])

  // Relations
  payments          Payment[]
  messages          ChatMessage[]

  @@index([status])
  @@index([buyerUserNo])
  @@index([binanceCreateTime])
  @@index([verificationStatus])
  @@index([dismissed])
  @@index([merchantId])
}

/// Bank payments received via webhook
model Payment {
  id                String          @id @default(cuid())
  transactionId     String          @unique
  amount            Decimal         @db.Decimal(18, 2)
  currency          String
  senderName        String
  senderAccount     String?
  receiverAccount   String?
  concept           String?
  bankReference     String?
  bankTimestamp     DateTime

  // Matching
  status            PaymentStatus   @default(PENDING)
  matchedOrderId    String?
  matchedAt         DateTime?

  // Verification
  verificationMethod VerificationMethod?
  ocrConfidence     Float?
  receiptUrl        String?

  // Internal
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Multi-tenant
  merchantId        String?
  merchant          Merchant?       @relation(fields: [merchantId], references: [id])

  // Relations
  order             Order?          @relation(fields: [matchedOrderId], references: [id])

  @@index([status])
  @@index([amount])
  @@index([senderName])
  @@index([merchantId])
}

/// Chat messages for audit trail
model ChatMessage {
  id            String   @id @default(cuid())
  messageId     String
  orderNumber   String
  content       String?
  imageUrl      String?
  thumbnailUrl  String?
  messageType   String
  fromNickName  String
  isSelf        Boolean

  binanceTime   DateTime
  createdAt     DateTime @default(now())

  // Multi-tenant
  merchantId    String?
  merchant      Merchant? @relation(fields: [merchantId], references: [id])

  // Relations
  order         Order    @relation(fields: [orderNumber], references: [orderNumber])

  @@index([orderNumber])
  @@index([merchantId])
}

/// Price history for analytics
model PriceHistory {
  id              String   @id @default(cuid())
  asset           String
  fiat            String
  tradeType       TradeType

  referencePrice  Decimal  @db.Decimal(18, 2)
  bestCompetitor  Decimal  @db.Decimal(18, 2)
  averagePrice    Decimal  @db.Decimal(18, 2)
  ourPrice        Decimal  @db.Decimal(18, 2)
  margin          Float
  pricePosition   String

  createdAt       DateTime @default(now())

  // Multi-tenant
  merchantId      String?
  merchant        Merchant? @relation(fields: [merchantId], references: [id])

  @@index([asset, fiat])
  @@index([createdAt])
  @@index([merchantId])
}

/// Daily statistics
model DailyStats {
  id                String   @id @default(cuid())
  date              DateTime @db.Date

  // Volume
  totalOrders       Int      @default(0)
  completedOrders   Int      @default(0)
  cancelledOrders   Int      @default(0)

  // Amounts
  totalVolumeFiat   Decimal  @db.Decimal(18, 2) @default(0)
  totalVolumeAsset  Decimal  @db.Decimal(18, 8) @default(0)
  totalCommission   Decimal  @db.Decimal(18, 8) @default(0)

  // Pricing
  avgMargin         Float    @default(0)
  avgPrice          Decimal  @db.Decimal(18, 2) @default(0)

  // Performance
  avgPaymentTime    Int?     // seconds
  avgReleaseTime    Int?     // seconds
  autoReleaseRate   Float?   // percentage

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Multi-tenant
  merchantId        String?
  merchant          Merchant? @relation(fields: [merchantId], references: [id])

  @@unique([date, merchantId])
  @@index([merchantId])
}

/// Buyer reputation cache
model BuyerCache {
  id                    String   @id @default(cuid())
  userNo                String
  nickName              String

  completedOrders       Int      @default(0)
  completedOrders30d    Int      @default(0)
  finishRate            Float    @default(0)
  finishRate30d         Float    @default(0)
  avgPayTime            Int?
  creditScore           Int?
  registerDays          Int?

  // Our tracking
  ordersWithUs          Int      @default(0)
  issuesCount           Int      @default(0)
  lastOrderAt           DateTime?
  isTrusted             Boolean  @default(false)
  isBlocked             Boolean  @default(false)
  blockReason           String?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Multi-tenant
  merchantId            String?
  merchant              Merchant? @relation(fields: [merchantId], references: [id])

  @@unique([userNo, merchantId])
  @@index([nickName])
  @@index([isTrusted])
  @@index([isBlocked])
  @@index([merchantId])
}

/// Manually verified trusted buyers for auto-release
/// Uses counterPartNickName as identifier (more reliable than userNo)
model TrustedBuyer {
  id                    String   @id @default(cuid())
  counterPartNickName   String             // Binance nickname (may have duplicates like "Use***")
  buyerUserNo           String?            // Binance unique user ID - MOST SECURE identifier
  realName              String?            // Verified real name (for display only, NOT for matching!)
  verifiedAt            DateTime @default(now())
  verifiedBy            String?            // Admin who verified
  notes                 String?            // Verification notes

  // Stats
  ordersAutoReleased    Int      @default(0)
  totalAmountReleased   Decimal  @db.Decimal(18, 2) @default(0)
  lastAutoReleaseAt     DateTime?

  // Status
  isActive              Boolean  @default(true)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Multi-tenant
  merchantId            String?
  merchant              Merchant? @relation(fields: [merchantId], references: [id])

  @@unique([buyerUserNo, merchantId])
  @@index([counterPartNickName])
  @@index([buyerUserNo])
  @@index([isActive])
  @@index([merchantId])
}

/// System alerts and notifications
model Alert {
  id          String   @id @default(cuid())
  type        String   // 'reversal', 'appeal', 'high_value', 'error'
  severity    String   // 'info', 'warning', 'error', 'critical'
  title       String
  message     String
  orderNumber String?
  metadata    Json?

  acknowledged Boolean  @default(false)
  acknowledgedAt DateTime?
  acknowledgedBy String?

  createdAt   DateTime @default(now())

  // Multi-tenant
  merchantId  String?
  merchant    Merchant? @relation(fields: [merchantId], references: [id])

  @@index([type])
  @@index([severity])
  @@index([acknowledged])
  @@index([createdAt])
  @@index([merchantId])
}

/// Audit log for all bot actions
model AuditLog {
  id          String   @id @default(cuid())
  action      String   // 'order_created', 'payment_matched', 'crypto_released', etc.
  orderNumber String?
  details     Json?
  success     Boolean
  error       String?

  createdAt   DateTime @default(now())

  // Multi-tenant
  merchantId  String?
  merchant    Merchant? @relation(fields: [merchantId], references: [id])

  @@index([action])
  @@index([orderNumber])
  @@index([createdAt])
  @@index([merchantId])
}

/// Support requests from buyers who need additional help
model SupportRequest {
  id                String   @id @default(cuid())
  orderNumber       String
  buyerNickName     String
  buyerRealName     String?
  amount            Decimal  @db.Decimal(18, 2)
  message           String?  // The message that triggered the request

  // Status: PENDING, ATTENDED, CLOSED
  status            String   @default("PENDING")

  // Timestamps
  createdAt         DateTime @default(now())
  attendedAt        DateTime?
  attendedBy        String?
  closedAt          DateTime?
  notes             String?  // Notes from support

  // Multi-tenant
  merchantId        String?
  merchant          Merchant? @relation(fields: [merchantId], references: [id])

  @@index([status])
  @@index([orderNumber])
  @@index([createdAt])
  @@index([merchantId])
}

/// Bot configuration - kill switches and settings
/// Now per-merchant instead of singleton
model BotConfig {
  id                  String   @id @default(cuid())

  // Kill switches
  releaseEnabled      Boolean  @default(true)   // Auto-release bot on/off
  positioningEnabled  Boolean  @default(false)  // Positioning bot on/off

  // Positioning mode: smart | follow | manual | off
  positioningMode     String   @default("off")

  // Follow mode target (if mode = follow)
  followTargetNickName String?
  followTargetUserNo   String?

  // SELL/BUY mode config
  sellMode            String?
  sellFollowTarget    String?
  buyMode             String?
  buyFollowTarget     String?

  // Per-asset positioning configs (JSON)
  positioningConfigs  Json?

  // Smart mode filters
  smartMinUserGrade     Int      @default(2)
  smartMinFinishRate    Float    @default(0.90)
  smartMinOrderCount    Int      @default(10)
  smartMinPositiveRate  Float    @default(0.95)
  smartRequireOnline    Boolean  @default(true)
  smartMinSurplus       Float    @default(100)

  // Positioning strategy
  undercutCents         Float    @default(1)    // Centavos a bajar del mejor competidor
  matchPrice            Boolean  @default(false)

  // Auto-message after release
  autoMessageEnabled    Boolean  @default(false)
  autoMessageText       String?  @db.Text

  // Ignored advertisers (JSON array)
  ignoredAdvertisers    Json?

  // Auto-buy SPEI dispatch
  autoBuyAutoDispatch   Boolean  @default(false)  // false = manual approval, true = auto

  // Status tracking
  releaseLastActive   DateTime?
  positioningLastActive DateTime?

  // Timestamps
  updatedAt           DateTime @updatedAt
  updatedBy           String?

  // Multi-tenant - one config per merchant
  merchantId          String?  @unique
  merchant            Merchant? @relation(fields: [merchantId], references: [id])

  @@index([merchantId])
}
